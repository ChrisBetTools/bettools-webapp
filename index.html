<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BetTools ‚Äî index</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#111a2e;
      --panel2:#0f1730;
      --text:#e8eefc;
      --muted:#9fb0d0;
      --line:#223055;
      --accent:#5aa9ff;
      --good:#19c37d;
      --bad:#ff4d4f;
      --warn:#ffd166;
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --radius: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      background:linear-gradient(180deg,#070b14 0%, #0b1220 40%, #070b14 100%);
      color:var(--text);
    }

    /* Top bar */
    .topbar{
      position:sticky; top:0; z-index:30;
      display:flex; align-items:center; gap:10px;
      padding:12px 14px;
      background:rgba(10,16,31,.86);
      backdrop-filter: blur(10px);
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    .hamburger{
      width:42px; height:42px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(255,255,255,.04);
      display:grid; place-items:center;
      cursor:pointer;
      user-select:none;
    }
    .hamburger:active{transform:scale(.98)}
    .hamburger span{
      display:block;
      width:18px; height:2px;
      background:rgba(232,238,252,.92);
      border-radius:2px;
      position:relative;
    }
    .hamburger span::before,.hamburger span::after{
      content:"";
      position:absolute; left:0;
      width:18px; height:2px;
      background:rgba(232,238,252,.92);
      border-radius:2px;
    }
    .hamburger span::before{top:-6px}
    .hamburger span::after{top:6px}
    .brand{
      display:flex; flex-direction:column; line-height:1.05;
    }
    .brand b{font-size:14px; letter-spacing:.2px}
    .brand small{color:var(--muted); font-size:12px}
    .topbar .spacer{flex:1}
    .pill{
      padding:7px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.05);
      color:var(--muted);
      font-size:12px;
      display:flex; gap:8px; align-items:center;
      white-space:nowrap;
    }
    .dot{width:8px;height:8px;border-radius:50%}
    .dot.good{background:var(--good)}
    .dot.bad{background:var(--bad)}
    .dot.neu{background:#7c8fb7}

    /* Sidebar */
    .overlay{
      position:fixed; inset:0;
      background:rgba(0,0,0,.55);
      opacity:0; pointer-events:none;
      transition:opacity .18s ease;
      z-index:40;
    }
    .overlay.show{opacity:1; pointer-events:auto}
    .sidebar{
      position:fixed; top:0; left:0; bottom:0;
      width:min(82vw, 320px);
      background:linear-gradient(180deg,#0b1220 0%, #0b1220 40%, #0a1020 100%);
      border-right:1px solid rgba(255,255,255,.08);
      transform:translateX(-105%);
      transition:transform .22s ease;
      z-index:50;
      padding:14px;
      box-shadow: var(--shadow);
      display:flex; flex-direction:column; gap:10px;
    }
    .sidebar.show{transform:translateX(0)}
    .sideHeader{
      display:flex; align-items:center; justify-content:space-between;
      margin-bottom:8px;
    }
    .sideHeader b{font-size:14px}
    .closeBtn{
      width:38px;height:38px;border-radius:12px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(255,255,255,.04);
      color:var(--text);
      cursor:pointer;
    }
    .nav{
      display:flex; flex-direction:column; gap:8px;
      padding-top:6px;
    }
    .nav button{
      text-align:left;
      padding:12px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(255,255,255,.04);
      color:var(--text);
      cursor:pointer;
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      font-size:14px;
    }
    .nav button.active{border-color:rgba(90,169,255,.55); background:rgba(90,169,255,.12)}
    .nav button small{color:var(--muted); font-size:12px}
    .sideFooter{
      margin-top:auto;
      border-top:1px solid rgba(255,255,255,.08);
      padding-top:12px;
      color:var(--muted);
      font-size:12px;
      line-height:1.4;
    }

    /* Main */
    .main{
      padding:16px 14px 28px;
      max-width: 1050px;
      margin:0 auto;
    }
    .page{display:none}
    .page.active{display:block}
    h1{font-size:18px; margin:0 0 10px}
    h2{font-size:15px; margin:16px 0 8px; color:var(--text)}
    p{color:var(--muted); margin:8px 0 0; line-height:1.35}

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    @media (min-width:900px){
      .grid.two{grid-template-columns: 1fr 1fr}
      .grid.three{grid-template-columns: 1fr 1fr 1fr}
    }
    .card{
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      padding:12px;
      box-shadow: 0 6px 18px rgba(0,0,0,.18);
    }
    .cardHeader{
      display:flex; align-items:flex-start; justify-content:space-between;
      gap:12px;
      margin-bottom:8px;
    }
    .cardHeader b{font-size:14px}
    .cardHeader small{color:var(--muted)}
    .row{
      display:flex; gap:10px; flex-wrap:wrap;
      align-items:center;
    }
    .kv{
      display:flex; flex-direction:column;
      gap:2px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(255,255,255,.03);
      min-width: 120px;
    }
    .kv span{color:var(--muted); font-size:12px}
    .kv b{font-size:14px}

    .btn{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-weight:600;
      font-size:13px;
    }
    .btn.primary{border-color:rgba(90,169,255,.55); background:rgba(90,169,255,.14)}
    .btn.danger{border-color:rgba(255,77,79,.55); background:rgba(255,77,79,.12)}
    .btn.good{border-color:rgba(25,195,125,.55); background:rgba(25,195,125,.12)}
    .btn:active{transform:scale(.99)}
    .btn:disabled{opacity:.5; cursor:not-allowed}

    input, textarea, select{
      width:100%;
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.10);
      color:var(--text);
      border-radius:14px;
      padding:10px 12px;
      outline:none;
      font-family:var(--sans);
      font-size:14px;
    }
    textarea{min-height:150px; font-family:var(--mono); font-size:12.5px; line-height:1.35}
    label{display:block; color:var(--muted); font-size:12px; margin:10px 0 6px}
    .help{color:var(--muted); font-size:12px; line-height:1.35}
    .mono{font-family:var(--mono)}
    .warnLine{color:var(--warn); font-size:12px; margin-top:8px}
    .okLine{color:var(--good); font-size:12px; margin-top:8px}
    .errLine{color:var(--bad); font-size:12px; margin-top:8px}

    .banner{
      border-radius:16px;
      padding:12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.04);
      margin-bottom:12px;
    }
    .banner.good{border-color:rgba(25,195,125,.55); background:rgba(25,195,125,.12)}
    .banner.bad{border-color:rgba(255,77,79,.55); background:rgba(255,77,79,.12)}
    .banner b{display:block; margin-bottom:4px}
    .banner small{color:var(--muted)}

    table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      overflow:hidden;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
    }
    th, td{
      padding:10px 10px;
      border-bottom:1px solid rgba(255,255,255,.08);
      text-align:left;
      font-size:13px;
      vertical-align:top;
    }
    th{
      color:var(--muted);
      font-weight:600;
      background:rgba(255,255,255,.03);
    }
    tr:last-child td{border-bottom:none}
    .badge{
      display:inline-flex; align-items:center; gap:6px;
      padding:5px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.04);
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
    }
    .badge.win{border-color:rgba(25,195,125,.55); color:rgba(25,195,125,.95); background:rgba(25,195,125,.10)}
    .badge.loss{border-color:rgba(255,77,79,.55); color:rgba(255,77,79,.95); background:rgba(255,77,79,.10)}
    .badge.pending{border-color:rgba(255,209,102,.55); color:rgba(255,209,102,.95); background:rgba(255,209,102,.10)}
    .smallmuted{color:var(--muted); font-size:12px}
    .split{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }
    @media (min-width:900px){ .split{grid-template-columns: 1.2fr .8fr} }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="hamburger" id="hamburger" aria-label="Apri menu" title="Menu">
      <span></span>
    </div>
    <div class="brand">
      <b>BetTools</b>
      <small>V3 Parser ‚Ä¢ Stake v1 ‚Ä¢ Daily BR</small>
    </div>
    <div class="spacer"></div>
    <div class="pill" id="pillDaily">
      <span class="dot neu" id="pillDot"></span>
      <span id="pillText">Giornata: neutra</span>
    </div>
  </div>

  <div class="overlay" id="overlay"></div>

  <aside class="sidebar" id="sidebar" aria-label="Menu laterale">
    <div class="sideHeader">
      <b>Menu</b>
      <button class="closeBtn" id="closeSidebar" aria-label="Chiudi menu">‚úï</button>
    </div>
    <div class="nav" id="nav">
      <button data-page="calc" class="active">üßÆ Calcolatore <small>LivePick V3</small></button>
      <button data-page="storico">üìí Storico <small>Bet & risultati</small></button>
      <button data-page="dash">üìä Dashboard <small>Bankroll & totali</small></button>
      <button data-page="time">üóìÔ∏è Riepilogo temporale <small>Giorni / mesi</small></button>
      <button data-page="filters">üßæ Riepilogo per filtri <small>ROI / profit</small></button>
    </div>

    <div class="sideFooter">
      <div><b class="mono">Notifica V3 semplificata</b></div>
      <div class="smallmuted">Parser robusto: a capo/spazi ok. Prob, stats, L10, PRESS, LATE, ODDS_TO_BET, LP.</div>
    </div>
  </aside>

  <main class="main">
    <!-- CALCOLATORE -->
    <section class="page active" id="page-calc">
      <h1>Calcolatore</h1>

      <div id="dailyBannerWrap"></div>

      <div class="split">
        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Incolla notifica LivePick (V3 semplificata)</b><br/>
              <small>Il parser ignora a capo e spazi extra. Usa i tag (META, STATE, STATS, L10, PROB, PRESS, LATE, ODDS_TO_BET, LP).</small>
            </div>
          </div>

          <label for="lpText">Notifica</label>
          <textarea id="lpText" spellcheck="false" placeholder="Incolla qui la notifica..."></textarea>

          <div class="row" style="margin-top:10px">
            <button class="btn primary" id="btnParse">Parse</button>
            <button class="btn" id="btnClear">Pulisci</button>
            <button class="btn danger" id="btnResetAll" title="Cancella tutti i dati (storico, impostazioni, snapshot)">Reset totale</button>
          </div>

          <div id="parseMsg" class="help" style="margin-top:10px"></div>
        </div>

        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Preview stake (Stake v1)</b><br/>
              <small>Min 2% ‚Ä¢ Max 5% ‚Ä¢ Bankroll fisso per la giornata.</small>
            </div>
          </div>

          <div class="grid two">
            <div>
              <label>Bankroll attuale (impostazioni)</label>
              <input id="bankrollInput" type="number" min="0" step="0.01" />
              <div class="help">Usato per ‚Äúfotografare‚Äù il bankroll giornaliero alla prima bet del giorno.</div>
            </div>
            <div>
              <label>Bankroll giornaliero (snapshot)</label>
              <input id="bankrollDay" type="text" disabled />
              <div class="help">Se oggi non c‚Äô√® snapshot, verr√† creato al primo ‚ÄúAggiungi a storico‚Äù.</div>
            </div>
          </div>

          <div style="margin-top:12px" id="previewWrap" class="help">
            Nessun parse ancora.
          </div>

          <div class="grid two" style="margin-top:12px">
            <div>
              <label>Quota reale giocata (post-calcolo)</label>
              <input id="oddsPlayed" type="number" min="1" step="0.01" placeholder="es: 1.40" />
              <div class="help">La quota della notifica √® la quota di riferimento per calcolo stake.</div>
            </div>
            <div>
              <label>Stake reale giocato (post-calcolo)</label>
              <input id="stakePlayed" type="number" min="0" step="0.01" placeholder="es: 30" />
              <div class="help">Se vuoto, verr√† precompilato con lo stake consigliato.</div>
            </div>
          </div>

          <div class="row" style="margin-top:12px">
            <button class="btn good" id="btnAddToHistory" disabled>‚ûï Aggiungi a storico</button>
          </div>

          <div class="help" style="margin-top:10px">
            Dopo aver giocato, potrai modificare l‚Äôesito in <b>Storico</b> (win/loss) e il profitto verr√† calcolato automaticamente.
          </div>
        </div>
      </div>
    </section>

    <!-- STORICO -->
    <section class="page" id="page-storico">
      <h1>Storico</h1>

      <div class="grid two">
        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Backup / Restore (JSON)</b><br/>
              <small>Esporta / importa tutto lo storico + impostazioni.</small>
            </div>
          </div>

          <div class="row">
            <button class="btn primary" id="btnBackup">‚¨áÔ∏è Backup JSON</button>
            <label class="btn" style="cursor:pointer">
              ‚¨ÜÔ∏è Restore JSON
              <input type="file" id="restoreFile" accept="application/json" style="display:none"/>
            </label>
          </div>
          <div class="help" style="margin-top:10px" id="backupMsg"></div>
        </div>

        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Azioni rapide</b><br/>
              <small>Gestisci storico e risultati.</small>
            </div>
          </div>

          <div class="row">
            <button class="btn danger" id="btnClearHistory">Svuota storico</button>
            <button class="btn" id="btnRecalc">Ricalcola profit & riepiloghi</button>
          </div>
          <div class="help" style="margin-top:10px">
            ‚ÄúRicalcola‚Äù utile se hai importato dati o modificato quota/stake su bet gi√† chiuse.
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:12px">
        <div class="cardHeader">
          <div>
            <b>Lista bet</b><br/>
            <small>Modifica esito e dettagli. Profitto calcolato su stake reale e quota reale.</small>
          </div>
          <div class="row">
            <select id="historyFilter">
              <option value="all">Tutte</option>
              <option value="pending">Pending</option>
              <option value="win">Win</option>
              <option value="loss">Loss</option>
            </select>
          </div>
        </div>

        <div class="help" id="historyEmpty"></div>
        <div style="overflow:auto">
          <table id="historyTable" style="display:none">
            <thead>
              <tr>
                <th>Data</th>
                <th>Match</th>
                <th>Pick</th>
                <th>Stake (sugg/reale)</th>
                <th>Quote (ref/reale)</th>
                <th>Esito</th>
                <th>Profitto</th>
                <th>Azioni</th>
              </tr>
            </thead>
            <tbody id="historyBody"></tbody>
          </table>
        </div>
      </div>

      <div class="card" style="margin-top:12px">
        <div class="cardHeader">
          <div>
            <b>Dettagli bet selezionata</b><br/>
            <small>Campi raw della notifica + calcoli (per audit e analisi).</small>
          </div>
        </div>
        <div id="detailsBox" class="help">Seleziona una bet dalla tabella.</div>
      </div>
    </section>

    <!-- DASHBOARD -->
    <section class="page" id="page-dash">
      <h1>Dashboard</h1>

      <div class="grid two">
        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Impostazioni bankroll</b><br/>
              <small>Usato per stake e per snapshot giornaliero.</small>
            </div>
          </div>

          <label>Bankroll attuale</label>
          <input id="bankrollInputDash" type="number" min="0" step="0.01" />
          <div class="help">Consiglio: aggiorna qui quando fai deposit/withdraw o vuoi riallineare il valore di riferimento.</div>

          <div class="row" style="margin-top:10px">
            <button class="btn primary" id="btnSaveBR">Salva bankroll</button>
            <button class="btn" id="btnNewDay">Nuova giornata (reset snapshot)</button>
          </div>
          <div class="help" id="dashMsg" style="margin-top:10px"></div>
        </div>

        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Totali</b><br/>
              <small>Basati su bet chiuse (win/loss).</small>
            </div>
          </div>

          <div class="row" id="totalsRow"></div>
          <div class="help" style="margin-top:10px">
            ROI = Profit / Somma stake reali (bet chiuse).
          </div>
        </div>
      </div>

      <div class="grid two" style="margin-top:12px">
        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Max Drawdown</b><br/>
              <small>Calcolato su equity cumulata dalle bet chiuse.</small>
            </div>
          </div>
          <div class="row" id="ddRow"></div>
        </div>

        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Streak</b><br/>
              <small>Striscia vincente / perdente pi√π lunga (bet chiuse).</small>
            </div>
          </div>
          <div class="row" id="streakRow"></div>
        </div>
      </div>
    </section>

    <!-- TIME SUMMARY -->
    <section class="page" id="page-time">
      <h1>Riepilogo temporale</h1>
      <div class="card">
        <div class="cardHeader">
          <div>
            <b>Risultati per giorno</b><br/>
            <small>Basati su data inserimento bet (oggi) e profitto bet chiuse.</small>
          </div>
        </div>
        <div class="help" id="timeEmpty"></div>
        <div style="overflow:auto">
          <table id="timeTable" style="display:none">
            <thead>
              <tr>
                <th>Data</th>
                <th>Bet chiuse</th>
                <th>Stake totale</th>
                <th>Profitto</th>
                <th>ROI</th>
              </tr>
            </thead>
            <tbody id="timeBody"></tbody>
          </table>
        </div>
      </div>
    </section>

    <!-- FILTER SUMMARY -->
    <section class="page" id="page-filters">
      <h1>Riepilogo per filtri</h1>
      <div class="card">
        <div class="cardHeader">
          <div>
            <b>Card per filtro (Method + Pick)</b><br/>
            <small>Ordina per ROI (default) o per altri criteri.</small>
          </div>
          <div class="row">
            <select id="filterSort">
              <option value="roi">Ordina: ROI</option>
              <option value="profit">Ordina: Profitto</option>
              <option value="winrate">Ordina: Winrate</option>
              <option value="bets">Ordina: Bet giocate</option>
              <option value="name">Ordina: Tipo scommessa</option>
            </select>
          </div>
        </div>

        <div class="row" id="filtersMetaRow"></div>
        <div class="warnLine" id="filtersNotes"></div>
      </div>

      <div class="grid two" id="filtersGrid" style="margin-top:12px"></div>
    </section>
  </main>

<script>
/* =========================
   Storage & Utils
========================= */
const STORAGE_KEY = "bettools_v3";
const DEFAULT_STATE = {
  version: "V3_SIMPLIFIED",
  settings: {
    bankroll: 1000
  },
  dailySnapshot: {
    date: null,     // YYYY-MM-DD
    bankroll: null  // number
  },
  history: [] // bet objects
};

function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return structuredClone(DEFAULT_STATE);
    const st = JSON.parse(raw);
    // minimal migrate
    if(!st.settings) st.settings = structuredClone(DEFAULT_STATE.settings);
    if(!st.dailySnapshot) st.dailySnapshot = structuredClone(DEFAULT_STATE.dailySnapshot);
    if(!Array.isArray(st.history)) st.history = [];
    return st;
  }catch(e){
    console.warn("loadState failed", e);
    return structuredClone(DEFAULT_STATE);
  }
}
function saveState(){
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}
function resetAll(){
  localStorage.removeItem(STORAGE_KEY);
  state = structuredClone(DEFAULT_STATE);
  saveState();
  renderAll();
}

function todayISO(){
  const d = new Date();
  // local time (user is in Europe/Rome in practice)
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth()+1).padStart(2,"0");
  const dd = String(d.getDate()).padStart(2,"0");
  return `${yyyy}-${mm}-${dd}`;
}
function fmtMoney(x){
  if(x === null || x === undefined || Number.isNaN(Number(x))) return "‚Äî";
  return Number(x).toLocaleString("it-IT",{minimumFractionDigits:2, maximumFractionDigits:2});
}
function fmtPct(x){
  if(x === null || x === undefined || Number.isNaN(Number(x))) return "‚Äî";
  return (Number(x)*100).toLocaleString("it-IT",{minimumFractionDigits:2, maximumFractionDigits:2}) + "%";
}
function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
function safeNum(v){
  if(v === null || v === undefined) return null;
  const s = String(v).trim();
  if(s.toLowerCase() === "null" || s === "") return null;
  const n = Number(s.replace(",", "."));
  return Number.isFinite(n) ? n : null;
}
function sum(arr){ return arr.reduce((a,b)=>a+(Number(b)||0),0); }

/* =========================
   Navigation (Hamburger)
========================= */
const overlay = document.getElementById("overlay");
const sidebar = document.getElementById("sidebar");
const hamburger = document.getElementById("hamburger");
const closeSidebar = document.getElementById("closeSidebar");
const nav = document.getElementById("nav");

function openSidebar(){
  sidebar.classList.add("show");
  overlay.classList.add("show");
}
function closeSidebarFn(){
  sidebar.classList.remove("show");
  overlay.classList.remove("show");
}
hamburger.addEventListener("click", openSidebar);
closeSidebar.addEventListener("click", closeSidebarFn);
overlay.addEventListener("click", closeSidebarFn);

nav.addEventListener("click", (e)=>{
  const btn = e.target.closest("button[data-page]");
  if(!btn) return;
  const page = btn.getAttribute("data-page");
  setPage(page);
  closeSidebarFn();
});

function setPage(page){
  document.querySelectorAll(".page").forEach(p=>p.classList.remove("active"));
  document.getElementById("page-"+page).classList.add("active");
  document.querySelectorAll("#nav button").forEach(b=>b.classList.remove("active"));
  const activeBtn = document.querySelector(`#nav button[data-page="${page}"]`);
  if(activeBtn) activeBtn.classList.add("active");
  // refresh some pages on enter
  if(page==="storico") renderHistory();
  if(page==="dash") renderDashboard();
  if(page==="time") renderTimeSummary();
  if(page==="filters") renderFilters();
}

/* =========================
   Parser V3 Semplificata
   Tags:
   META | Ver=V3 | Method=... | Comp=... | Match=...
   STATE | Time=... | RemHT=... | RemFT=... | Score=X-Y
   STATS | SOT=h/a | ...
   L10 | ...
   PROB | HT(+1=..,+2=..) | FT(+1=..,+2=..,+3=..)
   PRESS | GPI(M=..,L10=..) | GMS(H=..,..,A=..,..,M=..,..) | SI(M=..,..)
   LATE | AT=.. | L10=.. | L5=..
   ODDS_TO_BET | HT Next Over 0.5 = 1.45
   LP | WR=.. | ROI=.. | Profit=.. | AO=.. | N=..
========================= */

const TAGS = ["META","STATE","STATS","L10","PROB","PRESS","LATE","ODDS_TO_BET","LP"];

function normalizeText(s){
  return String(s || "")
    .replace(/\r/g,"\n")
    .replace(/[ \t]+/g," ")            // compress spaces
    .replace(/\n+/g,"\n");             // compress newlines
}

// Extract blocks by tag regardless of line breaks
function extractBlocks(text){
  const t = normalizeText(text);
  const positions = [];
  for(const tag of TAGS){
    const re = new RegExp(`(^|\\n|\\s)(${tag})\\s*\\|`, "g");
    let m;
    while((m=re.exec(t))!==null){
      positions.push({tag, idx: m.index + (m[1] ? m[1].length : 0)}); // approximate start
    }
  }
  // better: find exact tag occurrences by scanning
  const hits = [];
  const scanRe = new RegExp(`\\b(${TAGS.join("|")})\\s*\\|`, "g");
  let m;
  while((m=scanRe.exec(t))!==null){
    hits.push({tag:m[1], idx:m.index});
  }
  hits.sort((a,b)=>a.idx-b.idx);
  const blocks = {};
  for(let i=0;i<hits.length;i++){
    const start = hits[i].idx;
    const end = (i+1<hits.length) ? hits[i+1].idx : t.length;
    const tag = hits[i].tag;
    const chunk = t.slice(start, end).trim();
    blocks[tag] = chunk;
  }
  return blocks;
}

// Helper to parse key=value pairs from "TAG | a=b | c=d"
function parsePipeKVs(chunk){
  // chunk includes "TAG | ..."
  const parts = chunk.split("|").map(x=>x.trim()).filter(Boolean);
  // parts[0] is tag
  const kvs = {};
  for(let i=1;i<parts.length;i++){
    const p = parts[i];
    const eq = p.indexOf("=");
    if(eq===-1) continue;
    const k = p.slice(0,eq).trim();
    const v = p.slice(eq+1).trim();
    kvs[k] = v;
  }
  return kvs;
}

function parseScore(s){
  if(!s) return {home:null, away:null};
  const m = String(s).match(/(\d+)\s*-\s*(\d+)/);
  if(!m) return {home:null, away:null};
  return {home:Number(m[1]), away:Number(m[2])};
}
function parseHA(s){
  // "h/a" with tolerant separators like "h - a" or "h / a"
  if(!s) return {home:null, away:null};
  const m = String(s).match(/(-?\d+(\.\d+)?)\s*[/\-]\s*(-?\d+(\.\d+)?)/);
  if(!m) return {home:null, away:null};
  return {home:safeNum(m[1]), away:safeNum(m[3])};
}

function parsePROB(chunk){
  // "PROB | HT(+1=0.75,+2=0.55) | FT(+1=0.90,+2=0.72,+3=0.45)"
  const out = {HT:{}, FT:{}};
  const ht = chunk.match(/HT\s*\(([^)]*)\)/i);
  const ft = chunk.match(/FT\s*\(([^)]*)\)/i);
  if(ht){
    const inner = ht[1];
    inner.split(",").forEach(pair=>{
      const m = pair.match(/\+(\d+)\s*=\s*([0-9.,]+)/);
      if(m) out.HT[Number(m[1])] = safeNum(m[2]);
    });
  }
  if(ft){
    const inner = ft[1];
    inner.split(",").forEach(pair=>{
      const m = pair.match(/\+(\d+)\s*=\s*([0-9.,]+)/);
      if(m) out.FT[Number(m[1])] = safeNum(m[2]);
    });
  }
  return out;
}

function parsePRESS(chunk){
  // PRESS | GPI(M=156,L10=35) | GMS(H=90/45,A=60/30,M=180/60) | SI(M=4.5/0.75)
  const out = {
    GPI: {M_all:null, M_l10:null},
    GMS: {H_all:null,H_l10:null, A_all:null,A_l10:null, M_all:null,M_l10:null},
    SI:  {M_all:null, M_l10:null}
  };

  const gpi = chunk.match(/GPI\s*\(\s*M\s*=\s*([0-9.,-]+)\s*,\s*L10\s*=\s*([0-9.,-]+)\s*\)/i);
  if(gpi){
    out.GPI.M_all = safeNum(gpi[1]);
    out.GPI.M_l10 = safeNum(gpi[2]);
  }
  const gms = chunk.match(/GMS\s*\(\s*H\s*=\s*([0-9.,-]+)\s*\/\s*([0-9.,-]+)\s*,\s*A\s*=\s*([0-9.,-]+)\s*\/\s*([0-9.,-]+)\s*,\s*M\s*=\s*([0-9.,-]+)\s*\/\s*([0-9.,-]+)\s*\)/i);
  if(gms){
    out.GMS.H_all = safeNum(gms[1]); out.GMS.H_l10 = safeNum(gms[2]);
    out.GMS.A_all = safeNum(gms[3]); out.GMS.A_l10 = safeNum(gms[4]);
    out.GMS.M_all = safeNum(gms[5]); out.GMS.M_l10 = safeNum(gms[6]);
  }
  const si = chunk.match(/SI\s*\(\s*M\s*=\s*([0-9.,-]+)\s*\/\s*([0-9.,-]+)\s*\)/i);
  if(si){
    out.SI.M_all = safeNum(si[1]);
    out.SI.M_l10 = safeNum(si[2]);
  }
  return out;
}

function parseLATE(chunk){
  const kv = parsePipeKVs(chunk);
  return { AT: safeNum(kv.AT), L10: safeNum(kv.L10), L5: safeNum(kv.L5) };
}

function parseODDSTOBET(chunk){
  // "ODDS_TO_BET | HT Next Over 0.5 = 1.45"
  // Accept ":" or "="
  const m = chunk.match(/ODDS_TO_BET\s*\|\s*(.+?)\s*[:=]\s*([0-9.,]+)/i);
  if(!m) return null;
  const label = m[1].trim().replace(/\s+/g," ");
  const odds = safeNum(m[2]);
  // Try extract phase + market + line
  // Examples: "HT Next Over 0.5" or "FT Next Over 1.5"
  const ph = label.match(/\b(HT|FT)\b/i);
  const phase = ph ? ph[1].toUpperCase() : null;

  const lineM = label.match(/([0-9]+(\.[0-9]+)?)\b/);
  const line = lineM ? safeNum(lineM[1]) : null;

  // Market: remove phase and line
  let market = label;
  if(phase) market = market.replace(new RegExp("\\b"+phase+"\\b","i"),"").trim();
  if(line !== null) market = market.replace(new RegExp(String(line).replace(".","\\.")),"").trim();
  market = market.replace(/\s+/g," ").trim(); // e.g., "Next Over"
  return { label, phase, market, line, odds_ref: odds };
}

function parseLP(chunk){
  const kv = parsePipeKVs(chunk);
  return {
    WR: safeNum(kv.WR),
    ROI: safeNum(kv.ROI),
    Profit: safeNum(kv.Profit),
    AO: safeNum(kv.AO),
    N: safeNum(kv.N)
  };
}

function parseStatsLine(chunk, tag){
  const kv = parsePipeKVs(chunk);
  return {
    SOT: parseHA(kv.SOT),
    SOFF: parseHA(kv.SOFF),
    COR: parseHA(kv.COR),
    ATT: parseHA(kv.ATT),
    DATT: parseHA(kv.DATT),
    _raw: chunk
  };
}

function parseMETA(chunk){
  const kv = parsePipeKVs(chunk);
  return {
    Ver: (kv.Ver || "").trim(),
    Method: (kv.Method || "").trim(),
    Comp: (kv.Comp || "").trim(),
    Match: (kv.Match || "").trim(),
    _raw: chunk
  };
}

function parseSTATE(chunk){
  const kv = parsePipeKVs(chunk);
  const sc = parseScore(kv.Score);
  return {
    Time: safeNum(kv.Time),
    RemHT: safeNum(kv.RemHT),
    RemFT: safeNum(kv.RemFT),
    ScoreHome: sc.home,
    ScoreAway: sc.away,
    ScoreRaw: kv.Score ? String(kv.Score).trim() : "",
    _raw: chunk
  };
}

function parseNotification(text){
  const blocks = extractBlocks(text);
  const errors = [];
  const warnings = [];

  // required tags
  const required = ["META","STATE","PROB","ODDS_TO_BET","LP"];
  for(const r of required){
    if(!blocks[r]) errors.push(`Manca blocco: ${r}`);
  }
  if(errors.length) return {ok:false, errors, warnings, data:null};

  const meta = parseMETA(blocks.META);
  if(!meta.Ver || meta.Ver.toUpperCase() !== "V3"){
    warnings.push(`Ver non √® "V3" (trovato: "${meta.Ver || "‚Äî"}"). Parser comunque procede.`);
  }
  if(!meta.Method) warnings.push("META.Method vuoto");
  if(!meta.Match) warnings.push("META.Match vuoto");

  const state = parseSTATE(blocks.STATE);
  if(state.Time === null) warnings.push("STATE.Time non parsabile");
  if(state.RemHT === null) warnings.push("STATE.RemHT non parsabile");
  if(state.RemFT === null) warnings.push("STATE.RemFT non parsabile");

  const stats = blocks.STATS ? parseStatsLine(blocks.STATS, "STATS") : null;
  const l10 = blocks.L10 ? parseStatsLine(blocks.L10, "L10") : null;

  const prob = parsePROB(blocks.PROB);
  if(Object.keys(prob.HT).length===0) warnings.push("PROB.HT non parsato");
  if(Object.keys(prob.FT).length===0) warnings.push("PROB.FT non parsato");

  const press = blocks.PRESS ? parsePRESS(blocks.PRESS) : null;
  const late = blocks.LATE ? parseLATE(blocks.LATE) : null;

  const oddsToBet = parseODDSTOBET(blocks.ODDS_TO_BET);
  if(!oddsToBet || oddsToBet.odds_ref === null) errors.push("ODDS_TO_BET non parsabile (serve: '... = 1.45')");
  if(!oddsToBet.phase) warnings.push("ODDS_TO_BET: non riesco a capire Phase (HT/FT)");
  if(oddsToBet.line === null) warnings.push("ODDS_TO_BET: non riesco a capire Line (es: 0.5)");

  const lp = parseLP(blocks.LP);
  if(lp.WR === null) warnings.push("LP.WR non parsabile (atteso decimale 0-1)");
  if(lp.ROI !== null && lp.ROI > 1) warnings.push("LP.ROI sembra non in formato decimale (es: 0.043).");

  if(errors.length) return {ok:false, errors, warnings, data:null};

  // Normalize RemHT: never negative
  if(state.RemHT !== null && state.RemHT < 0) {
    warnings.push("STATE.RemHT √® negativo: normalizzato a 0");
    state.RemHT = 0;
  }

  return {
    ok:true,
    errors:[],
    warnings,
    data:{
      meta, state, stats, l10, prob, press, late, oddsToBet, lp,
      raw: normalizeText(text)
    }
  };
}

/* =========================
   Stake Formula v1
========================= */

function betKeyFromParsed(parsed){
  // group key: method + phase + market + line
  const m = parsed.meta.Method || "";
  const phase = parsed.oddsToBet.phase || "";
  const market = parsed.oddsToBet.market || parsed.oddsToBet.label || "";
  const line = parsed.oddsToBet.line;
  return `${m}||${phase}||${market}||${line ?? ""}`.trim();
}

function pickMatchProbability(parsed){
  // Determine which +k prob to use based on ODDS_TO_BET line (over X.5 => k = floor(X)+1)
  const phase = parsed.oddsToBet.phase;
  const line = parsed.oddsToBet.line;
  if(!phase || line === null) return {p:null, needed:null, reason:"Phase o Line non disponibili"};
  const needed = Math.floor(line) + 1; // 0.5 ->1, 1.5->2, 2.5->3
  const table = (phase==="HT") ? parsed.prob.HT : parsed.prob.FT;
  const p = table ? table[needed] : null;
  if(p === undefined || p === null) return {p:null, needed, reason:`Manca PROB ${phase}(+${needed})`};
  return {p, needed, reason:null};
}

function getArchiveStatsForKey(key){
  // Only closed bets
  const closed = state.history.filter(b => b.key === key && (b.result==="win" || b.result==="loss"));
  const N = closed.length;
  if(N === 0) return {N:0, winrate:null};
  const wins = closed.filter(b=>b.result==="win").length;
  return {N, winrate: wins / N};
}

function calcStakeV1(parsed){
  const key = betKeyFromParsed(parsed);
  const odds = parsed.oddsToBet.odds_ref;
  const lpWR = parsed.lp.WR;

  const matchP = pickMatchProbability(parsed);
  const P_MATCH = matchP.p; // can be null
  const arch = getArchiveStatsForKey(key);
  const P_ARCH = arch.winrate;
  const N = arch.N;

  const warnings = [];
  if(odds === null || odds <= 1) return { ok:false, reason:"Quota ODDS_TO_BET non valida", warnings, key };

  if(P_MATCH === null) warnings.push(matchP.reason || "Prob match non disponibile");
  if(lpWR === null) warnings.push("LP.WR non disponibile (atteso decimale 0-1)");
  if(P_ARCH === null) warnings.push("Archivio: nessuna bet chiusa per questo filtro (N=0)");

  // If we cannot form a reference probability, fail
  if(P_MATCH === null && lpWR === null && P_ARCH === null){
    return { ok:false, reason:"Impossibile calcolare P_REF (mancano probabilit√†)", warnings, key };
  }

  // Build P_REF per rules
  const P_LP = lpWR;
  let P_REF = null;
  let source = "LP/MATCH";
  if(N < 50){
    // P_REF = 0.6*P_LP + 0.4*P_MATCH
    // fallback: if one missing, use the other
    if(P_LP !== null && P_MATCH !== null) P_REF = 0.6*P_LP + 0.4*P_MATCH;
    else P_REF = (P_LP !== null) ? P_LP : P_MATCH;
  }else{
    source = "ARCH/MATCH";
    if(P_ARCH !== null && P_MATCH !== null) P_REF = 0.6*P_ARCH + 0.4*P_MATCH;
    else P_REF = (P_ARCH !== null) ? P_ARCH : P_MATCH;
  }

  // Blending zone 30-70 (smooth transition)
  if(N >= 30 && N < 70){
    const w = (N - 30) / 40; // 0..1
    const left = (P_LP !== null && P_MATCH !== null) ? (0.6*P_LP + 0.4*P_MATCH) : ((P_LP !== null)?P_LP:P_MATCH);
    const right = (P_ARCH !== null && P_MATCH !== null) ? (0.6*P_ARCH + 0.4*P_MATCH) : ((P_ARCH !== null)?P_ARCH:P_MATCH);
    P_REF = (1-w)*left + w*right;
    source = "BLEND";
  }

  // Edge
  const implied = 1/odds;
  const edge = (P_REF !== null) ? (P_REF - implied) : null;

  // No bet if edge <= 0 or P_REF invalid
  if(P_REF === null || edge === null || edge <= 0){
    return {
      ok:true,
      key,
      source,
      N_archive: N,
      P_REF,
      implied,
      edge,
      kelly: 0,
      stake_pct: 0,
      stake_amount: 0,
      no_bet: true,
      warnings
    };
  }

  // Kelly reduced
  const kelly = edge / (odds - 1);
  let kAdj = 0.5 * kelly;

  // Clamp min/max
  let stakePct = clamp(kAdj, 0.02, 0.05);

  // Rule: under 50 in DB never max stake (your rule)
  if(N < 50 && stakePct >= 0.05){
    stakePct = 0.04; // cap at 4% when sample small
    warnings.push("N<50: cap stake al 4% (mai massimo stake)");
  }

  // LP sample size reduction
  if(parsed.lp.N !== null && parsed.lp.N < 500){
    stakePct *= 0.8;
    stakePct = Math.max(stakePct, 0.02); // keep min
    warnings.push("LP.N<500: stake ridotto del 20%");
  }

  return {
    ok:true,
    key,
    source,
    N_archive: N,
    P_REF,
    implied,
    edge,
    kelly,
    stake_pct: stakePct,
    stake_amount: null, // computed after bankrollDay known
    no_bet: false,
    warnings
  };
}

/* =========================
   Daily Snapshot + Day PnL
========================= */
function ensureDailySnapshot(){
  const today = todayISO();
  if(state.dailySnapshot.date !== today || state.dailySnapshot.bankroll === null){
    state.dailySnapshot.date = today;
    state.dailySnapshot.bankroll = Number(state.settings.bankroll || 0);
    saveState();
  }
}
function getTodayClosedPnL(){
  const today = todayISO();
  const brDay = state.dailySnapshot.date === today ? Number(state.dailySnapshot.bankroll || 0) : null;
  const todays = state.history.filter(b=>b.date === today && (b.result==="win" || b.result==="loss"));
  const profit = sum(todays.map(b=>b.profit_real));
  const pct = (brDay && brDay>0) ? (profit / brDay) : null;
  return {profit, pct, brDay, closedCount: todays.length};
}

function updateDailyPill(){
  const pillDot = document.getElementById("pillDot");
  const pillText = document.getElementById("pillText");
  const info = getTodayClosedPnL();
  if(info.brDay === null){
    pillDot.className = "dot neu";
    pillText.textContent = "Giornata: neutra";
    return;
  }
  if(info.pct !== null && info.pct >= 0.03){
    pillDot.className = "dot good";
    pillText.textContent = "Target profit raggiunto";
  }else if(info.pct !== null && info.pct <= -0.10){
    pillDot.className = "dot bad";
    pillText.textContent = "Stop loss raggiunto";
  }else{
    pillDot.className = "dot neu";
    pillText.textContent = "Giornata: neutra";
  }
}

function renderDailyBanner(){
  const wrap = document.getElementById("dailyBannerWrap");
  const info = getTodayClosedPnL();
  wrap.innerHTML = "";
  if(info.brDay === null){
    const b = document.createElement("div");
    b.className = "banner";
    b.innerHTML = `<b>Bankroll giornaliero</b><small>Nessuno snapshot per oggi: verr√† creato alla prima bet aggiunta allo storico.</small>`;
    wrap.appendChild(b);
    return;
  }
  const pctStr = info.pct===null ? "‚Äî" : fmtPct(info.pct);
  const pStr = fmtMoney(info.profit);
  const brStr = fmtMoney(info.brDay);
  if(info.pct !== null && info.pct >= 0.03){
    const b = document.createElement("div");
    b.className = "banner good";
    b.innerHTML = `<b>TARGET PROFIT RAGGIUNTO</b>
      <small>Oggi: <b>${pStr}</b> (${pctStr}) su bankroll giornaliero <b>${brStr}</b>.</small>`;
    wrap.appendChild(b);
  }else if(info.pct !== null && info.pct <= -0.10){
    const b = document.createElement("div");
    b.className = "banner bad";
    b.innerHTML = `<b>STOP LOSS RAGGIUNTO</b>
      <small>Oggi: <b>${pStr}</b> (${pctStr}) su bankroll giornaliero <b>${brStr}</b>.</small>`;
    wrap.appendChild(b);
  }else{
    const b = document.createElement("div");
    b.className = "banner";
    b.innerHTML = `<b>Giornata in corso</b>
      <small>Oggi: <b>${pStr}</b> (${pctStr}) su bankroll giornaliero <b>${brStr}</b>. (Bet chiuse: ${info.closedCount})</small>`;
    wrap.appendChild(b);
  }
}

/* =========================
   History & Profit Calc
========================= */
function calcProfit(result, stake, odds){
  const s = Number(stake);
  const o = Number(odds);
  if(!Number.isFinite(s) || s<=0) return null;
  if(result==="win"){
    if(!Number.isFinite(o) || o<=1) return null;
    return s * (o - 1);
  }
  if(result==="loss") return -s;
  return null; // pending
}

function recalcAll(){
  for(const b of state.history){
    if(b.result==="win" || b.result==="loss"){
      // prefer manual override if present
      if(b.profit_manual === true) continue;
      b.profit_real = calcProfit(b.result, b.stake_played, b.odds_played);
    }else{
      b.profit_real = null;
    }
  }
  saveState();
  renderAll();
}

/* =========================
   UI: Calcolatore
========================= */
let state = loadState();

const lpText = document.getElementById("lpText");
const btnParse = document.getElementById("btnParse");
const btnClear = document.getElementById("btnClear");
const btnResetAll = document.getElementById("btnResetAll");
const parseMsg = document.getElementById("parseMsg");
const previewWrap = document.getElementById("previewWrap");
const bankrollInput = document.getElementById("bankrollInput");
const bankrollDay = document.getElementById("bankrollDay");
const oddsPlayed = document.getElementById("oddsPlayed");
const stakePlayed = document.getElementById("stakePlayed");
const btnAddToHistory = document.getElementById("btnAddToHistory");

let lastParsed = null;
let lastStake = null;

function syncBankrollInputs(){
  bankrollInput.value = Number(state.settings.bankroll || 0);
  document.getElementById("bankrollInputDash").value = Number(state.settings.bankroll || 0);
  bankrollDay.value = (state.dailySnapshot.date === todayISO() && state.dailySnapshot.bankroll !== null)
    ? fmtMoney(state.dailySnapshot.bankroll)
    : "‚Äî (non creato)";
}

bankrollInput.addEventListener("change", ()=>{
  state.settings.bankroll = Number(bankrollInput.value || 0);
  saveState();
  syncBankrollInputs();
});
document.getElementById("bankrollInputDash").addEventListener("change", ()=>{
  state.settings.bankroll = Number(document.getElementById("bankrollInputDash").value || 0);
  saveState();
  syncBankrollInputs();
});

btnClear.addEventListener("click", ()=>{
  lpText.value = "";
  lastParsed = null;
  lastStake = null;
  parseMsg.innerHTML = "";
  previewWrap.innerHTML = "Nessun parse ancora.";
  btnAddToHistory.disabled = true;
});
btnResetAll.addEventListener("click", ()=>{
  if(confirm("Sicuro di voler resettare TUTTO? (storico + impostazioni + snapshot)")){
    resetAll();
  }
});

btnParse.addEventListener("click", ()=>{
  const txt = lpText.value;
  const res = parseNotification(txt);
  if(!res.ok){
    lastParsed = null;
    lastStake = null;
    btnAddToHistory.disabled = true;
    parseMsg.innerHTML = `<div class="errLine"><b>Parse fallito:</b><br/>${res.errors.map(e=>`‚Ä¢ ${e}`).join("<br/>")}</div>` +
      (res.warnings.length ? `<div class="warnLine" style="margin-top:8px"><b>Warning:</b><br/>${res.warnings.map(w=>`‚Ä¢ ${w}`).join("<br/>")}</div>` : "");
    previewWrap.innerHTML = "Correggi la notifica e riprova.";
    return;
  }

  lastParsed = res.data;
  // stake calc
  const st = calcStakeV1(lastParsed);
  lastStake = st;

  const warningsHtml = (res.warnings.length || st.warnings.length)
    ? `<div class="warnLine"><b>Warning:</b><br/>${[...res.warnings, ...st.warnings].map(w=>`‚Ä¢ ${w}`).join("<br/>")}</div>` : "";

  parseMsg.innerHTML =
    `<div class="okLine"><b>Parse OK.</b> Method: <span class="mono">${escapeHtml(lastParsed.meta.Method)}</span> ‚Äî Match: <span class="mono">${escapeHtml(lastParsed.meta.Match)}</span></div>` +
    warningsHtml;

  // Ensure bankroll day field display (do not create snapshot yet)
  syncBankrollInputs();

  // Compute suggested stake amount based on snapshot if exists, else on current bankroll
  const brBase = (state.dailySnapshot.date === todayISO() && state.dailySnapshot.bankroll !== null)
    ? Number(state.dailySnapshot.bankroll)
    : Number(state.settings.bankroll || 0);

  const stakeAmt = st.stake_pct ? (st.stake_pct * brBase) : 0;

  // Pre-fill stake played if empty
  if(!stakePlayed.value){
    stakePlayed.value = stakeAmt > 0 ? stakeAmt.toFixed(2) : "";
  }
  // Pre-fill odds played if empty (common: slightly lower, user will edit)
  if(!oddsPlayed.value && lastParsed.oddsToBet.odds_ref !== null){
    oddsPlayed.value = "";
  }

  const pRef = (st.P_REF !== null) ? fmtPct(st.P_REF) : "‚Äî";
  const implied = (st.implied !== null) ? fmtPct(st.implied) : "‚Äî";
  const edge = (st.edge !== null) ? fmtPct(st.edge) : "‚Äî";
  const stakePct = st.no_bet ? "0.00%" : fmtPct(st.stake_pct);
  const stakeMoney = st.no_bet ? "‚Äî" : fmtMoney(stakeAmt);
  const noBetLine = st.no_bet ? `<div class="errLine"><b>NO BET</b>: edge ‚â§ 0 (o probabilit√† insufficiente).</div>` : "";

  previewWrap.innerHTML = `
    <div class="row">
      <div class="kv"><span>Pick</span><b class="mono">${escapeHtml(lastParsed.oddsToBet.label)} @ ${lastParsed.oddsToBet.odds_ref ?? "‚Äî"}</b></div>
      <div class="kv"><span>Fonte</span><b>${escapeHtml(st.source || "‚Äî")}</b></div>
      <div class="kv"><span>N archivio</span><b>${st.N_archive ?? 0}</b></div>
    </div>
    <div class="row" style="margin-top:10px">
      <div class="kv"><span>P_REF</span><b>${pRef}</b></div>
      <div class="kv"><span>Implied</span><b>${implied}</b></div>
      <div class="kv"><span>Edge</span><b>${edge}</b></div>
    </div>
    <div class="row" style="margin-top:10px">
      <div class="kv"><span>Stake %</span><b>${stakePct}</b></div>
      <div class="kv"><span>Stake ‚Ç¨ (base day)</span><b>${stakeMoney}</b></div>
      <div class="kv"><span>Bankroll base</span><b>${fmtMoney(brBase)}</b></div>
    </div>
    ${noBetLine}
  `;

  btnAddToHistory.disabled = false;
});

btnAddToHistory.addEventListener("click", ()=>{
  if(!lastParsed || !lastStake || !lastStake.ok) return;

  // Create daily snapshot at first bet of day
  ensureDailySnapshot();
  syncBankrollInputs();

  const brDay = Number(state.dailySnapshot.bankroll || 0);
  const stakeAmt = lastStake.stake_pct ? lastStake.stake_pct * brDay : 0;

  const bet = {
    id: crypto.randomUUID ? crypto.randomUUID() : String(Date.now()) + "_" + Math.random().toString(16).slice(2),
    date: todayISO(),
    key: lastStake.key,
    meta: lastParsed.meta,
    state: lastParsed.state,
    stats: lastParsed.stats,
    l10: lastParsed.l10,
    prob: lastParsed.prob,
    press: lastParsed.press,
    late: lastParsed.late,
    odds_to_bet: lastParsed.oddsToBet, // contains odds_ref, phase, market, line
    lp: lastParsed.lp,
    calc: {
      stake_source: lastStake.source,
      N_archive_at_bet: lastStake.N_archive,
      P_REF: lastStake.P_REF,
      implied_prob: lastStake.implied,
      edge: lastStake.edge,
      kelly: lastStake.kelly,
      stake_suggested_pct: lastStake.stake_pct,
      bankroll_day: brDay
    },
    execution: {
      odds_ref: lastParsed.oddsToBet.odds_ref,
      stake_suggested: stakeAmt,
      odds_played: safeNum(oddsPlayed.value),
      stake_played: safeNum(stakePlayed.value) ?? stakeAmt
    },
    result: "pending",
    profit_real: null,
    profit_manual: false,
    raw: lastParsed.raw
  };

  // store
  state.history.unshift(bet);
  saveState();

  // reset small fields (keep notification for rapid adds)
  // stakePlayed/oddsPlayed left as-is to speed workflow
  renderAll();
  setPage("storico");
});

/* =========================
   UI: Storico
========================= */
const historyEmpty = document.getElementById("historyEmpty");
const historyTable = document.getElementById("historyTable");
const historyBody = document.getElementById("historyBody");
const detailsBox = document.getElementById("detailsBox");
const historyFilter = document.getElementById("historyFilter");

historyFilter.addEventListener("change", renderHistory);

document.getElementById("btnClearHistory").addEventListener("click", ()=>{
  if(confirm("Svuotare lo storico?")){
    state.history = [];
    saveState();
    renderAll();
  }
});
document.getElementById("btnRecalc").addEventListener("click", ()=>{
  recalcAll();
  alert("Ricalcolo completato.");
});

function resultBadge(res){
  if(res==="win") return `<span class="badge win">WIN</span>`;
  if(res==="loss") return `<span class="badge loss">LOSS</span>`;
  return `<span class="badge pending">PENDING</span>`;
}

function renderHistory(){
  const f = historyFilter.value;
  let rows = state.history.slice();
  if(f !== "all"){
    rows = rows.filter(b=>b.result === f);
  }
  if(rows.length===0){
    historyEmpty.textContent = "Nessuna bet da mostrare.";
    historyTable.style.display = "none";
    historyBody.innerHTML = "";
    detailsBox.textContent = "Seleziona una bet dalla tabella.";
    return;
  }
  historyEmpty.textContent = "";
  historyTable.style.display = "";
  historyBody.innerHTML = "";

  for(const b of rows){
    const pick = `${b.odds_to_bet.phase || "‚Äî"} ${b.odds_to_bet.market || ""} ${b.odds_to_bet.line ?? ""}`.trim();
    const stakeS = fmtMoney(b.execution.stake_suggested);
    const stakeP = fmtMoney(b.execution.stake_played);
    const oddsRef = (b.execution.odds_ref ?? "‚Äî");
    const oddsP = (b.execution.odds_played ?? "‚Äî");
    const profit = fmtMoney(b.profit_real);

    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td class="mono">${escapeHtml(b.date)}</td>
      <td class="mono">${escapeHtml((b.meta.Match||"‚Äî"))}</td>
      <td class="mono">${escapeHtml(pick)}<br/><span class="smallmuted">${escapeHtml(b.meta.Method||"")}</span></td>
      <td class="mono">${stakeS} / <b>${stakeP}</b></td>
      <td class="mono">${oddsRef} / <b>${oddsP}</b></td>
      <td>${resultBadge(b.result)}</td>
      <td class="mono">${profit}</td>
      <td>
        <div class="row">
          <button class="btn" data-act="view" data-id="${b.id}">Dettagli</button>
          <button class="btn primary" data-act="edit" data-id="${b.id}">Modifica</button>
          <button class="btn danger" data-act="del" data-id="${b.id}">Elimina</button>
        </div>
      </td>
    `;
    historyBody.appendChild(tr);
  }
}

historyBody.addEventListener("click", (e)=>{
  const btn = e.target.closest("button[data-act]");
  if(!btn) return;
  const id = btn.getAttribute("data-id");
  const act = btn.getAttribute("data-act");
  const b = state.history.find(x=>x.id===id);
  if(!b) return;

  if(act==="view"){
    showDetails(b);
    return;
  }
  if(act==="del"){
    if(confirm("Eliminare questa bet?")){
      state.history = state.history.filter(x=>x.id!==id);
      saveState();
      renderAll();
    }
    return;
  }
  if(act==="edit"){
    editBet(b);
    return;
  }
});

function showDetails(b){
  const pretty = {
    id:b.id,
    date:b.date,
    match:b.meta.Match,
    method:b.meta.Method,
    comp:b.meta.Comp,
    state:b.state,
    odds_to_bet:b.odds_to_bet,
    lp:b.lp,
    calc:b.calc,
    execution:b.execution,
    result:b.result,
    profit_real:b.profit_real,
    raw_notification:b.raw
  };
  detailsBox.innerHTML = `<pre class="mono" style="white-space:pre-wrap;margin:0">${escapeHtml(JSON.stringify(pretty,null,2))}</pre>`;
}

function editBet(b){
  // Simple prompt-based editor (mobile friendly)
  const res = prompt(
`Modifica esito: scrivi "win", "loss" o "pending".
Attuale: ${b.result}`,
    b.result
  );
  if(res === null) return;
  const r = res.trim().toLowerCase();
  if(!["win","loss","pending"].includes(r)){
    alert('Valore non valido. Usa: win / loss / pending');
    return;
  }
  b.result = r;

  const op = prompt(
`Quota reale giocata (odds_played).
Attuale: ${b.execution.odds_played ?? ""}\n(Invio per lasciare invariato)`,
    (b.execution.odds_played ?? "")
  );
  if(op !== null && op.trim() !== ""){
    b.execution.odds_played = safeNum(op);
  }

  const sp = prompt(
`Stake reale giocato (stake_played).
Attuale: ${b.execution.stake_played ?? ""}\n(Invio per lasciare invariato)`,
    (b.execution.stake_played ?? "")
  );
  if(sp !== null && sp.trim() !== ""){
    b.execution.stake_played = safeNum(sp);
  }

  // Optional manual profit override
  const pm = prompt(
`Profitto manuale (opzionale).
Lascia vuoto per calcolo automatico.\nAttuale: ${b.profit_manual ? b.profit_real : ""}`,
    b.profit_manual ? String(b.profit_real ?? "") : ""
  );
  if(pm !== null){
    if(pm.trim()===""){
      b.profit_manual = false;
      b.profit_real = (b.result==="win"||b.result==="loss") ? calcProfit(b.result, b.execution.stake_played, b.execution.odds_played) : null;
    }else{
      b.profit_manual = true;
      b.profit_real = safeNum(pm);
    }
  }

  saveState();
  renderAll();
  showDetails(b);
}

/* =========================
   Backup / Restore
========================= */
const btnBackup = document.getElementById("btnBackup");
const restoreFile = document.getElementById("restoreFile");
const backupMsg = document.getElementById("backupMsg");

btnBackup.addEventListener("click", ()=>{
  const blob = new Blob([JSON.stringify(state,null,2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `bettools_backup_${todayISO()}.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
  backupMsg.innerHTML = `<div class="okLine">Backup creato.</div>`;
});

restoreFile.addEventListener("change", async (e)=>{
  const file = e.target.files && e.target.files[0];
  if(!file) return;
  try{
    const text = await file.text();
    const incoming = JSON.parse(text);

    const replace = confirm("OK = Sostituisci tutto lo storico.\nAnnulla = Unisci (merge) allo storico esistente.");
    if(replace){
      state = incoming;
      saveState();
      renderAll();
      backupMsg.innerHTML = `<div class="okLine">Restore completato (sostituzione).</div>`;
    }else{
      // Merge history arrays + keep current settings unless incoming has them
      const merged = loadState();
      // Keep current settings unless user wants incoming? We'll merge with incoming settings taking precedence if present
      const mergedState = structuredClone(merged);
      mergedState.settings = incoming.settings || mergedState.settings;
      mergedState.dailySnapshot = incoming.dailySnapshot || mergedState.dailySnapshot;

      const incHist = Array.isArray(incoming.history) ? incoming.history : [];
      const curHist = Array.isArray(mergedState.history) ? mergedState.history : [];
      const ids = new Set(curHist.map(b=>b.id));
      for(const b of incHist){
        if(!b || !b.id) continue;
        if(!ids.has(b.id)){
          curHist.push(b);
          ids.add(b.id);
        }
      }
      mergedState.history = curHist;
      state = mergedState;
      saveState();
      renderAll();
      backupMsg.innerHTML = `<div class="okLine">Restore completato (merge).</div>`;
    }
  }catch(err){
    console.error(err);
    backupMsg.innerHTML = `<div class="errLine">Errore restore: file non valido.</div>`;
  }finally{
    restoreFile.value = "";
  }
});

/* =========================
   Dashboard + Summaries
========================= */
document.getElementById("btnSaveBR").addEventListener("click", ()=>{
  const v = Number(document.getElementById("bankrollInputDash").value || 0);
  state.settings.bankroll = v;
  saveState();
  syncBankrollInputs();
  document.getElementById("dashMsg").innerHTML = `<div class="okLine">Bankroll salvato: ${fmtMoney(v)}</div>`;
  renderAll();
});

document.getElementById("btnNewDay").addEventListener("click", ()=>{
  if(confirm("Vuoi azzerare lo snapshot giornaliero? (La prossima bet creer√† un nuovo bankroll-day)")){
    state.dailySnapshot.date = null;
    state.dailySnapshot.bankroll = null;
    saveState();
    renderAll();
  }
});

function computeTotals(){
  const closed = state.history.filter(b=>b.result==="win" || b.result==="loss");
  const profit = sum(closed.map(b=>b.profit_real));
  const stakeTot = sum(closed.map(b=>Number(b.execution.stake_played)||0));
  const roi = (stakeTot>0) ? (profit/stakeTot) : null;
  const wins = closed.filter(b=>b.result==="win").length;
  const losses = closed.filter(b=>b.result==="loss").length;
  const winrate = (closed.length>0) ? (wins/closed.length) : null;
  return {closedCount:closed.length, wins, losses, profit, stakeTot, roi, winrate};
}

function computeDrawdown(){
  // equity curve on closed bets in chronological order by date and insertion order
  const closed = state.history
    .filter(b=>b.result==="win" || b.result==="loss")
    .slice()
    .sort((a,b)=> (a.date===b.date ? 0 : (a.date<b.date ? -1 : 1))); // simplistic by date
  let equity = 0;
  let peak = 0;
  let maxDD = 0;
  for(const b of closed){
    equity += Number(b.profit_real)||0;
    if(equity > peak) peak = equity;
    const dd = peak - equity;
    if(dd > maxDD) maxDD = dd;
  }
  return {maxDD, peak, end: equity};
}

function computeStreaks(){
  const closed = state.history
    .filter(b=>b.result==="win" || b.result==="loss")
    .slice()
    .sort((a,b)=> (a.date===b.date ? 0 : (a.date<b.date ? -1 : 1)));
  let curW=0, curL=0, maxW=0, maxL=0;
  for(const b of closed){
    if(b.result==="win"){
      curW++; curL=0;
    }else{
      curL++; curW=0;
    }
    if(curW>maxW) maxW=curW;
    if(curL>maxL) maxL=curL;
  }
  return {maxW, maxL};
}

function renderDashboard(){
  const t = computeTotals();
  const totalsRow = document.getElementById("totalsRow");
  totalsRow.innerHTML = "";
  const items = [
    ["Bet chiuse", t.closedCount],
    ["Winrate", fmtPct(t.winrate)],
    ["Stake totale", fmtMoney(t.stakeTot)],
    ["Profitto", fmtMoney(t.profit)],
    ["ROI", t.roi===null ? "‚Äî" : fmtPct(t.roi)]
  ];
  for(const [k,v] of items){
    const el = document.createElement("div");
    el.className = "kv";
    el.innerHTML = `<span>${k}</span><b>${escapeHtml(String(v))}</b>`;
    totalsRow.appendChild(el);
  }

  const dd = computeDrawdown();
  const ddRow = document.getElementById("ddRow");
  ddRow.innerHTML = "";
  const ddItems = [
    ["Max DD", fmtMoney(dd.maxDD)],
    ["Equity end", fmtMoney(dd.end)]
  ];
  for(const [k,v] of ddItems){
    const el = document.createElement("div");
    el.className = "kv";
    el.innerHTML = `<span>${k}</span><b>${escapeHtml(String(v))}</b>`;
    ddRow.appendChild(el);
  }

  const st = computeStreaks();
  const streakRow = document.getElementById("streakRow");
  streakRow.innerHTML = "";
  const stItems = [
    ["Max win streak", st.maxW],
    ["Max loss streak", st.maxL]
  ];
  for(const [k,v] of stItems){
    const el = document.createElement("div");
    el.className = "kv";
    el.innerHTML = `<span>${k}</span><b>${escapeHtml(String(v))}</b>`;
    streakRow.appendChild(el);
  }
}

function renderTimeSummary(){
  const timeEmpty = document.getElementById("timeEmpty");
  const timeTable = document.getElementById("timeTable");
  const timeBody = document.getElementById("timeBody");
  const closed = state.history.filter(b=>b.result==="win" || b.result==="loss");

  if(closed.length===0){
    timeEmpty.textContent = "Nessuna bet chiusa: riepilogo temporale non disponibile.";
    timeTable.style.display = "none";
    timeBody.innerHTML = "";
    return;
  }
  timeEmpty.textContent = "";
  timeTable.style.display = "";
  timeBody.innerHTML = "";

  const byDay = new Map();
  for(const b of closed){
    const d = b.date || "‚Äî";
    if(!byDay.has(d)) byDay.set(d, {bets:0, stake:0, profit:0});
    const o = byDay.get(d);
    o.bets += 1;
    o.stake += Number(b.execution.stake_played)||0;
    o.profit += Number(b.profit_real)||0;
  }
  const days = Array.from(byDay.entries()).sort((a,b)=> a[0]<b[0] ? 1 : -1); // newest first
  for(const [d, o] of days){
    const roi = o.stake>0 ? (o.profit/o.stake) : null;
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td class="mono">${escapeHtml(d)}</td>
      <td>${o.bets}</td>
      <td class="mono">${fmtMoney(o.stake)}</td>
      <td class="mono">${fmtMoney(o.profit)}</td>
      <td class="mono">${roi===null ? "‚Äî" : fmtPct(roi)}</td>
    `;
    timeBody.appendChild(tr);
  }
}

function renderFilters(){
  const grid = document.getElementById("filtersGrid");
  const sort = document.getElementById("filterSort").value;
  const filtersMetaRow = document.getElementById("filtersMetaRow");
  const filtersNotes = document.getElementById("filtersNotes");

  const all = state.history;
  const closed = all.filter(b=>b.result==="win" || b.result==="loss");

  filtersMetaRow.innerHTML = "";
  const t = computeTotals();
  const items = [
    ["Bet totali", all.length],
    ["Bet chiuse", t.closedCount],
    ["Profitto", fmtMoney(t.profit)],
    ["ROI", t.roi===null ? "‚Äî" : fmtPct(t.roi)]
  ];
  for(const [k,v] of items){
    const el = document.createElement("div");
    el.className = "kv";
    el.innerHTML = `<span>${k}</span><b>${escapeHtml(String(v))}</b>`;
    filtersMetaRow.appendChild(el);
  }

  const dd = computeDrawdown();
  const st = computeStreaks();
  filtersNotes.textContent = `Max DD: ${fmtMoney(dd.maxDD)} ‚Ä¢ Max win streak: ${st.maxW} ‚Ä¢ Max loss streak: ${st.maxL}`;

  // Group by (Method + Pick label)
  const groups = new Map();
  for(const b of all){
    const name = `${b.meta.Method || "‚Äî"} ‚Ä¢ ${b.odds_to_bet.label || "‚Äî"}`;
    if(!groups.has(name)){
      groups.set(name, {name, bets:0, wins:0, losses:0, stake:0, profit:0, oddsSum:0, oddsN:0});
    }
    const g = groups.get(name);
    g.bets += 1;
    // avg odds: use odds_played if exists else odds_ref
    const o = (b.execution.odds_played ?? b.execution.odds_ref);
    if(o && Number(o)>1){ g.oddsSum += Number(o); g.oddsN += 1; }
    if(b.result==="win" || b.result==="loss"){
      g.stake += Number(b.execution.stake_played)||0;
      g.profit += Number(b.profit_real)||0;
      if(b.result==="win") g.wins += 1;
      if(b.result==="loss") g.losses += 1;
    }
  }

  let arr = Array.from(groups.values()).map(g=>{
    const closedN = g.wins + g.losses;
    const winrate = closedN>0 ? (g.wins/closedN) : null;
    const avgOdds = g.oddsN>0 ? (g.oddsSum/g.oddsN) : null;
    const roi = g.stake>0 ? (g.profit/g.stake) : null;
    return {...g, closedN, winrate, avgOdds, roi};
  });

  // Sort
  arr.sort((a,b)=>{
    const va = (sort==="roi") ? (a.roi ?? -1e9)
      : (sort==="profit") ? a.profit
      : (sort==="winrate") ? (a.winrate ?? -1e9)
      : (sort==="bets") ? a.bets
      : a.name.localeCompare(b.name);
    const vb = (sort==="roi") ? (b.roi ?? -1e9)
      : (sort==="profit") ? b.profit
      : (sort==="winrate") ? (b.winrate ?? -1e9)
      : (sort==="bets") ? b.bets
      : 0;

    if(sort==="name") return va;
    return vb - va;
  });

  grid.innerHTML = "";
  if(arr.length===0){
    grid.innerHTML = `<div class="card"><div class="help">Nessun dato.</div></div>`;
    return;
  }

  for(const g of arr){
    const card = document.createElement("div");
    card.className = "card";
    card.innerHTML = `
      <div class="cardHeader">
        <div>
          <b>${escapeHtml(g.name)}</b><br/>
          <small>${g.bets} bet ‚Ä¢ chiuse ${g.closedN}</small>
        </div>
        <div class="badge">${g.roi===null ? "ROI ‚Äî" : ("ROI " + fmtPct(g.roi))}</div>
      </div>

      <div class="row">
        <div class="kv"><span>Winrate</span><b>${g.winrate===null ? "‚Äî" : fmtPct(g.winrate)}</b></div>
        <div class="kv"><span>Quota media</span><b>${g.avgOdds===null ? "‚Äî" : Number(g.avgOdds).toFixed(2)}</b></div>
        <div class="kv"><span>Profitto</span><b>${fmtMoney(g.profit)}</b></div>
        <div class="kv"><span>Stake tot</span><b>${fmtMoney(g.stake)}</b></div>
      </div>
    `;
    grid.appendChild(card);
  }
}

document.getElementById("filterSort").addEventListener("change", renderFilters);

/* =========================
   Render All
========================= */
function renderAll(){
  syncBankrollInputs();
  renderDailyBanner();
  updateDailyPill();
  renderHistory();
  renderDashboard();
  renderTimeSummary();
  renderFilters();
}
renderAll();

/* =========================
   Misc actions
========================= */
document.getElementById("btnClearHistory").addEventListener("click", ()=>{});
document.getElementById("btnClearHistory");

function escapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
</script>
</body>
</html>
