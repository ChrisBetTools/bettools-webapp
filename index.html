<!-- BLOCCO 1/4 -->
<!doctype html>
<html lang="it" data-theme="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BetTools — index v1.6.2</title>
  <style>
    :root{
      --bg:#0B1020;
      --bg2:#0E1730;
      --card:rgba(255,255,255,.06);
      --card2:rgba(255,255,255,.08);
      --stroke:rgba(255,255,255,.10);
      --muted:rgba(220,230,255,.72);
      --text:#E8EEFC;
      --good:#19C37D;
      --bad:#FF4D4F;
      --warn:#F5C84B;
      --neutral:#9FB0D0;
      --accent:#6D5EF6;
      --shadow: 0 18px 40px rgba(0,0,0,.45);
      --radius: 22px;
      --radius2: 16px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--font);
      background:
        radial-gradient(1200px 600px at 30% -10%, rgba(109,94,246,.30), transparent 60%),
        radial-gradient(900px 500px at 85% 0%, rgba(25,195,125,.18), transparent 55%),
        radial-gradient(900px 600px at 80% 90%, rgba(255,77,79,.14), transparent 55%),
        linear-gradient(180deg, var(--bg) 0%, #070A14 100%);
      color:var(--text);
    }

    /* Layout */
    .app{display:flex; min-height:100%;}
    .sidebar{
      width:290px;
      padding:22px;
      background: rgba(255,255,255,.03);
      border-right:1px solid var(--stroke);
      backdrop-filter: blur(12px);
      position:fixed;
      top:0; left:0; bottom:0;
      z-index:10;
      transform: translateX(0);
      transition: transform .25s ease;
    }
    .sidebarHeader{
      display:flex; align-items:center; justify-content:space-between;
      margin-bottom:18px;
    }
    .brand{
      display:flex; gap:10px; align-items:center;
    }
    .logo{
      width:40px;height:40px;border-radius:14px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.25), transparent 55%),
                  linear-gradient(135deg, rgba(109,94,246,.95), rgba(25,195,125,.65));
      box-shadow: 0 10px 18px rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.14);
    }
    .brandText b{display:block; font-size:14px; letter-spacing:.2px}
    .brandText small{display:block; color:var(--muted); font-weight:600}

    .nav{display:flex; flex-direction:column; gap:10px; margin-top:18px;}
    .nav button{
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.04);
      color:var(--text);
      padding:12px 12px;
      border-radius: 16px;
      text-align:left;
      display:flex; align-items:center; justify-content:space-between;
      cursor:pointer;
      transition:.15s ease;
    }
    .nav button:hover{background: rgba(255,255,255,.07);}
    .nav button.active{
      border-color: rgba(109,94,246,.70);
      box-shadow: 0 12px 30px rgba(109,94,246,.18);
      background: rgba(109,94,246,.18);
    }

    .main{
      flex:1;
      margin-left:290px;
      padding:22px 22px 40px;
    }
    .topbar{
      display:flex; gap:12px; align-items:center; justify-content:space-between;
      margin-bottom:14px;
    }
    .hamburger{
      display:none;
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.05);
      color:var(--text);
      width:44px;height:44px;border-radius:16px;
      cursor:pointer;
    }
    .pill{
      display:flex; align-items:center; gap:10px;
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.05);
      padding:10px 12px;
      border-radius: 999px;
      color:var(--muted);
      font-weight:700;
      letter-spacing:.1px;
    }
    .dot{
      width:10px;height:10px;border-radius:99px;
      background: var(--neutral);
      box-shadow:0 0 0 6px rgba(159,176,208,.12);
    }
    .dot.good{background:var(--good); box-shadow:0 0 0 6px rgba(25,195,125,.12);}
    .dot.bad{background:var(--bad); box-shadow:0 0 0 6px rgba(255,77,79,.12);}
    .dot.neu{background:var(--neutral); box-shadow:0 0 0 6px rgba(159,176,208,.12);}

    /* Cards */
    h1{font-size:24px; margin:10px 0 14px;}
    .grid2{display:grid; grid-template-columns:1fr 1fr; gap:14px;}
    .card{
      background: var(--card);
      border:1px solid var(--stroke);
      border-radius: var(--radius);
      padding:16px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .cardHeader{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      margin-bottom:12px;
      gap:10px;
    }
    .cardHeader small{color:var(--muted); font-weight:650}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .btn{
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.05);
      color:var(--text);
      padding:11px 14px;
      border-radius:16px;
      cursor:pointer;
      font-weight:800;
      transition:.15s ease;
    }
    .btn:hover{background: rgba(255,255,255,.08);}
    .btn.primary{
      background: rgba(109,94,246,.22);
      border-color: rgba(109,94,246,.55);
    }
    .btn.primary:hover{background: rgba(109,94,246,.28);}
    .btn.good{
      background: rgba(25,195,125,.18);
      border-color: rgba(25,195,125,.55);
    }
    .btn.danger{
      background: rgba(255,77,79,.16);
      border-color: rgba(255,77,79,.50);
    }
    .btn:disabled{opacity:.55; cursor:not-allowed;}
    .help{color:var(--muted); font-weight:650; line-height:1.3; font-size:13px;}
    textarea, input, select{
      width:100%;
      background: rgba(255,255,255,.04);
      border:1px solid var(--stroke);
      color:var(--text);
      border-radius: 16px;
      padding:10px 12px;
      outline:none;
      font-size:14px;
      font-weight:650;
    }
    textarea{min-height:210px; resize:vertical; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
    label{display:block; font-size:12px; color:var(--muted); font-weight:900; margin:8px 0 6px;}

    .badge{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.04);
      color:var(--muted);
      font-weight:900;
      font-size:12px;
    }
    .badge.win{background: rgba(25,195,125,.13); border-color: rgba(25,195,125,.40); color: rgba(220,255,240,.92);}
    .badge.loss{background: rgba(255,77,79,.12); border-color: rgba(255,77,79,.42); color: rgba(255,225,226,.92);}
    .badge.pending{background: rgba(245,200,75,.10); border-color: rgba(245,200,75,.40); color: rgba(255,244,210,.92);}
    .badge.neutral{background: rgba(159,176,208,.10); border-color: rgba(159,176,208,.36); color: rgba(230,236,252,.88);}
    .chip{
      display:inline-flex; align-items:center; justify-content:center;
      padding:10px 12px;
      border-radius: 18px;
      background: rgba(255,255,255,.05);
      border:1px solid var(--stroke);
      font-weight:900;
      color:var(--muted);
      gap:8px;
      min-width: 160px;
    }
    .chip.good{background: rgba(25,195,125,.14); border-color: rgba(25,195,125,.45); color: rgba(220,255,240,.95);}
    .chip.bad{background: rgba(255,77,79,.14); border-color: rgba(255,77,79,.45); color: rgba(255,225,226,.95);}
    .chip.warn{background: rgba(245,200,75,.12); border-color: rgba(245,200,75,.45); color: rgba(255,244,210,.95);}

    .banner{
      background: rgba(255,255,255,.04);
      border:1px dashed rgba(255,255,255,.16);
      padding:12px 14px;
      border-radius: 18px;
      margin: 8px 0 14px;
    }
    .banner b{letter-spacing:.2px}
    .banner.good{border-color: rgba(25,195,125,.55); background: rgba(25,195,125,.12);}
    .banner.bad{border-color: rgba(255,77,79,.55); background: rgba(255,77,79,.12);}

    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
    .page{display:none}
    .page.active{display:block}

    /* Calcolatore action block */
    .actionBlock{
      margin-top:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      border-radius: 20px;
      padding:14px;
    }
    .stakeBig{
      display:flex; align-items:flex-end; justify-content:space-between;
      gap:12px;
    }
    .stakeBig .label{color:var(--muted); font-weight:900; font-size:12px}
    .stakeBig .value{font-size:28px; font-weight:1000; letter-spacing:.2px}
    .stakeBig .sub{color:var(--muted); font-size:12px; font-weight:800}
    .pillMini{
      display:inline-flex; align-items:center; gap:8px;
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.04);
      padding:8px 10px;
      border-radius: 999px;
      font-weight:900;
      color:var(--muted);
      font-size:12px;
    }
    .right{display:flex; flex-direction:column; gap:8px; align-items:flex-end}

    /* List cards (storico) */
    .list{display:flex; flex-direction:column; gap:12px;}
    .betCard{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      border-radius: 22px;
      padding:14px;
      position:relative;
    }
    .betCard .top{
      display:flex; align-items:flex-start; justify-content:space-between; gap:12px;
    }
    .betCard .t1{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .betCard .date{color:var(--muted); font-weight:900}
    .betCard .method{
      background: rgba(109,94,246,.16);
      border:1px solid rgba(109,94,246,.40);
      color: rgba(235,232,255,.95);
      padding:6px 10px; border-radius: 999px;
      font-weight:950; font-size:12px;
    }
    .betCard .t2{color: rgba(230,236,252,.92); font-weight:900; margin-top:6px;}
    .betCard .mid{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;}
    .betCard .actions{display:flex; gap:10px; flex-wrap:wrap; margin-top:12px;}
    .smallBtn{
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.04);
      color:var(--text);
      padding:10px 12px;
      border-radius: 16px;
      cursor:pointer;
      font-weight:900;
    }
    .smallBtn.good{border-color: rgba(25,195,125,.50); background: rgba(25,195,125,.12);}
    .smallBtn.bad{border-color: rgba(255,77,79,.50); background: rgba(255,77,79,.12);}
    .smallBtn.warn{border-color: rgba(245,200,75,.50); background: rgba(245,200,75,.12);}
    .smallBtn.neu{border-color: rgba(159,176,208,.45); background: rgba(159,176,208,.10);}

    .detailsBox{
      margin-top:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      border-radius: 22px;
      padding:14px;
    }
    .detailsBox h3{margin:0 0 10px; font-size:14px;}
    .detailsList{
      display:flex; flex-direction:column; gap:12px;
    }
    .kv{
      width:100%;
      border-collapse:collapse;
      font-size:13px;
    }
    .kv td{
      border-bottom:1px dashed rgba(255,255,255,.10);
      padding:8px 0;
      vertical-align:top;
    }
    .kv td:first-child{
      width:36%;
      color:var(--muted);
      font-weight:900;
      padding-right:12px;
    }

    /* Dashboard canvases */
    canvas{
      width:100%;
      height:220px;
      background: rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.08);
      border-radius: 22px;
    }

    /* Responsive */
    @media (max-width: 980px){
      .sidebar{transform: translateX(-105%);}
      .sidebar.show{transform: translateX(0);}
      .main{margin-left:0;}
      .hamburger{display:inline-flex; align-items:center; justify-content:center;}
      .overlay{
        display:none;
        position:fixed; inset:0;
        background: rgba(0,0,0,.55);
        z-index:9;
      }
      .overlay.show{display:block;}
      .grid2{grid-template-columns:1fr;}
    }
  </style>
</head>
<body>
<div class="app">

  <div class="overlay" id="overlay"></div>

  <aside class="sidebar" id="sidebar">
    <div class="sidebarHeader">
      <div class="brand">
        <div class="logo"></div>
        <div class="brandText">
          <b>BetTools</b>
          <small>Webapp locale</small>
        </div>
      </div>
      <button class="btn" id="closeSidebar" style="width:auto;padding:10px 12px">✕</button>
    </div>

    <nav class="nav" id="nav">
      <button data-page="calc" class="active">Calcolatori <span>›</span></button>
      <button data-page="storico">Storico <span>›</span></button>
      <button data-page="dash">Dashboard <span>›</span></button>
      <button data-page="time">Riepilogo temporale <span>›</span></button>
      <button data-page="filters">Riepilogo filtri <span>›</span></button>
      <button data-page="backup">Backup/Restore <span>›</span></button>
    </nav>

    <div style="margin-top:18px">
      <div class="help">
        <b>Nota:</b> Pending/Non giocata non vengono conteggiate nelle dashboard.
      </div>
    </div>
  </aside>

  <main class="main">
    <div class="topbar">
      <button class="hamburger" id="hamburger">☰</button>
      <div class="pill">
        <span class="dot neu" id="pillDot"></span>
        <span id="pillText">Giornata: —</span>
      </div>
    </div>

    <!-- CALCOLATORI -->
    <section class="page active" id="page-calc">
      <h1>Calcolatori</h1>

      <div id="dailyBannerWrap"></div>

      <div class="grid2">
        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Incolla notifica LivePick</b><br/>
              <small>Parse + calcolo PROB/EV/Stake (NEXT).</small>
            </div>
          </div>

          <label for="lpText">Incolla notifica</label>
          <textarea id="lpText" spellcheck="false" placeholder="Incolla qui la notifica..."></textarea>

          <div class="row" style="margin-top:10px">
            <button class="btn primary" id="btnParse">Parse</button>
            <button class="btn" id="btnClear">Pulisci</button>
            <button class="btn danger" id="btnResetAll">Reset totale</button>
          </div>

          <div id="parseMsg" class="help" style="margin-top:10px"></div>

          <!-- ACTION BLOCK -->
          <div id="actionWrap"></div>
        </div>

        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Stake v2</b><br/>
              <small>Min 1% • Max 5% • BR giornaliero fisso.</small>
            </div>
          </div>

          <div class="grid" style="grid-template-columns:1fr 1fr; gap:10px">
            <div>
              <label>Bankroll attuale</label>
              <input id="bankrollInput" type="number" min="0" step="0.01" />
              <div class="help">Calcolato automaticamente dopo ogni bet chiusa.</div>
            </div>
            <div>
              <label>Bankroll giornaliero (oggi)</label>
              <input id="bankrollDay" type="text" disabled />
            </div>
          </div>

          <div class="row" style="margin-top:10px">
            <button class="btn good" id="btnAddToHistory" disabled>➕ Aggiungi a storico</button>
          </div>

          <div class="help" style="margin-top:10px">
            Esito e correzioni in <b>Storico</b>. Pending/Non giocata non vengono conteggiate.
          </div>
        </div>
      </div>
    </section>

    <!-- STORICO -->
    <section class="page" id="page-storico">
      <h1>Storico</h1>

      <div class="card">
        <div class="cardHeader">
          <div>
            <b>Filtri</b><br/>
            <small>Pending/Non giocata non conteggiate.</small>
          </div>
          <div class="row">
            <button class="btn" id="btnAddManualBet" style="width:auto">➕ Manuale</button>
            <select id="historyResultFilter" style="width:auto; min-width:160px">
              <option value="all">Tutte</option>
              <option value="win">Vinte</option>
              <option value="loss">Perse</option>
              <option value="pending">Pending</option>
              <option value="not_played">Non giocate</option>
            </select>
            <select id="historyDateFilter" style="width:auto; min-width:160px">
              <option value="all">Tutto</option>
              <option value="today">Oggi</option>
              <option value="yesterday">Ieri</option>
              <option value="week">Settimana corrente</option>
              <option value="month">Mese corrente</option>
            </select>
          </div>
        </div>

        <div id="historyList" class="list"></div>
        <div id="historyEmpty" class="help"></div>
      </div>

      <div class="card" style="margin-top:14px">
        <div class="cardHeader">
          <div>
            <b>Dettagli bet</b><br/>
            <small>Visualizza JSON raw oppure vista leggibile.</small>
          </div>
          <div class="row">
            <button class="btn" id="btnToggleRaw" disabled>Mostra JSON raw</button>
          </div>
        </div>
        <div class="detailsBox" id="detailsBox">Seleziona “Dettagli” su una bet.</div>
      </div>
    </section>
<!-- BLOCCO 2/4 -->
    <!-- DASHBOARD -->
    <section class="page" id="page-dash">
      <h1>Dashboard</h1>

      <div class="grid2">
        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Riepilogo</b><br/>
              <small>Solo bet chiuse.</small>
            </div>
            <div class="row">
              <select id="dashRangeSelect" style="width:auto; min-width:160px">
                <option value="all">All time</option>
                <option value="today">Oggi</option>
                <option value="yesterday">Ieri</option>
                <option value="week">Questa settimana</option>
                <option value="month">Questo mese</option>
              </select>
              <button class="btn primary" id="btnGoStorico" style="width:auto">Vai a storico</button>
            </div>
          </div>

          <div class="row" style="gap:12px">
            <div class="chip" id="chipBets">Bets: <b>—</b></div>
            <div class="chip" id="chipWR">WR: <b>—</b></div>
            <div class="chip" id="chipROI">ROI: <b>—</b></div>
            <div class="chip" id="chipProfit">Profit: <b>—</b></div>
          </div>

          <div class="row" style="margin-top:12px; gap:12px">
            <div class="chip" id="chipDD">Max DD: <b>—</b></div>
            <div class="chip" id="chipStreakW">W Streak: <b>—</b></div>
            <div class="chip" id="chipStreakL">L Streak: <b>—</b></div>
          </div>

          <div class="help" id="dashMsg" style="margin-top:10px"></div>
        </div>

        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Bankroll</b><br/>
              <small>Imposta bankroll attuale (base).</small>
            </div>
            <div class="row">
              <button class="btn good" id="btnSaveBR" style="width:auto">Salva bankroll</button>
              <button class="btn" id="btnNewDay" style="width:auto">Nuovo giorno</button>
            </div>
          </div>
          <label>Bankroll attuale</label>
          <input id="bankrollInputDash" type="number" min="0" step="0.01" />
          <div class="help">Il bankroll si aggiorna automaticamente quando chiudi una bet (win/loss).</div>
        </div>
      </div>

      <div class="grid2" style="margin-top:14px">
        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Win Rate</b><br/>
              <small>Distribuzione win/loss (all time)</small>
            </div>
          </div>
          <canvas id="wrCanvas" width="600" height="260"></canvas>
          <div class="row" style="margin-top:10px">
            <div class="help" id="wonLabel">Won: <b>—</b></div>
            <div class="help" id="lostLabel">Lost: <b>—</b></div>
          </div>
        </div>

        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Profit chart</b><br/>
              <small>Solo bet chiuse</small>
            </div>
            <div class="row">
              <select id="profitRangeSelect" style="width:auto; min-width:160px">
                <option value="1m">Ultimi 30g</option>
                <option value="3m">Ultimi 90g</option>
                <option value="6m">Ultimi 180g</option>
                <option value="12m">Ultimi 365g</option>
                <option value="all">All time</option>
              </select>
            </div>
          </div>
          <canvas id="profitCanvas" width="600" height="260"></canvas>
        </div>
      </div>
    </section>

    <!-- TIME SUMMARY -->
    <section class="page" id="page-time">
      <h1>Riepilogo temporale</h1>
      <div class="card">
        <div class="cardHeader">
          <div>
            <b>Aggregazione</b><br/>
            <small>Solo bet chiuse. ROC usa BR giornaliero.</small>
          </div>
          <div class="row">
            <select id="timeGroupSelect" style="width:auto; min-width:160px">
              <option value="day">Giorno</option>
              <option value="week">Settimana</option>
              <option value="month">Mese</option>
            </select>
          </div>
        </div>
        <div style="overflow:auto">
          <table class="kv" id="timeTable"></table>
        </div>
      </div>
    </section>

    <!-- FILTER SUMMARY -->
    <section class="page" id="page-filters">
      <h1>Riepilogo filtri</h1>

      <div class="card">
        <div class="cardHeader">
          <div>
            <b>Ranking filtri</b><br/>
            <small>Basato su key = Method||Phase||Market||Line</small>
          </div>
          <div class="row">
            <select id="filterSort" style="width:auto; min-width:200px">
              <option value="profit">Profit (all time)</option>
              <option value="roi">ROI (all time)</option>
              <option value="wr">WR (all time)</option>
              <option value="n">N bets (all time)</option>
            </select>
          </div>
        </div>

        <div style="overflow:auto">
          <table class="kv" id="filterTable"></table>
        </div>
      </div>

      <div class="card" style="margin-top:14px">
        <div class="cardHeader">
          <div>
            <b>Dettaglio filtro</b><br/>
            <small>Seleziona un filtro sopra per vedere andamento</small>
          </div>
        </div>
        <div id="filterDetail" class="help">Seleziona un filtro nella tabella.</div>
      </div>
    </section>

    <!-- BACKUP -->
    <section class="page" id="page-backup">
      <h1>Backup / Restore</h1>

      <div class="card">
        <div class="cardHeader">
          <div>
            <b>Azioni</b><br/>
            <small>Esporta/Importa JSON. Attenzione: restore può sovrascrivere.</small>
          </div>
          <div class="row">
            <button class="btn danger" id="btnClearHistory" style="width:auto">Svuota storico</button>
            <button class="btn" id="btnRecalc" style="width:auto">Ricalcola profit</button>
          </div>
        </div>

        <div class="row" style="margin-top:10px">
          <button class="btn primary" id="btnBackup" style="width:auto">⬇︎ Crea backup</button>
          <label class="btn" style="width:auto; cursor:pointer">
            ⬆︎ Restore
            <input id="restoreFile" type="file" accept="application/json" style="display:none"/>
          </label>
        </div>

        <div id="backupMsg" class="help" style="margin-top:10px"></div>
      </div>
    </section>

  </main>
</div>

<script>
/* =========================
   State & Storage
========================= */
const STORAGE_KEY="bettools_state_v162";

function defaultState(){
  return {
    settings:{
      bankroll: 100,          // retro-compat
      bankroll_base: 100      // base per bankroll calcolato
    },
    dailySnapshot:{
      date:null,
      bankroll:null
    },
    history:[]
  };
}
function loadState(){
  try{
    const raw=localStorage.getItem(STORAGE_KEY);
    if(!raw) return defaultState();
    const s=JSON.parse(raw);
    return Object.assign(defaultState(), s);
  }catch(e){
    return defaultState();
  }
}
function saveState(){
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}
let state = loadState();

/* =========================
   Utils
========================= */
function todayISO(){
  const d=new Date();
  return d.toISOString().slice(0,10);
}
function yesterdayISO(){
  const d=new Date();
  d.setDate(d.getDate()-1);
  return d.toISOString().slice(0,10);
}
function clamp(x, a, b){
  return Math.max(a, Math.min(b, x));
}
function sum(arr){ return arr.reduce((a,b)=>a+(Number(b)||0),0); }
function fmtMoney(x){
  if(x===null || x===undefined || !Number.isFinite(Number(x))) return "—";
  return Number(x).toFixed(2)+"€";
}
function fmtPct(x){
  if(x===null || x===undefined || !Number.isFinite(Number(x))) return "—";
  return (Number(x)*100).toFixed(1)+"%";
}
function safeNum(x){
  const n = Number(String(x).replace(",","."));
  return Number.isFinite(n) ? n : null;
}
function escapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
function startOfWeekISO(dISO){
  const d = new Date(dISO+"T00:00:00");
  const day = (d.getDay()+6)%7; // Mon=0.Sun=6
  d.setDate(d.getDate()-day);
  return d.toISOString().slice(0,10);
}
function monthKey(dISO){ return dISO.slice(0,7); }
function inDateRange(dISO, range){
  if(range==="all") return true;
  const t = todayISO();
  if(range==="today") return dISO===t;
  if(range==="yesterday") return dISO===yesterdayISO();
  if(range==="week"){
    const sow = startOfWeekISO(t);
    return dISO >= sow && dISO <= t;
  }
  if(range==="month"){
    const ym = t.slice(0,7);
    return dISO.slice(0,7)===ym;
  }
  return true;
}
function addDays(dateISO, days){
  const d = new Date(dateISO+"T00:00:00");
  d.setDate(d.getDate()+days);
  return d.toISOString().slice(0,10);
}
function withinDays(dateISO, daysBack){
  const d = new Date(dateISO+"T00:00:00");
  const now = new Date();
  const cutoff = new Date(now);
  cutoff.setDate(cutoff.getDate()-daysBack);
  return d >= cutoff;
}
function roundStake1decMin1(x){
  const n = Number(x||0);
  const r = Math.round(n*10)/10;
  return Math.max(1, r);
}
function sumClosedProfitAllTime(){
  const closed = state.history.filter(b=>b.result==="win" || b.result==="loss");
  return sum(closed.map(b=>Number(b.profit_real)||0));
}
function getCurrentBankroll(){
  const base = Number(state.settings.bankroll_base ?? state.settings.bankroll ?? 100);
  return base + sumClosedProfitAllTime();
}
function setCurrentBankroll(newCurrent){
  const curProf = sumClosedProfitAllTime();
  state.settings.bankroll_base = Number(newCurrent) - curProf;
  state.settings.bankroll = Number(newCurrent);
  saveState();
}

/* =========================
   Navigation
========================= */
const overlay = document.getElementById("overlay");
const sidebar = document.getElementById("sidebar");
document.getElementById("hamburger").addEventListener("click", ()=>{
  sidebar.classList.add("show"); overlay.classList.add("show");
});
document.getElementById("closeSidebar").addEventListener("click", closeSidebar);
overlay.addEventListener("click", closeSidebar);
function closeSidebar(){
  sidebar.classList.remove("show"); overlay.classList.remove("show");
}
document.getElementById("nav").addEventListener("click",(e)=>{
  const btn = e.target.closest("button[data-page]");
  if(!btn) return;
  setPage(btn.getAttribute("data-page"));
  closeSidebar();
});
function setPage(page){
  document.querySelectorAll(".page").forEach(p=>p.classList.remove("active"));
  document.getElementById("page-"+page).classList.add("active");
  document.querySelectorAll("#nav button").forEach(b=>b.classList.remove("active"));
  const active = document.querySelector(`#nav button[data-page="${page}"]`);
  if(active) active.classList.add("active");

  if(page==="storico") renderHistory();
  if(page==="dash") renderDashboard();
  if(page==="time") renderTimeSummary();
  if(page==="filters") renderFilters();
}
<!-- BLOCCO 3/4 -->
/* =========================
   Parser V3
========================= */
const TAGS = ["META","STATE","STATS","L10","PRESS","LATE","ODDS_TO_BET","LP","PROB"];
function normalizeText(s){
  return String(s || "")
    .replace(/\r/g,"\n")
    .replace(/[ \t]+/g," ")
    .replace(/\n+/g,"\n");
}
function extractBlocks(text){
  const t = normalizeText(text);
  const hits = [];
  const scanRe = new RegExp(`\\b(${TAGS.join("|")})\\s*\\|`, "g");
  let m;
  while((m=scanRe.exec(t))!==null) hits.push({tag:m[1], idx:m.index});
  hits.sort((a,b)=>a.idx-b.idx);
  const blocks = {};
  for(let i=0;i<hits.length;i++){
    const start = hits[i].idx;
    const end = (i+1<hits.length) ? hits[i+1].idx : t.length;
    const chunk = t.slice(start, end).trim();
    blocks[hits[i].tag] = chunk;
  }
  return blocks;
}
function parsePipeKVs(chunk){
  const out={};
  chunk.split("|").forEach(part=>{
    const p=part.trim();
    const m=p.match(/^([A-Za-z0-9_]+)\s*=\s*(.*)$/);
    if(m) out[m[1]]=m[2];
  });
  return out;
}
function parseHA(v){
  if(!v) return {home:null, away:null};
  const m=String(v).trim().match(/^(\d+)\s*\/\s*(\d+)$/);
  if(!m) return {home:null, away:null};
  return {home: Number(m[1]), away: Number(m[2])};
}
function parseScore(v){
  if(!v) return {home:null, away:null};
  const m=String(v).trim().match(/^(\d+)\s*-\s*(\d+)$/);
  if(!m) return {home:null, away:null};
  return {home: Number(m[1]), away: Number(m[2])};
}
function parseODDSTOBET(chunk){
  // ODDS_TO_BET | FT Next Over 1.5 = 2.00
  const label = chunk.replace(/^ODDS_TO_BET\s*\|\s*/i,"").trim();
  const oddsM = label.match(/=\s*([0-9.]+)\s*$/);
  const odds = oddsM ? safeNum(oddsM[1]) : null;

  const phaseM = label.match(/\b(FT|HT)\b/i);
  const phase = phaseM ? phaseM[1].toUpperCase() : null;

  const lineM = label.match(/\bOver\s+([0-9]+(?:\.[0-9]+)?)\b/i);
  const line = lineM ? safeNum(lineM[1]) : null;

  let market = label;
  if(phase) market = market.replace(new RegExp("\\b"+phase+"\\b","i"),"").trim();
  if(line !== null) market = market.replace(new RegExp(String(line).replace(".","\\.")),"").trim();
  market = market.replace(/\s+/g," ").trim();

  return { label, phase, market, line, odds_ref: odds };
}
function parseLP(chunk){
  const kv = parsePipeKVs(chunk);
  const wr = safeNum(kv.WR);
  const roi = safeNum(kv.ROI);
  return {
    WR: wr===null ? null : wr/100,
    ROI: roi===null ? null : roi/100,
    Profit: safeNum(kv.Profit),
    AO: safeNum(kv.AO),
    N: safeNum(kv.N)
  };
}
function parseStatsLine(chunk){
  const kv = parsePipeKVs(chunk);
  return { SOT:parseHA(kv.SOT), SOFF:parseHA(kv.SOFF), COR:parseHA(kv.COR), ATT:parseHA(kv.ATT), DATT:parseHA(kv.DATT) };
}
function parseMETA(chunk){
  const kv = parsePipeKVs(chunk);
  return { Ver:(kv.Ver||"").trim(), Method:(kv.Method||"").trim(), Comp:(kv.Comp||"").trim(), Match:(kv.Match||"").trim() };
}
function parseSTATE(chunk){
  const kv = parsePipeKVs(chunk);
  const sc = parseScore(kv.Score);
  const remht = safeNum(kv.RemHT);
  return {
    Time: safeNum(kv.Time),
    RemHT: remht!==null && remht<0 ? 0 : remht,
    RemFT: safeNum(kv.RemFT),
    ScoreHome: sc.home,
    ScoreAway: sc.away,
    ScoreRaw: kv.Score ? String(kv.Score).trim() : ""
  };
}
function parsePROB(chunk){
  // legacy (opzionale)
  const clean = chunk.replace(/^PROB\s*\|\s*/i,"").trim();
  const parts = clean.split("|").map(s=>s.trim()).filter(Boolean);
  const out = {FT:{}, HT:{}};
  for(const p of parts){
    const m = p.match(/^(FT|HT)\s*\(\+\s*(\d+)\s*\)\s*=\s*([0-9.]+)\s*%?$/i);
    if(!m) continue;
    const ph=m[1].toUpperCase();
    const k=Number(m[2]);
    let v=safeNum(m[3]);
    if(v!==null && v>1) v=v/100;
    out[ph][k]=v;
  }
  return out;
}
function parsePRESS(chunk){
  // supporta "GPI(M=74.986,L10=43.773) | GMS(H=170/11,A=252/41,M=74.986/52) | SI(M=60/50)"
  const out = {GPI_M:null, GPI_L10:null, GMS_M:null, GMS_L10:null, SI_M:null, SI_L10:null};
  const gpiM = chunk.match(/GPI\s*\(\s*M\s*=\s*([0-9.]+)\s*,\s*L10\s*=\s*([0-9.]+)\s*\)/i);
  if(gpiM){ out.GPI_M = safeNum(gpiM[1]); out.GPI_L10 = safeNum(gpiM[2]); }
  const gmsM = chunk.match(/GMS\s*\([\s\S]*?M\s*=\s*([0-9.]+)\s*\/\s*([0-9.]+)\s*\)/i);
  if(gmsM){ out.GMS_M = safeNum(gmsM[1]); out.GMS_L10 = safeNum(gmsM[2]); }
  const siM = chunk.match(/SI\s*\(\s*M\s*=\s*([0-9.]+)\s*\/\s*([0-9.]+)\s*\)/i);
  if(siM){ out.SI_M = safeNum(siM[1]); out.SI_L10 = safeNum(siM[2]); }
  return out;
}
function parseLATE(chunk){
  const kv = parsePipeKVs(chunk);
  return { AT: safeNum(kv.AT), L10: safeNum(kv.L10), L5: safeNum(kv.L5) };
}
function parseNotification(text){
  const blocks = extractBlocks(text);
  const errors = [];
  const warnings = [];
  const required = ["META","STATE","ODDS_TO_BET","LP"];
  for(const r of required){ if(!blocks[r]) errors.push(`Manca blocco: ${r}`); }
  if(errors.length) return {ok:false, errors, warnings, data:null};

  const meta = parseMETA(blocks.META);
  const stateObj = parseSTATE(blocks.STATE);
  const prob = blocks.PROB ? parsePROB(blocks.PROB) : null;
  const oddsToBet = parseODDSTOBET(blocks.ODDS_TO_BET);
  const lp = parseLP(blocks.LP);

  const stats = blocks.STATS ? parseStatsLine(blocks.STATS) : null;
  const l10 = blocks.L10 ? parseStatsLine(blocks.L10) : null;
  const press = blocks.PRESS ? parsePRESS(blocks.PRESS) : null;
  const late = blocks.LATE ? parseLATE(blocks.LATE) : null;

  if(!oddsToBet || oddsToBet.odds_ref===null) errors.push("ODDS_TO_BET non parsabile (serve: '... = 1.45')");
  if(!oddsToBet?.phase) warnings.push("ODDS_TO_BET: Phase (HT/FT) non rilevata");
  if(oddsToBet?.line===null) warnings.push("ODDS_TO_BET: Line non rilevata (es 1.5)");
  if(lp.WR===null) warnings.push("LP.WR mancante");
  if(lp.ROI===null) warnings.push("LP.ROI mancante");
  if(errors.length) return {ok:false, errors, warnings, data:null};

  return { ok:true, errors:[], warnings, data:{
    meta, state:stateObj, stats, l10, prob, press, late, oddsToBet, lp,
    raw: normalizeText(text)
  }};
}

/* =========================
   Model V2 (Poisson + correttori) — NEXT markets
   - Probabilità da Poisson(lambda_remaining) con correzione su:
     GPI (all-time + L10), LATE (AT/L10/L5), SI, GMS
   - Blend con WR LP e WR archivio (shrink) -> P_REF
   - Stake: min 1% max 5%, in € min 1, arrotondato 0.1
   NOTE: PROB block non è più richiesto.
========================= */
function betKeyFromParsed(parsed){
  const m = parsed.meta.Method || "";
  const phase = parsed.oddsToBet.phase || "";
  const market = parsed.oddsToBet.market || parsed.oddsToBet.label || "";
  const line = parsed.oddsToBet.line;
  return `${m}||${phase}||${market}||${line ?? ""}`.trim();
}
function neededGoalsFromLine_NEXT(line){
  if(line===null) return null;
  return Math.floor(line) + 1; // es: 1.5 -> 2 goal "da adesso"
}
function poissonTailProb(lmbda, kPlus){
  if(!Number.isFinite(lmbda) || lmbda<0) return null;
  if(!Number.isFinite(kPlus)) return null;
  if(kPlus<=0) return 1.0;
  let cdf = 0;
  let term = Math.exp(-lmbda);
  cdf += term;
  for(let i=1;i<kPlus;i++){
    term *= (lmbda / i);
    cdf += term;
  }
  return clamp(1 - cdf, 0, 1);
}
function safeDiv(a,b, fallback=0){
  a = Number(a); b = Number(b);
  if(!Number.isFinite(a) || !Number.isFinite(b) || b===0) return fallback;
  return a/b;
}
function sumHA(obj){
  if(!obj) return null;
  const h = Number(obj.home); const a = Number(obj.away);
  if(!Number.isFinite(h) || !Number.isFinite(a)) return null;
  return h+a;
}

/* --- Coefficienti (generati dai tuoi json) --- */
const COEF_FT = {
  intercept: -2.6475635256031107,
  coef: {
    "Minutes_Remaining_FT": -0.006482651719136978,
    "Goals_Scored_So_far": -0.0044240769590670696,
    "Avg_Pressure_Score_FT": 0.10380587431713764,
    "Avg_SOT_per_min": 5.719900475694123,
    "Avg_SOFF_per_min": 0.49538875040487773,
    "Avg_CORNER_per_min": 63.719664341487004,
    "Avg_DA_per_min": -6.269252023077126,
    "Avg_ATT_per_min": 3.406240419112395,
    "Avg_SOT_L10_perMin": -2.4686199505970894,
    "Avg_SOFF_L10_perMin": 17.476960312147803,
    "Avg_CORNERS_L10_perMin": -31.64183110501638,
    "Avg_DA_L10_perMin": -0.1817192173389214,
    "Avg_ATT_L10_perMin": -2.433659065386576,
    "picked_minute": 0.006482651719135257
  }
};
const COEF_HT = {
  intercept: 0.0933197447847644,
  coef: {
    "Minutes_Remaining_HT": 0.024047541890786263,
    "Goals_Scored_So_far": 0.019299705976413097,
    "Avg_Pressure_Score_FT": 0.022092738498312343,
    "Avg_SOT_per_min": 0.1439228811175211,
    "Avg_SOFF_per_min": 4.532687953230974,
    "Avg_CORNER_per_min": 38.028892067740664,
    "Avg_DA_per_min": 1.4984146913952283,
    "Avg_ATT_per_min": -4.212725592191199,
    "Avg_SOT_L10_perMin": -0.5929748033384535,
    "Avg_SOFF_L10_perMin": -1.503362285114244,
    "Avg_CORNERS_L10_perMin": -7.347130283107119,
    "Avg_DA_L10_perMin": -0.6784695295588267,
    "Avg_ATT_L10_perMin": 1.6335777635106252,
    "picked_minute": -0.0240475418907835
  }
};

function computePressureScoreFromCounts(perMin){
  const s = Number(perMin.SOT)||0;
  const so = Number(perMin.SOFF)||0;
  const c = Number(perMin.COR)||0;
  const da = Number(perMin.DA)||0;
  const at = Number(perMin.ATT)||0;
  return 0.35*s + 0.20*so + 0.15*c + 0.20*da + 0.10*at;
}

function buildFeatureRow(parsed){
  const t = Number(parsed.state?.Time);
  const remFT = Number(parsed.state?.RemFT);
  const remHT = Number(parsed.state?.RemHT);
  const goalsSoFar = (Number(parsed.state?.ScoreHome)||0) + (Number(parsed.state?.ScoreAway)||0);

  const totSOT = sumHA(parsed.stats?.SOT);
  const totSOFF = sumHA(parsed.stats?.SOFF);
  const totCOR = sumHA(parsed.stats?.COR);
  const totDA = sumHA(parsed.stats?.DATT);
  const totATT = sumHA(parsed.stats?.ATT);

  const l10SOT = sumHA(parsed.l10?.SOT);
  const l10SOFF = sumHA(parsed.l10?.SOFF);
  const l10COR = sumHA(parsed.l10?.COR);
  const l10DA = sumHA(parsed.l10?.DATT);
  const l10ATT = sumHA(parsed.l10?.ATT);

  const denomAll = (Number.isFinite(t) ? (t+1) : 1);
  const denomL10 = 11;

  const perMin = {
    SOT: safeDiv(totSOT, denomAll, 0),
    SOFF: safeDiv(totSOFF, denomAll, 0),
    COR: safeDiv(totCOR, denomAll, 0),
    DA: safeDiv(totDA, denomAll, 0),
    ATT: safeDiv(totATT, denomAll, 0),
  };
  const perMinL10 = {
    SOT: safeDiv(l10SOT, denomL10, 0),
    SOFF: safeDiv(l10SOFF, denomL10, 0),
    COR: safeDiv(l10COR, denomL10, 0),
    DA: safeDiv(l10DA, denomL10, 0),
    ATT: safeDiv(l10ATT, denomL10, 0),
  };

  const pressureScore = computePressureScoreFromCounts(perMin);

  return {
    picked_minute: Number.isFinite(t) ? t : 0,
    Goals_Scored_So_far: goalsSoFar,
    Minutes_Remaining_FT: Number.isFinite(remFT) ? remFT : 0,
    Minutes_Remaining_HT: Number.isFinite(remHT) ? remHT : 0,
    Avg_Pressure_Score_FT: pressureScore,

    Avg_SOT_per_min: perMin.SOT,
    Avg_SOFF_per_min: perMin.SOFF,
    Avg_CORNER_per_min: perMin.COR,
    Avg_DA_per_min: perMin.DA,
    Avg_ATT_per_min: perMin.ATT,

    Avg_SOT_L10_perMin: perMinL10.SOT,
    Avg_SOFF_L10_perMin: perMinL10.SOFF,
    Avg_CORNERS_L10_perMin: perMinL10.COR,
    Avg_DA_L10_perMin: perMinL10.DA,
    Avg_ATT_L10_perMin: perMinL10.ATT
  };
}

function predictLambda(coeffObj, features){
  let lin = Number(coeffObj.intercept)||0;
  for(const [k,v] of Object.entries(coeffObj.coef||{})){
    const x = Number(features[k]);
    lin += (Number.isFinite(x) ? Number(v)*x : 0);
  }
  return clamp(Math.exp(lin), 0, 50);
}

function applyLiveCorrector(lambdaBase, parsed){
  const press = parsed.press || {};
  const late = parsed.late || {};

  const gpi = (Number.isFinite(press.GPI_M) ? press.GPI_M : null);
  const gpi10 = (Number.isFinite(press.GPI_L10) ? press.GPI_L10 : null);
  const gpiMix = (gpi!==null && gpi10!==null) ? (0.6*gpi + 0.4*gpi10) : (gpi!==null ? gpi : gpi10);

  const gms = (Number.isFinite(press.GMS_M) ? press.GMS_M : null);
  const gms10 = (Number.isFinite(press.GMS_L10) ? press.GMS_L10 : null);
  const gmsMix = (gms!==null && gms10!==null) ? (0.6*gms + 0.4*gms10) : (gms!==null ? gms : gms10);

  const si = (Number.isFinite(press.SI_M) ? press.SI_M : null);
  const si10 = (Number.isFinite(press.SI_L10) ? press.SI_L10 : null);
  const siMix = (si!==null && si10!==null) ? (0.6*si + 0.4*si10) : (si!==null ? si : si10);

  const at = Number.isFinite(late.AT) ? late.AT : null;
  const at10 = Number.isFinite(late.L10) ? late.L10 : null;
  const l5 = Number.isFinite(late.L5) ? late.L5 : null;
  const lateScore =
    (at!==null ? 0.5*at : 0) +
    (at10!==null ? 0.3*at10 : 0) +
    (l5!==null ? 0.2*(Math.log1p(l5)/4) : 0);

  const zGPI = (gpiMix!==null) ? ((gpiMix - 75)/30) : 0;
  const zGMS = (gmsMix!==null) ? ((gmsMix - 75)/30) : 0;
  const zLATE = (lateScore - 0.6)/0.4;
  const zSI  = (siMix!==null) ? ((siMix - 50)/20) : 0;

  let delta = 0;
  delta += 0.08 * zGPI;
  delta += 0.06 * zGMS;
  delta += 0.10 * zLATE;
  delta += -0.06 * zSI;

  delta = clamp(delta, -0.25, 0.25);
  const lamAdj = clamp(lambdaBase * Math.exp(delta), 0, 50);
  return {lamAdj, delta};
}

function betaShrinkFromWR(wr, n, alpha=20, beta=20){
  if(wr===null || !Number.isFinite(wr) || n===null || !Number.isFinite(n) || n<=0) return null;
  const wins = wr * n;
  return (wins + alpha) / (n + alpha + beta);
}
function getArchiveStatsForKey(key){
  const closed = state.history.filter(b => b.key===key && (b.result==="win" || b.result==="loss"));
  const N = closed.length;
  if(N===0) return {N:0, winrate:null};
  const wins = closed.filter(b=>b.result==="win").length;
  return {N, winrate: wins/N};
}

function calcStakeV2(parsed){
  const key = betKeyFromParsed(parsed);
  const odds = parsed.oddsToBet?.odds_ref;
  const phase = parsed.oddsToBet?.phase;
  const line = parsed.oddsToBet?.line;
  const needed = neededGoalsFromLine_NEXT(line);

  const warnings = [];
  if(odds===null || !Number.isFinite(odds) || odds<=1) return {ok:false, reason:"Quota ODDS_TO_BET non valida", warnings, key};

  const feats = buildFeatureRow(parsed);
  const lambdaBase = (phase==="HT") ? predictLambda(COEF_HT, feats) : predictLambda(COEF_FT, feats);

  const corr = applyLiveCorrector(lambdaBase, parsed);
  const lambdaAdj = corr.lamAdj;

  const P_MODEL = (needed!==null) ? poissonTailProb(lambdaAdj, needed) : null;

  const lpWR = (parsed.lp && parsed.lp.WR!==null) ? parsed.lp.WR : null;
  const lpN  = (parsed.lp && parsed.lp.N!==null) ? parsed.lp.N : null;
  const P_LP = betaShrinkFromWR(lpWR, lpN, 20, 20);

  const arch = getArchiveStatsForKey(key);
  const P_ARCH = betaShrinkFromWR(arch.winrate, arch.N, 10, 10);
  const N_ARCH = arch.N;

  const wArch = clamp(N_ARCH / 500, 0, 0.40);
  const wLP = 0.25;
  const wModel = 1 - wArch - wLP;

  let num=0, den=0;
  if(P_MODEL!==null){ num += wModel*P_MODEL; den += wModel; }
  if(P_LP!==null){ num += wLP*P_LP; den += wLP; }
  if(P_ARCH!==null){ num += wArch*P_ARCH; den += wArch; }
  const P_REF = den>0 ? clamp(num/den, 0, 1) : null;

  const implied = 1/odds;
  const EV = (P_REF!==null) ? (P_REF*odds - 1) : null;
  const edge = (P_REF!==null) ? (P_REF - implied) : null;

  let stakePct = 0.01;
  let kelly = null;
  if(P_REF!==null){
    if(EV!==null && EV>0){
      kelly = (P_REF*odds - 1) / (odds - 1);
      stakePct = clamp(0.5*kelly, 0.01, 0.05);
    }else{
      stakePct = 0.01;
    }
  }else{
    stakePct = 0.01;
  }

  if(N_ARCH < 50 && stakePct >= 0.05){
    stakePct = 0.04;
    warnings.push("Archivio N<50: cap stake al 4%");
  }

  return {
    ok:true,
    key,
    phase, line,
    needed_goals: needed,
    lambda_base: lambdaBase,
    lambda_adj: lambdaAdj,
    corr_delta: corr.delta,
    P_MODEL,
    P_LP,
    P_ARCH,
    N_archive: N_ARCH,
    P_REF,
    implied,
    edge,
    EV,
    kelly,
    stake_pct: stakePct,
    warnings
  };
}

/* =========================
   Daily snapshot & PnL
========================= */
function ensureDailySnapshot(){
  const t = todayISO();
  if(state.dailySnapshot.date !== t || state.dailySnapshot.bankroll === null){
    state.dailySnapshot.date = t;
    state.dailySnapshot.bankroll = Number(getCurrentBankroll() || 0);
    saveState();
  }
}
function getStartBankrollForDate(dateISO){
  const bets = state.history.filter(b=>b.date===dateISO && b.calc?.bankroll_day);
  if(bets.length>0) return Number(bets[bets.length-1].calc.bankroll_day);
  if(state.dailySnapshot.date===dateISO && state.dailySnapshot.bankroll!==null) return Number(state.dailySnapshot.bankroll);
  return null;
}
function getTodayClosedPnL(){
  const t = todayISO();
  const brDay = getStartBankrollForDate(t);
  const closed = state.history.filter(b=>b.date===t && (b.result==="win" || b.result==="loss"));
  const profit = sum(closed.map(b=>Number(b.profit_real)||0));
  const roc = (brDay!==null && brDay>0) ? (profit/brDay) : null;
  return {profit, roc, brDay, closedCount: closed.length};
}
function dayStatusFromROC(roc){
  if(roc===null) return {label:"", cls:""};
  if(roc>=0.03) return {label:"Target profit", cls:"badge win"};
  if(roc<=-0.10) return {label:"Stop loss", cls:"badge loss"};
  return {label:"", cls:""};
}
function updateDailyPill(){
  const info=getTodayClosedPnL();
  const pillDot=document.getElementById("pillDot");
  const pillText=document.getElementById("pillText");
  if(info.brDay===null){
    pillDot.className="dot neu"; pillText.textContent="Giornata: —";
    return;
  }
  if(info.roc!==null && info.roc>=0.03){
    pillDot.className="dot good"; pillText.textContent="Fermati: Target profit";
  }else if(info.roc!==null && info.roc<=-0.10){
    pillDot.className="dot bad"; pillText.textContent="Fermati: Stop loss";
  }else{
    pillDot.className="dot neu"; pillText.textContent="Giornata: neutra";
  }
}
function renderDailyBanner(){
  const wrap=document.getElementById("dailyBannerWrap");
  const info=getTodayClosedPnL();
  wrap.innerHTML="";
  if(info.brDay===null){
    wrap.innerHTML = `<div class="banner"><b>Bankroll giornaliero</b><small>Nessuno snapshot per oggi: verrà creato alla prima bet aggiunta allo storico.</small></div>`;
    return;
  }
  const rocStr = info.roc===null ? "—" : fmtPct(info.roc);
  const pStr = fmtMoney(info.profit);
  const brStr = fmtMoney(info.brDay);

  if(info.roc!==null && info.roc>=0.03){
    wrap.innerHTML = `<div class="banner good"><b>TARGET PROFIT RAGGIUNTO</b><small>Oggi: <b>${pStr}</b> (ROC ${rocStr}) su BR day <b>${brStr}</b>. Fermati.</small></div>`;
  }else if(info.roc!==null && info.roc<=-0.10){
    wrap.innerHTML = `<div class="banner bad"><b>STOP LOSS RAGGIUNTO</b><small>Oggi: <b>${pStr}</b> (ROC ${rocStr}) su BR day <b>${brStr}</b>. Fermati.</small></div>`;
  }else{
    wrap.innerHTML = `<div class="banner"><b>Risultato giornata</b><small>Oggi: <b>${pStr}</b> (ROC ${rocStr}) su BR day <b>${brStr}</b>. (Bet chiuse: ${info.closedCount})</small></div>`;
  }
}

/* =========================
   Profit calc
========================= */
function calcProfit(result, stake, odds){
  const s = Number(stake);
  const o = Number(odds);
  if(!Number.isFinite(s) || s<=0) return null;
  if(result==="win"){
    if(!Number.isFinite(o) || o<=1) return null;
    return s * (o - 1);
  }
  if(result==="loss") return -s;
  return null;
}
function recalcAll(){
  for(const b of state.history){
    if(b.result==="win" || b.result==="loss"){
      b.profit_real = calcProfit(b.result, b.execution.stake_played, b.execution.odds_played);
    }else{
      b.profit_real = null;
    }
  }
  saveState();
  renderAll();
}

/* =========================
   Calcolatore UI
========================= */
const lpText=document.getElementById("lpText");
const btnParse=document.getElementById("btnParse");
const btnClear=document.getElementById("btnClear");
const btnResetAll=document.getElementById("btnResetAll");
const parseMsg=document.getElementById("parseMsg");
const actionWrap=document.getElementById("actionWrap");
const bankrollInput=document.getElementById("bankrollInput");
const bankrollDay=document.getElementById("bankrollDay");
const btnAddToHistory=document.getElementById("btnAddToHistory");

let lastParsed=null;
let lastStake=null;

// action inputs (created after parse)
let oddsPlayedInput=null;
let stakePlayedInput=null;

function syncBankrollInputs(){
  bankrollInput.value = Number(getCurrentBankroll()||0);
  document.getElementById("bankrollInputDash").value = Number(getCurrentBankroll()||0);
  bankrollDay.value = (state.dailySnapshot.date===todayISO() && state.dailySnapshot.bankroll!==null)
    ? fmtMoney(state.dailySnapshot.bankroll)
    : "—";
}
bankrollInput.addEventListener("change", ()=>{
  setCurrentBankroll(Number(bankrollInput.value||0));
  syncBankrollInputs(); renderDailyBanner(); updateDailyPill();
});
document.getElementById("bankrollInputDash").addEventListener("change", ()=>{
  setCurrentBankroll(Number(document.getElementById("bankrollInputDash").value||0));
  syncBankrollInputs(); renderDailyBanner(); updateDailyPill();
});

btnClear.addEventListener("click", ()=>{
  lpText.value=""; lastParsed=null; lastStake=null;
  parseMsg.innerHTML=""; actionWrap.innerHTML="";
  btnAddToHistory.disabled=true;
});
btnResetAll.addEventListener("click", ()=>{
  if(confirm("Sicuro di voler resettare TUTTO? (storico + impostazioni + snapshot)")) resetAll();
});

btnParse.addEventListener("click", ()=>{
  const res = parseNotification(lpText.value);
  actionWrap.innerHTML="";
  oddsPlayedInput=null; stakePlayedInput=null;

  if(!res.ok){
    lastParsed=null; lastStake=null; btnAddToHistory.disabled=true;
    parseMsg.innerHTML =
      `<div class="errLine"><b>Parse fallito:</b><br/>${res.errors.map(e=>`• ${escapeHtml(e)}`).join("<br/>")}</div>` +
      (res.warnings.length ? `<div class="warnLine"><b>Warning:</b><br/>${res.warnings.map(w=>`• ${escapeHtml(w)}`).join("<br/>")}</div>` : "");
    return;
  }

  lastParsed=res.data;
  lastStake=calcStakeV2(lastParsed);

  const warn = [...res.warnings, ...(lastStake.warnings||[])];
  parseMsg.innerHTML = `<div class="okLine"><b>Parse OK.</b> <span class="mono">${escapeHtml(lastParsed.meta.Match)}</span></div>` +
    (warn.length ? `<div class="warnLine"><b>Warning:</b><br/>${warn.map(w=>`• ${escapeHtml(w)}`).join("<br/>")}</div>` : "");

  syncBankrollInputs();

  const brBase = (state.dailySnapshot.date===todayISO() && state.dailySnapshot.bankroll!==null)
    ? Number(state.dailySnapshot.bankroll) : Number(getCurrentBankroll()||0);

  const stakeAmtRaw = (lastStake.stake_pct || 0.01) * brBase;
  const stakeAmt = roundStake1decMin1(stakeAmtRaw);

  const pRef = lastStake.P_REF!==null ? fmtPct(lastStake.P_REF) : "—";
  const implied = lastStake.implied!==null ? fmtPct(lastStake.implied) : "—";
  const edge = lastStake.edge!==null ? fmtPct(lastStake.edge) : "—";
  const needed = lastStake.needed_goals ?? "—";

  const edgeNeg = (lastStake.edge!==null && lastStake.edge<=0);
  const edgeTag = edgeNeg
    ? `<span class="badge loss">Edge: ${escapeHtml(edge)} (negativo)</span>`
    : `<span class="badge win">Edge: ${escapeHtml(edge)}</span>`;

  const oddsRef = lastParsed.oddsToBet?.odds_ref ?? null;

  actionWrap.innerHTML = `
    <div class="actionBlock">
      <div class="stakeBig">
        <div>
          <div class="label">Probabilità stimata</div>
          <div class="value mono">${escapeHtml(pRef)}</div>
          <div class="sub">Goal richiesti (NEXT): <b class="mono">${escapeHtml(String(needed))}</b> • Goal attesi (λ): <b class="mono">${escapeHtml((lastStake.lambda_adj!==null && lastStake.lambda_adj!==undefined) ? lastStake.lambda_adj.toFixed(2) : "—")}</b></div>
        </div>
        <div class="right">
          <div class="pillMini">Market: <b class="mono">${escapeHtml(lastParsed.oddsToBet.phase||"—")}(+${needed})</b></div>
          <div class="pillMini">Fonte: <b>${escapeHtml(lastStake.N_archive>=50 ? "ARCH+MODEL" : "MODEL+WR")}</b> • N arch: <b class="mono">${lastStake.N_archive ?? 0}</b></div>
        </div>
      </div>

      <div class="row" style="margin-top:8px">
        <span class="badge">${escapeHtml(lastParsed.oddsToBet.label)} @ <b class="mono">${escapeHtml(String(lastParsed.oddsToBet.odds_ref))}</b></span>
        <span class="badge">Implied: <b class="mono">${escapeHtml(implied)}</b></span>
        ${edgeTag}
      </div>

      <div class="stakeBig" style="margin-top:10px">
        <div>
          <div class="label">EV (per unità)</div>
          <div class="value mono">${escapeHtml(lastStake.EV===null||lastStake.EV===undefined ? "—" : (lastStake.EV>=0? "+" : "") + lastStake.EV.toFixed(3))}</div>
          <div class="sub">Stake% suggerito: <span class="mono">${escapeHtml(fmtPct(lastStake.stake_pct))}</span> • BR day: <span class="mono">${escapeHtml(fmtMoney(brBase))}</span></div>
        </div>
        <div class="right">
          <div class="label">Stake consigliato</div>
          <div class="value">${escapeHtml(fmtMoney(stakeAmt))}</div>
        </div>
      </div>

      <div class="grid" style="grid-template-columns:1fr 1fr; gap:10px; margin-top:10px">
        <div>
          <label>Stake (modificabile)</label>
          <input id="stakePlayed" type="number" min="1" step="0.1" value="${escapeHtml(String(stakeAmt))}" />
        </div>
        <div>
          <label>Quota (modificabile)</label>
          <input id="oddsPlayed" type="number" min="1.01" step="0.01" value="${escapeHtml(String(oddsRef ?? ""))}" />
        </div>
      </div>

      <div class="help" style="margin-top:10px">
        Se EV è negativo, lo stake rimane comunque all'1% (decidi tu se giocare).
      </div>
    </div>
  `;

  oddsPlayedInput = document.getElementById("oddsPlayed");
  stakePlayedInput = document.getElementById("stakePlayed");

  btnAddToHistory.disabled=false;
});

btnAddToHistory.addEventListener("click", ()=>{
  if(!lastParsed || !lastStake || !lastStake.ok) return;

  ensureDailySnapshot();
  syncBankrollInputs();

  const brDay = Number(state.dailySnapshot.bankroll||0);
  const stakeAmtRaw = (lastStake.stake_pct || 0.01) * brDay;
  const stakeAmt = roundStake1decMin1(stakeAmtRaw);

  const oddsPlayed = safeNum(oddsPlayedInput?.value) ?? safeNum(lastParsed.oddsToBet?.odds_ref);
  const stakePlayed = safeNum(stakePlayedInput?.value);
  const stakePlayedFinal = roundStake1decMin1(stakePlayed ?? stakeAmt);

  const bet = {
    id: crypto.randomUUID ? crypto.randomUUID() : String(Date.now())+"_"+Math.random().toString(16).slice(2),
    date: todayISO(),
    key: lastStake.key,
    meta: lastParsed.meta,
    state: lastParsed.state,
    stats: lastParsed.stats,
    l10: lastParsed.l10,
    prob: lastParsed.prob,
    press: lastParsed.press,
    late: lastParsed.late,
    odds_to_bet: lastParsed.oddsToBet,
    lp: lastParsed.lp,
    calc: {
      stake_source: "MODEL_V2",
      N_archive_at_bet: lastStake.N_archive,
      P_REF: lastStake.P_REF,
      implied_prob: lastStake.implied,
      edge: lastStake.edge,
      kelly: lastStake.kelly,
      stake_suggested_pct: lastStake.stake_pct,
      bankroll_day: brDay,
      needed_goals: lastStake.needed_goals,
      lambda_base: lastStake.lambda_base,
      lambda_adj: lastStake.lambda_adj,
      corr_delta: lastStake.corr_delta,
      P_MODEL: lastStake.P_MODEL,
      P_LP: lastStake.P_LP,
      P_ARCH: lastStake.P_ARCH,
      EV: lastStake.EV
    },
    execution: {
      odds_ref: lastParsed.oddsToBet.odds_ref,
      stake_suggested: stakeAmt,
      odds_played: oddsPlayed,
      stake_played: stakePlayedFinal
    },
    result: "pending",
    profit_real: null,
    raw: lastParsed.raw
  };

  state.history.unshift(bet);
  saveState();
  renderAll();
  setPage("storico");
});
<!-- BLOCCO 4/4 -->
/* =========================
   Storico UI
========================= */
const historyList=document.getElementById("historyList");
const historyEmpty=document.getElementById("historyEmpty");
const historyResultFilter=document.getElementById("historyResultFilter");
const historyDateFilter=document.getElementById("historyDateFilter");
historyResultFilter.addEventListener("change", renderHistory);

document.getElementById("btnAddManualBet").addEventListener("click", ()=>{
  const date = prompt("Data (YYYY-MM-DD):", todayISO());
  if(!date) return;
  const match = prompt("Partita (es: TeamA-TeamB):", "");
  if(match===null) return;
  const market = prompt("Tipo mercato (es: FT Next Over 1.5):", "");
  if(market===null) return;
  const odds = safeNum(prompt("Quota:", "1.80"));
  const stake = safeNum(prompt("Stake (€):", "1.0"));
  const res = prompt("Stato (pending / not_played / win / loss):", "pending");
  const result = (res||"pending").trim();

  const bet = {
    id: crypto.randomUUID ? crypto.randomUUID() : String(Date.now())+"_"+Math.random().toString(16).slice(2),
    date: date,
    key: `MANUAL||${market||""}`.trim(),
    meta: {Ver:"", Method:"MANUAL", Comp:"", Match: match||""},
    state: {},
    stats: null,
    l10: null,
    prob: null,
    press: null,
    late: null,
    odds_to_bet: {label: market||"", phase: market?.includes("HT") ? "HT" : (market?.includes("FT")?"FT":""), market: market||"", line: null, odds_ref: odds},
    lp: {WR:null, ROI:null, Profit:null, AO:null, N:null},
    calc: {
      stake_source: "MANUAL",
      N_archive_at_bet: null,
      P_REF: null,
      implied_prob: (odds && odds>1) ? 1/odds : null,
      edge: null,
      kelly: null,
      stake_suggested_pct: null,
      bankroll_day: null,
      needed_goals: null
    },
    execution: {
      odds_ref: odds,
      stake_suggested: stake,
      odds_played: odds,
      stake_played: roundStake1decMin1(stake||1)
    },
    result: ["pending","not_played","win","loss"].includes(result) ? result : "pending",
    profit_real: null,
    raw: "MANUAL"
  };

  if(bet.result==="win" || bet.result==="loss"){
    bet.profit_real = calcProfit(bet.result, bet.execution.stake_played, bet.execution.odds_played);
  }

  state.history.unshift(bet);
  saveState();
  renderAll();
  setPage("storico");
});

historyDateFilter.addEventListener("change", renderHistory);

let selectedBetId=null;
let showRaw=false;
let editingBetId=null;

document.getElementById("btnToggleRaw").addEventListener("click", ()=>{
  if(!selectedBetId) return;
  showRaw = !showRaw;
  renderDetails(state.history.find(b=>b.id===selectedBetId));
});

function resultBadge(res){
  if(res==="win") return `<span class="badge win">Vinta</span>`;
  if(res==="loss") return `<span class="badge loss">Persa</span>`;
  if(res==="not_played") return `<span class="badge pending">Non giocata</span>`;
  return `<span class="badge neutral">Pending</span>`;
}
function profitChip(b){
  if(b.result==="win"){
    return `<span class="chip good">Profit <b>+${escapeHtml(fmtMoney(b.profit_real))}</b></span>`;
  }
  if(b.result==="loss"){
    return `<span class="chip bad">Profit <b>${escapeHtml(fmtMoney(b.profit_real))}</b></span>`;
  }
  return `<span class="chip warn">Profit <b>—</b></span>`;
}
function formatPick(b){
  return (b.odds_to_bet && b.odds_to_bet.label) ? b.odds_to_bet.label : `${b.odds_to_bet?.phase||""} ${b.odds_to_bet?.market||""} ${b.odds_to_bet?.line??""}`.trim();
}
function filterHistoryList(){
  let arr = state.history.slice();
  const rf = historyResultFilter.value;
  const df = historyDateFilter.value;
  if(rf!=="all") arr = arr.filter(b=>b.result===rf);
  if(df!=="all") arr = arr.filter(b=>inDateRange(b.date, df));
  return arr;
}
function renderBetCardHTML(b, mode){
  const pick = formatPick(b);
  const method = b.meta?.Method || "—";
  const match = b.meta?.Match || "—";
  const stakeS = fmtMoney(b.execution?.stake_suggested);
  const stakeP = fmtMoney(b.execution?.stake_played);
  const oddsRef = b.execution?.odds_ref ?? "—";
  const oddsP = (b.execution?.odds_played ?? "—");
  const badge = resultBadge(b.result);

  const isEditing = (editingBetId === b.id && mode==="history");

  const topLine = isEditing
    ? `
      <div class="t1">
        <input class="mono" data-edit="date" data-id="${b.id}" type="date" value="${escapeHtml(b.date)}" style="width:auto; min-width:160px"/>
        <span class="method">${escapeHtml(method)}</span>
      </div>
      <div class="t2">
        <input data-edit="match" data-id="${b.id}" type="text" value="${escapeHtml(match)}" />
      </div>`
    : `
      <div class="t1">
        <span class="date mono">${escapeHtml(b.date)}</span>
        <span class="method">${escapeHtml(method)}</span>
      </div>
      <div class="t2 mono">${escapeHtml(match)}</div>`;

  const midLine = isEditing
    ? `
      <div class="mid">
        <span class="badge neutral">Pick: <b class="mono">${escapeHtml(pick)}</b></span>
        <span class="badge neutral">Stake: <b class="mono">${escapeHtml(stakeP)}</b></span>
        <span class="badge neutral">Quota: <b class="mono">${escapeHtml(String(oddsP))}</b></span>
      </div>`
    : `
      <div class="mid">
        <span class="badge neutral">Pick: <b class="mono">${escapeHtml(pick)}</b></span>
        <span class="badge neutral">Stake: <b class="mono">${escapeHtml(stakeP)}</b> <small style="opacity:.7">(sugg: ${escapeHtml(stakeS)})</small></span>
        <span class="badge neutral">Quota: <b class="mono">${escapeHtml(String(oddsP))}</b> <small style="opacity:.7">(ref: ${escapeHtml(String(oddsRef))})</small></span>
      </div>`;

  const actions = (mode==="history")
    ? `
      <div class="actions">
        <button class="smallBtn neu" data-act="details" data-id="${b.id}">Dettagli</button>
        <button class="smallBtn neu" data-act="edit" data-id="${b.id}">${isEditing ? "Salva" : "Modifica"}</button>
        <button class="smallBtn warn" data-act="pending" data-id="${b.id}">Pending</button>
        <button class="smallBtn warn" data-act="not_played" data-id="${b.id}">Non giocata</button>
        <button class="smallBtn good" data-act="win" data-id="${b.id}">Vinta</button>
        <button class="smallBtn bad" data-act="loss" data-id="${b.id}">Persa</button>
      </div>`
    : "";

  return `
    <div class="betCard" data-id="${b.id}">
      <div class="top">
        <div style="flex:1">
          ${topLine}
          ${midLine}
          <div class="row" style="margin-top:10px; gap:10px">
            ${badge}
            ${profitChip(b)}
          </div>
        </div>
      </div>
      ${actions}
    </div>
  `;
}

function renderHistory(){
  const arr = filterHistoryList();
  historyList.innerHTML = "";
  if(arr.length===0){
    historyEmpty.textContent = "Nessuna bet nello storico (con i filtri attuali).";
    return;
  }
  historyEmpty.textContent = "";
  for(const b of arr){
    historyList.insertAdjacentHTML("beforeend", renderBetCardHTML(b, "history"));
  }
}
historyList.addEventListener("click",(e)=>{
  const btn = e.target.closest("button[data-act]");
  if(!btn) return;
  const id = btn.getAttribute("data-id");
  const act = btn.getAttribute("data-act");
  const bet = state.history.find(x=>x.id===id);
  if(!bet) return;

  if(act==="details"){
    selectedBetId=id;
    document.getElementById("btnToggleRaw").disabled=false;
    renderDetails(bet);
    return;
  }
  if(act==="edit"){
    if(editingBetId===id){
      // save
      const dateEl = document.querySelector(`input[data-edit="date"][data-id="${id}"]`);
      const matchEl = document.querySelector(`input[data-edit="match"][data-id="${id}"]`);
      if(dateEl) bet.date = dateEl.value;
      if(matchEl) bet.meta.Match = matchEl.value;
      editingBetId=null;
      saveState(); renderAll();
    }else{
      editingBetId=id;
      renderHistory();
    }
    return;
  }

  if(["pending","not_played","win","loss"].includes(act)){
    bet.result = act;
    if(act==="win" || act==="loss"){
      bet.profit_real = calcProfit(bet.result, bet.execution.stake_played, bet.execution.odds_played);
    }else{
      bet.profit_real = null;
    }
    saveState();
    renderAll();
    return;
  }
});

function kvRowsFromObj(obj){
  if(!obj) return [];
  return Object.entries(obj).map(([k,v])=>{
    if(typeof v==="object" && v!==null) return [k, JSON.stringify(v)];
    return [k, String(v)];
  });
}
function sec(title, rows){
  if(!rows || rows.length===0) return "";
  const tr = rows.map(r=>`<tr><td>${escapeHtml(r[0])}</td><td class="mono">${escapeHtml(r[1])}</td></tr>`).join("");
  return `<div><h3>${escapeHtml(title)}</h3><table class="kv">${tr}</table></div>`;
}
function renderDetails(b){
  const box=document.getElementById("detailsBox");
  if(!b){
    box.textContent="Seleziona “Dettagli” su una bet.";
    return;
  }
  if(showRaw){
    document.getElementById("btnToggleRaw").textContent="Mostra vista leggibile";
    box.innerHTML = `<pre class="mono" style="white-space:pre-wrap;margin:0">${escapeHtml(JSON.stringify(b,null,2))}</pre>`;
    return;
  }
  document.getElementById("btnToggleRaw").textContent="Mostra JSON raw";

  const infoRows = [
    ["id", b.id],
    ["date", b.date],
    ["result", b.result],
    ["profit_real", (b.profit_real===null||b.profit_real===undefined)?"—":fmtMoney(b.profit_real)],
  ];

  const all = [];
  all.push(sec("INFO", infoRows));
  all.push(sec("META", kvRowsFromObj(b.meta)));
  all.push(sec("STATE", kvRowsFromObj(b.state)));
  all.push(sec("STATS", kvRowsFromObj(b.stats)));
  all.push(sec("L10", kvRowsFromObj(b.l10)));
  all.push(sec("PRESS", kvRowsFromObj(b.press)));
  all.push(sec("LATE", kvRowsFromObj(b.late)));
  all.push(sec("ODDS_TO_BET", kvRowsFromObj(b.odds_to_bet)));
  all.push(sec("LP", kvRowsFromObj(b.lp)));
  all.push(sec("CALC", kvRowsFromObj(b.calc)));
  all.push(sec("EXECUTION", kvRowsFromObj(b.execution)));
  all.push(sec("RAW (notifica)", [["raw", b.raw ? b.raw : "—"]]));

  box.innerHTML = `<div class="detailsList">${all.join("")}</div>`;
}

/* =========================
   Backup / Restore + actions
========================= */
document.getElementById("btnClearHistory").addEventListener("click", ()=>{
  if(confirm("Svuotare lo storico?")){
    state.history=[];
    saveState();
    selectedBetId=null;
    editingBetId=null;
    document.getElementById("btnToggleRaw").disabled=true;
    document.getElementById("detailsBox").textContent="Seleziona “Dettagli” su una bet.";
    renderAll();
  }
});
document.getElementById("btnRecalc").addEventListener("click", ()=>{
  recalcAll();
  document.getElementById("backupMsg").innerHTML = `<div class="okLine">Ricalcolo completato.</div>`;
});
document.getElementById("btnBackup").addEventListener("click", ()=>{
  const blob = new Blob([JSON.stringify(state,null,2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `bettools_backup_${todayISO()}.json`;
  document.body.appendChild(a);
  a.click(); a.remove();
  URL.revokeObjectURL(url);
  document.getElementById("backupMsg").innerHTML = `<div class="okLine">Backup creato.</div>`;
});
document.getElementById("restoreFile").addEventListener("change", async (e)=>{
  const file = e.target.files && e.target.files[0];
  if(!file) return;
  try{
    const text = await file.text();
    const incoming = JSON.parse(text);
    const replace = confirm("OK = Sostituisci tutto.\nAnnulla = Unisci (merge).");
    if(replace){
      state = incoming;
    }else{
      const cur = loadState();
      const merged = structuredClone(cur);
      merged.settings = incoming.settings || merged.settings;
      merged.dailySnapshot = incoming.dailySnapshot || merged.dailySnapshot;
      const incHist = Array.isArray(incoming.history) ? incoming.history : [];
      const ids = new Set((merged.history||[]).map(b=>b.id));
      for(const b of incHist){
        if(b && b.id && !ids.has(b.id)){
          merged.history.push(b);
          ids.add(b.id);
        }
      }
      state = merged;
    }
    saveState();
    renderAll();
    document.getElementById("backupMsg").innerHTML = `<div class="okLine">Restore completato.</div>`;
  }catch(err){
    document.getElementById("backupMsg").innerHTML = `<div class="errLine">Errore restore: file non valido.</div>`;
  }finally{
    document.getElementById("restoreFile").value="";
  }
});

/* =========================
   Dashboard
========================= */
let dashRange = "all";
let profitRange = "1m";

document.getElementById("dashRangeSelect").addEventListener("change",(e)=>{
  dashRange = e.target.value;
  renderDashboard();
});
document.getElementById("profitRangeSelect").addEventListener("change",(e)=>{
  profitRange = e.target.value;
  renderDashboard();
});
document.getElementById("btnSaveBR").addEventListener("click", ()=>{
  const v = Number(document.getElementById("bankrollInputDash").value||0);
  setCurrentBankroll(v);

  syncBankrollInputs();
  document.getElementById("dashMsg").innerHTML = `<div class="okLine">Bankroll salvato: ${fmtMoney(v)}</div>`;
});
document.getElementById("btnNewDay").addEventListener("click", ()=>{
  if(confirm("Reset snapshot giornaliero?")){
    state.dailySnapshot.date=null;
    state.dailySnapshot.bankroll=null;
    saveState();
    renderAll();
  }
});
document.getElementById("btnGoStorico").addEventListener("click", ()=> setPage("storico"));

function closedBetsFiltered(range){
  return state.history.filter(b=> (b.result==="win" || b.result==="loss") && inDateRange(b.date, range));
}
function computeTotalsRange(range){
  const closed = closedBetsFiltered(range);
  const profit = sum(closed.map(b=>b.profit_real));
  const stakeTot = sum(closed.map(b=>Number(b.execution.stake_played)||0));
  const roi = stakeTot>0 ? (profit/stakeTot) : null;
  const wins = closed.filter(b=>b.result==="win").length;
  const losses = closed.filter(b=>b.result==="loss").length;
  const winrate = closed.length>0 ? wins/closed.length : null;
  return {closedCount:closed.length, wins, losses, profit, stakeTot, roi, winrate, closed};
}
function computeDrawdownFromClosed(closed){
  const sorted = closed.slice().sort((a,b)=> a.date<b.date ? -1 : (a.date>b.date ? 1 : 0));
  let eq=0, peak=0, maxDD=0;
  for(const b of sorted){
    eq += Number(b.profit_real)||0;
    if(eq>peak) peak=eq;
    const dd=peak-eq;
    if(dd>maxDD) maxDD=dd;
  }
  return {maxDD, eqEnd:eq};
}
function computeStreaksFromClosed(closed){
  const sorted = closed.slice().sort((a,b)=> a.date<b.date ? -1 : (a.date>b.date ? 1 : 0));
  let curW=0, curL=0, bestW=0, bestL=0;
  for(const b of sorted){
    if(b.result==="win"){ curW++; curL=0; }
    if(b.result==="loss"){ curL++; curW=0; }
    if(curW>bestW) bestW=curW;
    if(curL>bestL) bestL=curL;
  }
  return {bestW, bestL};
}
function renderDashboard(){
  const t = computeTotalsRange(dashRange);
  document.getElementById("chipBets").innerHTML = `Bets: <b>${t.closedCount}</b>`;
  document.getElementById("chipWR").innerHTML = `WR: <b>${t.winrate===null?"—":Math.round(t.winrate*100)+"%"}</b>`;
  document.getElementById("chipROI").innerHTML = `ROI: <b>${t.roi===null?"—":fmtPct(t.roi)}</b>`;
  document.getElementById("chipProfit").innerHTML = `Profit: <b>${fmtMoney(t.profit)}</b>`;

  const dd = computeDrawdownFromClosed(t.closed);
  const st = computeStreaksFromClosed(t.closed);
  document.getElementById("chipDD").innerHTML = `Max DD: <b>${fmtMoney(dd.maxDD)}</b>`;
  document.getElementById("chipStreakW").innerHTML = `W Streak: <b>${st.bestW}</b>`;
  document.getElementById("chipStreakL").innerHTML = `L Streak: <b>${st.bestL}</b>`;

  drawWRDonutOn(document.getElementById("wrCanvas"), t.closed);
  drawProfitChartOn(document.getElementById("profitCanvas"), t.closed, profitRange);
}

/* donut */
function drawWRDonutOn(canvas, closed){
  const ctx = canvas.getContext("2d");
  const W=canvas.width, H=canvas.height;
  ctx.clearRect(0,0,W,H);

  const wins = closed.filter(b=>b.result==="win").length;
  const total = closed.length;
  const winPct = total>0 ? wins/total : 0;
  const lossPct = total>0 ? 1-winPct : 0;

  const cx=W/2, cy=H/2, r=Math.min(W,H)*0.33;
  const start=-Math.PI/2;

  // base ring
  ctx.lineWidth = r*0.25;
  ctx.strokeStyle="rgba(255,255,255,.10)";
  ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();

  // win arc
  ctx.strokeStyle="rgba(25,195,125,.85)";
  ctx.beginPath(); ctx.arc(cx,cy,r,start,start+Math.PI*2*winPct); ctx.stroke();

  // loss arc
  ctx.strokeStyle="rgba(255,77,79,.75)";
  ctx.beginPath(); ctx.arc(cx,cy,r,start+Math.PI*2*winPct,start+Math.PI*2); ctx.stroke();

  // center label
  ctx.fillStyle="rgba(232,238,252,.92)";
  ctx.font="700 22px "+getComputedStyle(document.body).fontFamily;
  const wr = total>0 ? Math.round(winPct*100) : 0;
  ctx.textAlign="center";
  ctx.fillText(`${wr}%`, cx, cy+8);
  ctx.font="600 12px "+getComputedStyle(document.body).fontFamily;
  ctx.fillStyle="rgba(159,176,208,.95)";
  ctx.fillText("Win Rate", cx, cy+28);

  document.getElementById("wonLabel").innerHTML = `Won: <b>${Math.round(winPct*100)}%</b>`;
  document.getElementById("lostLabel").innerHTML = `Lost: <b>${Math.round(lossPct*100)}%</b>`;
}

/* profit chart */
function filterByRangeMode(closed, mode){
  const now = new Date();
  const cutoff = new Date(now);
  if(mode==="1m") cutoff.setDate(cutoff.getDate()-30);
  if(mode==="3m") cutoff.setDate(cutoff.getDate()-90);
  if(mode==="6m") cutoff.setDate(cutoff.getDate()-180);
  if(mode==="12m") cutoff.setDate(cutoff.getDate()-365);
  if(mode==="all") return closed;
  return closed.filter(b=>{
    const d=new Date(b.date+"T00:00:00");
    return d>=cutoff;
  });
}
function drawProfitChartOn(canvas, closed, mode){
  const ctx = canvas.getContext("2d");
  const W=canvas.width, H=canvas.height;
  ctx.clearRect(0,0,W,H);

  let data = closed.slice().sort((a,b)=> a.date<b.date ? -1 : (a.date>b.date ? 1 : 0));
  data = filterByRangeMode(data, mode);

  let eq=0;
  const pts = data.map(b=> (eq += Number(b.profit_real)||0));
  if(pts.length===0){
    ctx.strokeStyle="rgba(255,255,255,.10)";
    ctx.strokeRect(40,20,W-60,H-50);
    ctx.fillStyle="rgba(159,176,208,.95)";
    ctx.font="600 12px "+getComputedStyle(document.body).fontFamily;
    ctx.fillText("Nessun dato nel periodo", 50, 40);
    return;
  }

  const minY = Math.min(...pts);
  const maxY = Math.max(...pts);
  const pad = (maxY-minY)*0.12 || 1;
  const y0 = minY - pad;
  const y1 = maxY + pad;

  const left=40, top=20, right=W-20, bottom=H-30;
  const plotW = right-left;
  const plotH = bottom-top;

  const xAt = (i)=> left + (pts.length===1 ? plotW/2 : (i/(pts.length-1))*plotW);
  const yAt = (v)=> top + (1-(v-y0)/(y1-y0))*plotH;

  ctx.strokeStyle="rgba(255,255,255,.08)";
  ctx.strokeRect(left, top, plotW, plotH);

  // line
  ctx.beginPath();
  for(let i=0;i<pts.length;i++){
    const x=xAt(i), y=yAt(pts[i]);
    if(i===0) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  }
  ctx.lineWidth=3;
  ctx.strokeStyle="rgba(109,94,246,.85)";
  ctx.stroke();
}

function resetAll(){
  state = defaultState();
  saveState();
  selectedBetId=null;
  editingBetId=null;
  lastParsed=null; lastStake=null;
  showRaw=false;
  document.getElementById("btnToggleRaw").disabled=true;
  document.getElementById("detailsBox").textContent="Seleziona “Dettagli” su una bet.";
  document.getElementById("dashMsg").innerHTML="";
  document.getElementById("backupMsg").innerHTML="";
  actionWrap.innerHTML="";
  parseMsg.innerHTML="";
  btnAddToHistory.disabled=true;
  lpText.value="";
  renderAll();
}

function renderAll(){
  renderDailyBanner();
  updateDailyPill();
  syncBankrollInputs();
  renderHistory();
  renderDashboard();
  renderTimeSummary();
  renderFilters();
}

/* =========================
   Time summary
========================= */
const timeGroupSelect=document.getElementById("timeGroupSelect");
timeGroupSelect.addEventListener("change", renderTimeSummary);
function periodKey(dateISO, group){
  if(group==="day") return dateISO;
  if(group==="week") return startOfWeekISO(dateISO);
  if(group==="month") return monthKey(dateISO);
  return dateISO;
}
function periodLabel(key, group){
  if(group==="day") return key;
  if(group==="week") return "Week of "+key;
  if(group==="month") return key;
  return key;
}
function renderTimeSummary(){
  const timeGroup = timeGroupSelect.value;
  const closed = state.history.filter(b=> b.result==="win" || b.result==="loss");
  const map=new Map();
  for(const b of closed){
    const key=periodKey(b.date, timeGroup);
    if(!map.has(key)) map.set(key,{key,bets:0,wins:0,losses:0,stake:0,profit:0, brDay:null});
    const o=map.get(key);
    o.bets++;
    if(b.result==="win") o.wins++; else o.losses++;
    o.stake += Number(b.execution.stake_played)||0;
    o.profit += Number(b.profit_real)||0;

    if(timeGroup==="day"){
      if(o.brDay===null){
        o.brDay = getStartBankrollForDate(b.date);
      }
    }
  }

  const rows=[...map.values()].sort((a,b)=> a.key<b.key ? 1 : -1);
  const table=document.getElementById("timeTable");
  table.innerHTML = `
    <thead>
      <tr>
        <td><b>Periodo</b></td>
        <td><b>Bets</b></td>
        <td><b>WR</b></td>
        <td><b>Profit</b></td>
        <td><b>ROI</b></td>
        <td><b>ROC</b></td>
        <td><b>Status</b></td>
      </tr>
    </thead>
    <tbody></tbody>
  `;
  const body = table.querySelector("tbody");
  for(const r of rows){
    const closedN=r.wins+r.losses;
    const wr=closedN>0 ? r.wins/closedN : null;
    const roi=r.stake>0 ? r.profit/r.stake : null;
    const roc = (timeGroup==="day" && r.brDay && r.brDay>0) ? (r.profit/r.brDay) : null;
    const status = (timeGroup==="day") ? dayStatusFromROC(roc) : {label:"", cls:""};

    const profitCls = r.profit>=0 ? "badge win" : "badge loss";
    const roiCls = (roi!==null && roi>=0) ? "badge win" : "badge loss";
    const rocCls = (roc!==null && roc>=0) ? "badge win" : (roc!==null ? "badge loss" : "badge neutral");

    const tr=document.createElement("tr");
    tr.innerHTML = `
      <td class="mono">${escapeHtml(periodLabel(r.key,timeGroup))}</td>
      <td>${r.bets}</td>
      <td class="mono">${wr===null?"—":fmtPct(wr)}</td>
      <td><span class="${profitCls}">${escapeHtml(fmtMoney(r.profit))}</span></td>
      <td><span class="${roiCls}">${roi===null?"—":escapeHtml(fmtPct(roi))}</span></td>
      <td><span class="${rocCls}">${roc===null?"—":escapeHtml(fmtPct(roc))}</span></td>
      <td>${status.label ? `<span class="${status.cls}">${escapeHtml(status.label)}</span>` : ""}</td>
    `;
    body.appendChild(tr);
  }
}

/* =========================
   Filters summary
========================= */
document.getElementById("filterSort").addEventListener("change", renderFilters);

function computeRangeForBets(bets, daysBackStart, daysBackEnd){
  const now = new Date();
  const start = new Date(now); start.setDate(start.getDate()-daysBackStart);
  const end = new Date(now); end.setDate(end.getDate()-daysBackEnd);
  const sel = bets.filter(b=>{
    const d=new Date(b.date+"T00:00:00");
    return d<=start && d>=end;
  });
  const profit = sum(sel.map(b=>b.profit_real));
  const stakeTot = sum(sel.map(b=>Number(b.execution.stake_played)||0));
  const roi = stakeTot>0 ? (profit/stakeTot) : null;
  const wins = sel.filter(b=>b.result==="win").length;
  const wr = sel.length>0 ? wins/sel.length : null;
  return {n:sel.length, profit, stakeTot, roi, wr};
}
function renderFilters(){
  const sortBy = document.getElementById("filterSort").value;
  const closed = state.history.filter(b=> b.result==="win" || b.result==="loss");
  const map=new Map();
  for(const b of closed){
    const key = b.key || "(no key)";
    if(!map.has(key)) map.set(key, []);
    map.get(key).push(b);
  }
  const rows=[];
  for(const [key, bets] of map.entries()){
    const all = computeRangeForBets(bets, 0, 99999);
    rows.push({key, bets, ...all});
  }
  rows.sort((a,b)=>{
    if(sortBy==="profit") return (b.profit||0)-(a.profit||0);
    if(sortBy==="roi") return (b.roi||-999)-(a.roi||-999);
    if(sortBy==="wr") return (b.wr||-999)-(a.wr||-999);
    if(sortBy==="n") return (b.n||0)-(a.n||0);
    return 0;
  });
  const table=document.getElementById("filterTable");
  table.innerHTML = `
    <thead>
      <tr>
        <td><b>Filtro</b></td>
        <td><b>N</b></td>
        <td><b>WR</b></td>
        <td><b>Profit</b></td>
        <td><b>ROI</b></td>
      </tr>
    </thead>
    <tbody></tbody>
  `;
  const body = table.querySelector("tbody");
  body.innerHTML="";
  for(const r of rows){
    const tr=document.createElement("tr");
    tr.style.cursor="pointer";
    tr.addEventListener("click", ()=> renderFilterDetail(r));
    tr.innerHTML = `
      <td class="mono">${escapeHtml(r.key)}</td>
      <td>${r.n}</td>
      <td class="mono">${r.wr===null?"—":fmtPct(r.wr)}</td>
      <td class="mono">${escapeHtml(fmtMoney(r.profit))}</td>
      <td class="mono">${r.roi===null?"—":escapeHtml(fmtPct(r.roi))}</td>
    `;
    body.appendChild(tr);
  }
}
function renderFilterDetail(r){
  const box=document.getElementById("filterDetail");
  const last30 = computeRangeForBets(r.bets, 0, 30);
  const prev30 = computeRangeForBets(r.bets, 30, 60);
  box.innerHTML = `
    <div class="row" style="gap:12px; flex-wrap:wrap">
      <span class="badge neutral">Filtro: <b class="mono">${escapeHtml(r.key)}</b></span>
      <span class="badge">All time N: <b class="mono">${r.n}</b></span>
      <span class="badge">All time WR: <b class="mono">${r.wr===null?"—":fmtPct(r.wr)}</b></span>
      <span class="badge">All time ROI: <b class="mono">${r.roi===null?"—":fmtPct(r.roi)}</b></span>
      <span class="badge">All time Profit: <b class="mono">${escapeHtml(fmtMoney(r.profit))}</b></span>
    </div>
    <div class="row" style="gap:12px; margin-top:12px; flex-wrap:wrap">
      <span class="badge neutral">Ultimi 30g: N <b class="mono">${last30.n}</b> • WR <b class="mono">${last30.wr===null?"—":fmtPct(last30.wr)}</b> • ROI <b class="mono">${last30.roi===null?"—":fmtPct(last30.roi)}</b> • Profit <b class="mono">${escapeHtml(fmtMoney(last30.profit))}</b></span>
      <span class="badge neutral">30–60g: N <b class="mono">${prev30.n}</b> • WR <b class="mono">${prev30.wr===null?"—":fmtPct(prev30.wr)}</b> • ROI <b class="mono">${prev30.roi===null?"—":fmtPct(prev30.roi)}</b> • Profit <b class="mono">${escapeHtml(fmtMoney(prev30.profit))}</b></span>
    </div>
  `;
}

/* =========================
   Boot
========================= */
renderAll();
</script>
</body>
</html>
