<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BetTools ‚Äî index</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#10182c;
      --panel2:#0d1528;
      --text:#e8eefc;
      --muted:#9fb0d0;
      --line:#223055;
      --accent:#5aa9ff;
      --good:#19c37d;
      --bad:#ff4d4f;
      --warn:#ffd166;
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --radius: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      background:linear-gradient(180deg,#070b14 0%, #0b1220 45%, #070b14 100%);
      color:var(--text);
    }

    /* Top bar */
    .topbar{
      position:sticky; top:0; z-index:30;
      display:flex; align-items:center; gap:10px;
      padding:12px 14px;
      background:rgba(10,16,31,.86);
      backdrop-filter: blur(10px);
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    .hamburger{
      width:42px; height:42px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(255,255,255,.04);
      display:grid; place-items:center;
      cursor:pointer;
      user-select:none;
    }
    .hamburger:active{transform:scale(.98)}
    .hamburger span{
      display:block; width:18px; height:2px; background:rgba(232,238,252,.92);
      border-radius:2px; position:relative;
    }
    .hamburger span::before,.hamburger span::after{
      content:""; position:absolute; left:0; width:18px; height:2px;
      background:rgba(232,238,252,.92); border-radius:2px;
    }
    .hamburger span::before{top:-6px}
    .hamburger span::after{top:6px}
    .brand{display:flex; flex-direction:column; line-height:1.05}
    .brand b{font-size:14px; letter-spacing:.2px}
    .brand small{color:var(--muted); font-size:12px}
    .topbar .spacer{flex:1}
    .pill{
      padding:7px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.05);
      color:var(--muted); font-size:12px;
      display:flex; gap:8px; align-items:center; white-space:nowrap;
    }
    .dot{width:8px;height:8px;border-radius:50%}
    .dot.good{background:var(--good)}
    .dot.bad{background:var(--bad)}
    .dot.neu{background:#7c8fb7}

    /* Sidebar */
    .overlay{
      position:fixed; inset:0;
      background:rgba(0,0,0,.55);
      opacity:0; pointer-events:none;
      transition:opacity .18s ease;
      z-index:40;
    }
    .overlay.show{opacity:1; pointer-events:auto}
    .sidebar{
      position:fixed; top:0; left:0; bottom:0;
      width:min(82vw, 320px);
      background:linear-gradient(180deg,#0b1220 0%, #0b1220 40%, #0a1020 100%);
      border-right:1px solid rgba(255,255,255,.08);
      transform:translateX(-105%);
      transition:transform .22s ease;
      z-index:50;
      padding:14px;
      box-shadow: var(--shadow);
      display:flex; flex-direction:column; gap:10px;
    }
    .sidebar.show{transform:translateX(0)}
    .sideHeader{display:flex; align-items:center; justify-content:space-between; margin-bottom:8px}
    .sideHeader b{font-size:14px}
    .closeBtn{
      width:38px;height:38px;border-radius:12px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(255,255,255,.04);
      color:var(--text); cursor:pointer;
    }
    .nav{display:flex; flex-direction:column; gap:8px; padding-top:6px}
    .nav button{
      text-align:left; padding:12px 12px; border-radius:14px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(255,255,255,.04);
      color:var(--text); cursor:pointer;
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; font-size:14px;
    }
    .nav button.active{border-color:rgba(90,169,255,.55); background:rgba(90,169,255,.12)}
    .nav button small{color:var(--muted); font-size:12px}
    .sideFooter{
      margin-top:auto;
      border-top:1px solid rgba(255,255,255,.08);
      padding-top:12px;
      color:var(--muted); font-size:12px; line-height:1.4;
    }

    /* Main */
    .main{padding:16px 14px 28px; max-width:1050px; margin:0 auto}
    .page{display:none}
    .page.active{display:block}
    h1{font-size:18px; margin:0 0 10px}
    .muted{color:var(--muted)}
    .mono{font-family:var(--mono)}

    .grid{display:grid; grid-template-columns:1fr; gap:12px}
    @media (min-width:900px){
      .grid.two{grid-template-columns:1fr 1fr}
      .grid.leftwide{grid-template-columns:1.2fr .8fr}
    }
    .card{
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      padding:12px;
      box-shadow: 0 6px 18px rgba(0,0,0,.18);
    }
    .cardHeader{display:flex; align-items:flex-start; justify-content:space-between; gap:12px; margin-bottom:8px}
    .cardHeader b{font-size:14px}
    .cardHeader small{color:var(--muted)}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .btn{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:9px 11px;
      border-radius:12px;
      cursor:pointer;
      font-weight:650;
      font-size:13px;
    }
    .btn.primary{border-color:rgba(90,169,255,.55); background:rgba(90,169,255,.14)}
    .btn.danger{border-color:rgba(255,77,79,.55); background:rgba(255,77,79,.12)}
    .btn.good{border-color:rgba(25,195,125,.55); background:rgba(25,195,125,.12)}
    .btn:active{transform:scale(.99)}
    .btn:disabled{opacity:.5; cursor:not-allowed}

    input, textarea, select{
      width:100%;
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.10);
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      outline:none;
      font-family:var(--sans);
      font-size:14px;
    }
    textarea{min-height:150px; font-family:var(--mono); font-size:12.5px; line-height:1.35}
    label{display:block; color:var(--muted); font-size:12px; margin:10px 0 6px}
    .help{color:var(--muted); font-size:12px; line-height:1.35}
    .warnLine{color:var(--warn); font-size:12px; margin-top:8px}
    .okLine{color:var(--good); font-size:12px; margin-top:8px}
    .errLine{color:var(--bad); font-size:12px; margin-top:8px}

    .banner{
      border-radius:14px;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.04);
      margin-bottom:10px;
    }
    .banner.good{border-color:rgba(25,195,125,.55); background:rgba(25,195,125,.12)}
    .banner.bad{border-color:rgba(255,77,79,.55); background:rgba(255,77,79,.12)}
    .banner b{display:block; margin-bottom:2px; font-size:13px}
    .banner small{color:var(--muted); font-size:12px}

    .badge{
      display:inline-flex; align-items:center; gap:6px;
      padding:5px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.04);
      font-size:12px; color:var(--muted);
      white-space:nowrap;
    }
    .badge.win{border-color:rgba(25,195,125,.55); color:rgba(25,195,125,.95); background:rgba(25,195,125,.10)}
    .badge.loss{border-color:rgba(255,77,79,.55); color:rgba(255,77,79,.95); background:rgba(255,77,79,.10)}
    .badge.pending{border-color:rgba(255,209,102,.55); color:rgba(255,209,102,.95); background:rgba(255,209,102,.10)}
    .badge.neutral{border-color:rgba(124,143,183,.55); color:rgba(159,176,208,.95); background:rgba(124,143,183,.10)}

    /* History card list */
    .list{display:flex; flex-direction:column; gap:10px}

    /* === Betting.gs-style mini cards readability fix (v1.6.1) === */
    .betCard{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      border-radius:14px;
      padding:10px 10px;
    }
    .betTop{
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
    }
    .betTopLeft{min-width:0}
    .betTopLeft .t1{
      display:flex; gap:8px; flex-wrap:wrap; align-items:center;
      font-size:13px; font-weight:750;
    }
    .betTopLeft .t1 .date{color:rgba(232,238,252,.92)}
    .betTopLeft .t1 .method{color:var(--muted); font-weight:650}
    .betTopLeft .t2{
      margin-top:6px;
      color:rgba(232,238,252,.92);
      font-size:13px;
      white-space:normal;       /* FIX: era nowrap */
      overflow:visible;         /* FIX */
      text-overflow:unset;      /* FIX */
      word-break:break-word;    /* FIX */
      line-height:1.25;
    }

    .betMid{
      margin-top:8px;
      display:flex; flex-wrap:wrap; gap:10px;
      align-items:center;
    }
    .chip{
      padding:6px 8px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      font-size:12px;
      color:var(--muted);
      display:flex; gap:6px; align-items:center;
    }
    .chip b{color:var(--text); font-size:12px}
    .chip.good b{color:rgba(25,195,125,.95)}
    .chip.bad b{color:rgba(255,77,79,.95)}
    .chip.warn b{color:rgba(255,209,102,.95)}
    .betActions{
      margin-top:10px;
      display:flex; gap:8px; flex-wrap:wrap;
    }
    .miniBtn{
      padding:7px 10px;
      border-radius:12px;
      font-weight:650;
      font-size:12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.04);
      color:var(--text);
      cursor:pointer;
    }
    .miniBtn.primary{border-color:rgba(90,169,255,.55); background:rgba(90,169,255,.14)}
    .miniBtn.danger{border-color:rgba(255,77,79,.55); background:rgba(255,77,79,.12)}

    /* Calc action block (v1.6.1: compact) */
    .actionBlock{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      border-radius:14px;
      padding:12px;
      margin-top:10px;
    }
    .stakeBig{
      display:flex; align-items:baseline; justify-content:space-between; gap:10px; flex-wrap:wrap;
      margin-bottom:6px;
    }
    .stakeBig .label{color:var(--muted); font-size:12px}
    .stakeBig .value{
      font-size:28px;
      font-weight:900;
      letter-spacing:.2px;
      font-family:var(--mono);
    }
    .stakeBig .sub{color:var(--muted); font-size:12px}
    .stakeBig .right{
      display:flex; flex-direction:column; align-items:flex-end; gap:6px;
    }
    .stakeBig .right .pillMini{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.04);
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
    }

    /* Details list */
    .detailsList{display:flex; flex-direction:column; gap:10px}
    .section{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      border-radius:14px;
      padding:10px;
    }
    .sectionTitle{font-weight:750; font-size:13px; margin-bottom:8px}
    .kvList{display:flex; flex-direction:column; gap:6px}
    .kvItem{display:flex; justify-content:space-between; gap:10px; font-size:12px}
    .kvItem .k{color:var(--muted)}
    .kvItem .v{color:var(--text); font-family:var(--mono); text-align:right; overflow-wrap:anywhere}

    table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      overflow:hidden;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
    }
    th, td{
      padding:10px 10px;
      border-bottom:1px solid rgba(255,255,255,.08);
      text-align:left;
      font-size:13px;
      vertical-align:top;
    }
    th{color:var(--muted); font-weight:700; background:rgba(255,255,255,.03)}
    tr:last-child td{border-bottom:none}

    /* Dashboard compact KPI grid (v1.6.1: 2x2 also on mobile) */
    .kpiGrid{
      display:grid;
      grid-template-columns:1fr 1fr; /* FIX: was 1 column on mobile */
      gap:10px;
    }
    @media (max-width:360px){
      .kpiGrid{grid-template-columns:1fr} /* only tiny phones */
    }
    .kpi{
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
    }
    .kpi span{display:block; color:var(--muted); font-size:12px}
    .kpi b{display:block; font-size:16px; margin-top:2px}
    .kpi b.good{color:rgba(25,195,125,.95)}
    .kpi b.bad{color:rgba(255,77,79,.95)}
    canvas{width:100%; height:auto; border-radius:14px;}
  </style>
</head>

<body>
  <div class="topbar">
    <div class="hamburger" id="hamburger" aria-label="Apri menu" title="Menu"><span></span></div>
    <div class="brand">
      <b>BetTools</b>
      <small>V3 ‚Ä¢ NEXT ‚Ä¢ Stake v1 ‚Ä¢ UI v1.6.1</small>
    </div>
    <div class="spacer"></div>
    <div class="pill" id="pillDaily">
      <span class="dot neu" id="pillDot"></span>
      <span id="pillText">Giornata: neutra</span>
    </div>
  </div>

  <div class="overlay" id="overlay"></div>

  <aside class="sidebar" id="sidebar" aria-label="Menu laterale">
    <div class="sideHeader">
      <b>Menu</b>
      <button class="closeBtn" id="closeSidebar" aria-label="Chiudi menu">‚úï</button>
    </div>
    <div class="nav" id="nav">
      <button data-page="calc" class="active">üßÆ Calcolatore <small>Operativo</small></button>
      <button data-page="storico">üìí Storico <small>Mini-card</small></button>
      <button data-page="dash">üìä Dashboard <small>Grafici</small></button>
      <button data-page="time">üóìÔ∏è Riepilogo temporale <small>ROC</small></button>
      <button data-page="filters">üßæ Riepilogo per filtri <small>ROI</small></button>
    </div>

    <div class="sideFooter">
      <div><b class="mono">Notifica V3</b></div>
      <div>Parser robusto: a capo/spazi ok. NEXT: soglia dipende solo dalla line.</div>
    </div>
  </aside>

  <main class="main">
    <!-- CALCOLATORE -->
    <section class="page active" id="page-calc">
      <h1>Calcolatore</h1>
      <div id="dailyBannerWrap"></div>

      <div class="grid leftwide">
        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Notifica LivePick (V3)</b><br/>
              <small>Incolla notifica. UI v1.6.1: action block compatto.</small>
            </div>
          </div>

          <label for="lpText">Incolla notifica</label>
          <textarea id="lpText" spellcheck="false" placeholder="Incolla qui la notifica..."></textarea>

          <div class="row" style="margin-top:10px">
            <button class="btn primary" id="btnParse">Parse</button>
            <button class="btn" id="btnClear">Pulisci</button>
            <button class="btn danger" id="btnResetAll">Reset totale</button>
          </div>

          <div id="parseMsg" class="help" style="margin-top:10px"></div>

          <!-- ACTION BLOCK -->
          <div id="actionWrap"></div>
        </div>

        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Stake v1</b><br/>
              <small>Min 2% ‚Ä¢ Max 5% ‚Ä¢ BR giornaliero fisso.</small>
            </div>
          </div>

          <div class="kvGrid" style="margin-top:4px">
            <div>
              <label>Bankroll attuale</label>
              <input id="bankrollInput" type="number" min="0" step="0.01" />
              <div class="help">Snapshot giornaliero creato al primo ‚ÄúAggiungi a storico‚Äù.</div>
            </div>
            <div>
              <label>Bankroll giornaliero (oggi)</label>
              <input id="bankrollDay" type="text" disabled />
            </div>
          </div>

          <div class="row" style="margin-top:10px">
            <button class="btn good" id="btnAddToHistory" disabled>‚ûï Aggiungi a storico</button>
          </div>

          <div class="help" style="margin-top:10px">
            Esito e correzioni in <b>Storico</b>. Pending/Non giocata non vengono conteggiate.
          </div>
        </div>
      </div>
    </section>

    <!-- STORICO -->
    <section class="page" id="page-storico">
      <h1>Storico</h1>

      <div class="card">
        <div class="cardHeader">
          <div>
            <b>Filtri</b><br/>
            <small>Pending/Non giocata non conteggiate.</small>
          </div>
          <div class="row">
            <select id="historyResultFilter" style="width:auto; min-width:160px">
              <option value="all">Tutte</option>
              <option value="win">Vinte</option>
              <option value="loss">Perse</option>
              <option value="pending">Pending</option>
              <option value="not_played">Non giocate</option>
            </select>
            <select id="historyDateFilter" style="width:auto; min-width:160px">
              <option value="all">Tutto</option>
              <option value="today">Oggi</option>
              <option value="yesterday">Ieri</option>
              <option value="week">Settimana corrente</option>
              <option value="month">Mese corrente</option>
            </select>
          </div>
        </div>

        <div id="historyList" class="list"></div>
        <div id="historyEmpty" class="help"></div>
      </div>

      <div class="grid two" style="margin-top:12px">
        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Dettagli bet</b><br/>
              <small>Se clicchi ‚ÄúDettagli‚Äù vedi TUTTI i campi arrivati dalla notifica.</small>
            </div>
            <div class="row">
              <button class="btn" id="btnToggleRaw" disabled>Mostra JSON raw</button>
            </div>
          </div>
          <div id="detailsBox" class="help">Seleziona ‚ÄúDettagli‚Äù su una bet.</div>
        </div>

        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Backup / Restore</b><br/>
              <small>JSON completo (storico + impostazioni).</small>
            </div>
          </div>

          <div class="row">
            <button class="btn primary" id="btnBackup">‚¨áÔ∏è Backup</button>
            <label class="btn" style="cursor:pointer">
              ‚¨ÜÔ∏è Restore
              <input type="file" id="restoreFile" accept="application/json" style="display:none"/>
            </label>
          </div>

          <div class="row" style="margin-top:10px">
            <button class="btn danger" id="btnClearHistory">Svuota storico</button>
            <button class="btn" id="btnRecalc">Ricalcola</button>
          </div>

          <div class="help" style="margin-top:10px" id="backupMsg"></div>
        </div>
      </div>
    </section>

    <!-- DASHBOARD -->
    <section class="page" id="page-dash">
      <h1>Dashboard</h1>

      <div class="card">
        <div class="cardHeader">
          <div>
            <b>Filtro periodo</b><br/>
            <small>Influenza KPI e grafici.</small>
          </div>
          <div class="row">
            <select id="dashRangeSelect" style="width:auto; min-width:220px">
              <option value="all" selected>Tutto</option>
              <option value="today">Oggi</option>
              <option value="yesterday">Ieri</option>
              <option value="week">Settimana corrente</option>
              <option value="month">Mese corrente</option>
            </select>
          </div>
        </div>

        <div class="kpiGrid" id="dashKpis"></div>

        <div class="row" style="margin-top:10px">
          <span class="badge">Max DD: <b class="mono" id="dashMaxDD">‚Äî</b></span>
          <span class="badge">Streak W/L: <b class="mono" id="dashStreak">‚Äî</b></span>
        </div>
      </div>

      <div class="grid two" style="margin-top:12px">
        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Win Rate</b><br/>
              <small>Solo bet chiuse.</small>
            </div>
          </div>
          <canvas id="donut" width="520" height="360"></canvas>
          <div class="row" style="margin-top:8px; justify-content:space-between">
            <div class="badge win" id="wonLabel">Won: ‚Äî</div>
            <div class="badge loss" id="lostLabel">Lost: ‚Äî</div>
          </div>
        </div>

        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Profit Chart</b><br/>
              <small>Cumulato bet chiuse.</small>
            </div>
            <div class="row">
              <select id="profitRangeSelect" style="width:auto; min-width:140px">
                <option value="1m" selected>1m</option>
                <option value="6m">6m</option>
                <option value="12m">12m</option>
                <option value="all">all</option>
              </select>
            </div>
          </div>
          <canvas id="profitChart" width="820" height="360"></canvas>
          <div class="help" style="margin-top:8px">Area tutta verde se cumulato finale > 0, tutta rossa se < 0.</div>
        </div>
      </div>

      <div class="card" style="margin-top:12px">
        <div class="cardHeader">
          <div>
            <b>Impostazioni Bankroll</b><br/>
            <small>Usato per stake e snapshot giornaliero.</small>
          </div>
        </div>
        <div class="grid two">
          <div>
            <label>Bankroll attuale</label>
            <input id="bankrollInputDash" type="number" min="0" step="0.01" />
          </div>
          <div>
            <label>Azioni</label>
            <div class="row">
              <button class="btn primary" id="btnSaveBR">Salva bankroll</button>
              <button class="btn" id="btnNewDay">Nuova giornata</button>
            </div>
          </div>
        </div>
        <div class="help" id="dashMsg" style="margin-top:8px"></div>
      </div>
    </section>

    <!-- TIME SUMMARY -->
    <section class="page" id="page-time">
      <h1>Riepilogo temporale</h1>

      <div class="card">
        <div class="cardHeader">
          <div>
            <b>Raggruppa</b><br/>
            <small>Stato solo per Giorno. ROC basato su bankroll inizio giornata.</small>
          </div>
          <div class="row">
            <select id="timeGroupSelect" style="width:auto; min-width:180px">
              <option value="day" selected>Giorni</option>
              <option value="week">Settimane</option>
              <option value="month">Mesi</option>
            </select>
          </div>
        </div>

        <div class="help" id="timeEmpty"></div>
        <div style="overflow:auto">
          <table id="timeTable" style="display:none">
            <thead>
              <tr>
                <th>Periodo</th>
                <th>Bet</th>
                <th>Winrate</th>
                <th>Profitto</th>
                <th>ROI</th>
                <th>ROC</th>
                <th>Stato</th>
              </tr>
            </thead>
            <tbody id="timeBody"></tbody>
          </table>
        </div>
      </div>
    </section>

    <!-- FILTER SUMMARY -->
    <section class="page" id="page-filters">
      <h1>Riepilogo per filtri</h1>

      <div class="card">
        <div class="cardHeader">
          <div>
            <b>Ordinamento</b><br/>
            <small>Default ROI (migliore ‚Üí peggiore).</small>
          </div>
          <div class="row">
            <select id="filterSort" style="width:auto; min-width:220px">
              <option value="roi" selected>Ordina: ROI</option>
              <option value="profit">Ordina: Profitto</option>
              <option value="winrate">Ordina: % Vinte</option>
              <option value="bets">Ordina: Bet giocate</option>
              <option value="name">Ordina: Tipo scommessa</option>
            </select>
          </div>
        </div>
        <div class="help">Confronto LivePick preso dall‚Äôultima bet registrata per filtro.</div>
      </div>

      <div class="grid two" id="filtersGrid" style="margin-top:12px"></div>
    </section>
  </main>

<script>
/* =========================
   State
========================= */
const STORAGE_KEY = "bettools_v3_uiv161";
const DEFAULT_STATE = {
  version: "V3_SIMPLIFIED_UI161",
  settings: { bankroll: 1000 },
  dailySnapshot: { date: null, bankroll: null },
  history: []
};

function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return structuredClone(DEFAULT_STATE);
    const st = JSON.parse(raw);
    if(!st.settings) st.settings = structuredClone(DEFAULT_STATE.settings);
    if(!st.dailySnapshot) st.dailySnapshot = structuredClone(DEFAULT_STATE.dailySnapshot);
    if(!Array.isArray(st.history)) st.history = [];
    return st;
  }catch(e){
    return structuredClone(DEFAULT_STATE);
  }
}
function saveState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
function resetAll(){
  localStorage.removeItem(STORAGE_KEY);
  state = structuredClone(DEFAULT_STATE);
  saveState();
  renderAll();
}
let state = loadState();

/* =========================
   Utils
========================= */
function todayISO(){
  const d = new Date();
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth()+1).padStart(2,"0");
  const dd = String(d.getDate()).padStart(2,"0");
  return `${yyyy}-${mm}-${dd}`;
}
function yesterdayISO(){
  const d = new Date();
  d.setDate(d.getDate()-1);
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth()+1).padStart(2,"0");
  const dd = String(d.getDate()).padStart(2,"0");
  return `${yyyy}-${mm}-${dd}`;
}
function fmtMoney(x){
  if(x === null || x === undefined || Number.isNaN(Number(x))) return "‚Äî";
  return Number(x).toLocaleString("it-IT",{minimumFractionDigits:2, maximumFractionDigits:2});
}
function fmtPct(x){
  if(x === null || x === undefined || Number.isNaN(Number(x))) return "‚Äî";
  return (Number(x)*100).toLocaleString("it-IT",{minimumFractionDigits:2, maximumFractionDigits:2}) + "%";
}
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
function safeNum(v){
  if(v === null || v === undefined) return null;
  const s = String(v).trim();
  if(s.toLowerCase()==="null" || s==="") return null;
  const n = Number(s.replace(",", "."));
  return Number.isFinite(n) ? n : null;
}
function sum(arr){ return arr.reduce((a,b)=>a+(Number(b)||0),0); }
function escapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
function startOfWeekISO(dISO){
  const d = new Date(dISO+"T00:00:00");
  const day = (d.getDay()+6)%7;
  d.setDate(d.getDate()-day);
  return d.toISOString().slice(0,10);
}
function monthKey(dISO){ return dISO.slice(0,7); }
function inDateRange(dISO, range){
  if(range==="all") return true;
  const t = todayISO();
  if(range==="today") return dISO===t;
  if(range==="yesterday") return dISO===yesterdayISO();
  if(range==="week"){
    const sow = startOfWeekISO(t);
    return dISO >= sow && dISO <= t;
  }
  if(range==="month"){
    const ym = t.slice(0,7);
    return dISO.slice(0,7)===ym;
  }
  return true;
}
function inMonthsBack(dISO, months){
  const d = new Date(dISO+"T00:00:00");
  const now = new Date();
  const cutoff = new Date(now);
  cutoff.setMonth(cutoff.getMonth()-months);
  return d >= cutoff;
}

/* =========================
   Navigation
========================= */
const overlay = document.getElementById("overlay");
const sidebar = document.getElementById("sidebar");
document.getElementById("hamburger").addEventListener("click", ()=>{
  sidebar.classList.add("show"); overlay.classList.add("show");
});
document.getElementById("closeSidebar").addEventListener("click", closeSidebar);
overlay.addEventListener("click", closeSidebar);
function closeSidebar(){
  sidebar.classList.remove("show"); overlay.classList.remove("show");
}
document.getElementById("nav").addEventListener("click",(e)=>{
  const btn = e.target.closest("button[data-page]");
  if(!btn) return;
  setPage(btn.getAttribute("data-page"));
  closeSidebar();
});
function setPage(page){
  document.querySelectorAll(".page").forEach(p=>p.classList.remove("active"));
  document.getElementById("page-"+page).classList.add("active");
  document.querySelectorAll("#nav button").forEach(b=>b.classList.remove("active"));
  const active = document.querySelector(`#nav button[data-page="${page}"]`);
  if(active) active.classList.add("active");

  if(page==="storico") renderHistory();
  if(page==="dash") renderDashboard();
  if(page==="time") renderTimeSummary();
  if(page==="filters") renderFilters();
}

/* =========================
   Parser V3
========================= */
const TAGS = ["META","STATE","STATS","L10","PROB","PRESS","LATE","ODDS_TO_BET","LP"];
function normalizeText(s){
  return String(s || "")
    .replace(/\r/g,"\n")
    .replace(/[ \t]+/g," ")
    .replace(/\n+/g,"\n");
}
function extractBlocks(text){
  const t = normalizeText(text);
  const hits = [];
  const scanRe = new RegExp(`\\b(${TAGS.join("|")})\\s*\\|`, "g");
  let m;
  while((m=scanRe.exec(t))!==null) hits.push({tag:m[1], idx:m.index});
  hits.sort((a,b)=>a.idx-b.idx);
  const blocks = {};
  for(let i=0;i<hits.length;i++){
    const start = hits[i].idx;
    const end = (i+1<hits.length) ? hits[i+1].idx : t.length;
    blocks[hits[i].tag] = t.slice(start, end).trim();
  }
  return blocks;
}
function parsePipeKVs(chunk){
  const parts = chunk.split("|").map(x=>x.trim()).filter(Boolean);
  const kvs = {};
  for(let i=1;i<parts.length;i++){
    const p = parts[i];
    const eq = p.indexOf("=");
    if(eq===-1) continue;
    const k = p.slice(0,eq).trim();
    const v = p.slice(eq+1).trim();
    kvs[k] = v;
  }
  return kvs;
}
function parseScore(s){
  if(!s) return {home:null, away:null};
  const m = String(s).match(/(\d+)\s*-\s*(\d+)/);
  if(!m) return {home:null, away:null};
  return {home:Number(m[1]), away:Number(m[2])};
}
function parseHA(s){
  if(!s) return {home:null, away:null};
  const m = String(s).match(/(-?\d+(\.\d+)?)\s*[/\-]\s*(-?\d+(\.\d+)?)/);
  if(!m) return {home:null, away:null};
  return {home:safeNum(m[1]), away:safeNum(m[3])};
}
function parsePROB(chunk){
  const out = {HT:{}, FT:{}};
  const ht = chunk.match(/HT\s*\(([^)]*)\)/i);
  const ft = chunk.match(/FT\s*\(([^)]*)\)/i);
  if(ht){
    ht[1].split(",").forEach(pair=>{
      const m = pair.match(/\+(\d+)\s*=\s*([0-9.,-]+)/);
      if(m) out.HT[Number(m[1])] = safeNum(m[2]);
    });
  }
  if(ft){
    ft[1].split(",").forEach(pair=>{
      const m = pair.match(/\+(\d+)\s*=\s*([0-9.,-]+)/);
      if(m) out.FT[Number(m[1])] = safeNum(m[2]);
    });
  }
  return out;
}
function parsePRESS(chunk){
  const out = {
    GPI: {M_all:null, M_l10:null},
    GMS: {H_all:null,H_l10:null, A_all:null,A_l10:null, M_all:null,M_l10:null},
    SI:  {M_all:null, M_l10:null}
  };
  const gpi = chunk.match(/GPI\s*\(\s*M\s*=\s*([0-9.,-]+)\s*,\s*L10\s*=\s*([0-9.,-]+)\s*\)/i);
  if(gpi){ out.GPI.M_all=safeNum(gpi[1]); out.GPI.M_l10=safeNum(gpi[2]); }
  const gms = chunk.match(/GMS\s*\(\s*H\s*=\s*([0-9.,-]+)\s*\/\s*([0-9.,-]+)\s*,\s*A\s*=\s*([0-9.,-]+)\s*\/\s*([0-9.,-]+)\s*,\s*M\s*=\s*([0-9.,-]+)\s*\/\s*([0-9.,-]+)\s*\)/i);
  if(gms){
    out.GMS.H_all=safeNum(gms[1]); out.GMS.H_l10=safeNum(gms[2]);
    out.GMS.A_all=safeNum(gms[3]); out.GMS.A_l10=safeNum(gms[4]);
    out.GMS.M_all=safeNum(gms[5]); out.GMS.M_l10=safeNum(gms[6]);
  }
  const si = chunk.match(/SI\s*\(\s*M\s*=\s*([0-9.,-]+)\s*\/\s*([0-9.,-]+)\s*\)/i);
  if(si){ out.SI.M_all=safeNum(si[1]); out.SI.M_l10=safeNum(si[2]); }
  return out;
}
function parseLATE(chunk){
  const kv = parsePipeKVs(chunk);
  return { AT:safeNum(kv.AT), L10:safeNum(kv.L10), L5:safeNum(kv.L5) };
}
function parseODDSTOBET(chunk){
  const m = chunk.match(/ODDS_TO_BET\s*\|\s*(.+?)\s*[:=]\s*([0-9.,]+)/i);
  if(!m) return null;
  const label = m[1].trim().replace(/\s+/g," ");
  const odds = safeNum(m[2]);
  const ph = label.match(/\b(HT|FT)\b/i);
  const phase = ph ? ph[1].toUpperCase() : null;
  const lineM = label.match(/([0-9]+(\.[0-9]+)?)\b/);
  const line = lineM ? safeNum(lineM[1]) : null;
  let market = label;
  if(phase) market = market.replace(new RegExp("\\b"+phase+"\\b","i"),"").trim();
  if(line !== null) market = market.replace(new RegExp(String(line).replace(".","\\.")),"").trim();
  market = market.replace(/\s+/g," ").trim();
  return { label, phase, market, line, odds_ref: odds };
}
function parseLP(chunk){
  const kv = parsePipeKVs(chunk);
  const wr = safeNum(kv.WR);
  const roi = safeNum(kv.ROI);
  return {
    WR: wr===null ? null : wr/100,
    ROI: roi===null ? null : roi/100,
    Profit: safeNum(kv.Profit),
    AO: safeNum(kv.AO),
    N: safeNum(kv.N)
  };
}
function parseStatsLine(chunk){
  const kv = parsePipeKVs(chunk);
  return { SOT:parseHA(kv.SOT), SOFF:parseHA(kv.SOFF), COR:parseHA(kv.COR), ATT:parseHA(kv.ATT), DATT:parseHA(kv.DATT) };
}
function parseMETA(chunk){
  const kv = parsePipeKVs(chunk);
  return { Ver:(kv.Ver||"").trim(), Method:(kv.Method||"").trim(), Comp:(kv.Comp||"").trim(), Match:(kv.Match||"").trim() };
}
function parseSTATE(chunk){
  const kv = parsePipeKVs(chunk);
  const sc = parseScore(kv.Score);
  const remht = safeNum(kv.RemHT);
  return {
    Time: safeNum(kv.Time),
    RemHT: remht!==null && remht<0 ? 0 : remht,
    RemFT: safeNum(kv.RemFT),
    ScoreHome: sc.home,
    ScoreAway: sc.away,
    ScoreRaw: kv.Score ? String(kv.Score).trim() : ""
  };
}
function parseNotification(text){
  const blocks = extractBlocks(text);
  const errors = [];
  const warnings = [];
  const required = ["META","STATE","PROB","ODDS_TO_BET","LP"];
  for(const r of required){ if(!blocks[r]) errors.push(`Manca blocco: ${r}`); }
  if(errors.length) return {ok:false, errors, warnings, data:null};

  const meta = parseMETA(blocks.META);
  const stateObj = parseSTATE(blocks.STATE);
  const prob = parsePROB(blocks.PROB);
  const oddsToBet = parseODDSTOBET(blocks.ODDS_TO_BET);
  const lp = parseLP(blocks.LP);

  const stats = blocks.STATS ? parseStatsLine(blocks.STATS) : null;
  const l10 = blocks.L10 ? parseStatsLine(blocks.L10) : null;
  const press = blocks.PRESS ? parsePRESS(blocks.PRESS) : null;
  const late = blocks.LATE ? parseLATE(blocks.LATE) : null;

  if(!oddsToBet || oddsToBet.odds_ref===null) errors.push("ODDS_TO_BET non parsabile (serve: '... = 1.45')");
  if(!oddsToBet?.phase) warnings.push("ODDS_TO_BET: Phase (HT/FT) non rilevata");
  if(oddsToBet?.line===null) warnings.push("ODDS_TO_BET: Line non rilevata (es 1.5)");
  if(lp.WR===null) warnings.push("LP.WR mancante");
  if(lp.ROI===null) warnings.push("LP.ROI mancante");
  if(errors.length) return {ok:false, errors, warnings, data:null};

  const checkProb = (obj, label)=>{
    for(const k of Object.keys(obj)){
      const v = obj[k];
      if(v!==null && (v<0 || v>1)) warnings.push(`PROB ${label}(+${k}) fuori range (0-1): ${v}`);
    }
  };
  checkProb(prob.HT,"HT"); checkProb(prob.FT,"FT");

  return { ok:true, errors:[], warnings, data:{
    meta, state:stateObj, stats, l10, prob, press, late, oddsToBet, lp,
    raw: normalizeText(text)
  }};
}

/* =========================
   Stake v1 (NEXT logic)
========================= */
function betKeyFromParsed(parsed){
  const m = parsed.meta.Method || "";
  const phase = parsed.oddsToBet.phase || "";
  const market = parsed.oddsToBet.market || parsed.oddsToBet.label || "";
  const line = parsed.oddsToBet.line;
  return `${m}||${phase}||${market}||${line ?? ""}`.trim();
}
function neededGoalsFromLine_NEXT(line){
  if(line===null) return null;
  return Math.floor(line) + 1;
}
function pickMatchProbability_NEXT(parsed){
  const phase = parsed.oddsToBet.phase;
  const line = parsed.oddsToBet.line;
  if(!phase || line===null) return {p:null, needed:null, reason:"Phase o Line non disponibili"};
  const needed = neededGoalsFromLine_NEXT(line);
  const table = (phase==="HT") ? parsed.prob.HT : parsed.prob.FT;
  const p = table ? table[needed] : null;
  if(p === undefined || p === null) return {p:null, needed, reason:`Manca PROB ${phase}(+${needed})`};
  return {p, needed, reason:null};
}
function getArchiveStatsForKey(key){
  const closed = state.history.filter(b => b.key===key && (b.result==="win" || b.result==="loss"));
  const N = closed.length;
  if(N===0) return {N:0, winrate:null};
  const wins = closed.filter(b=>b.result==="win").length;
  return {N, winrate: wins/N};
}
function calcStakeV1(parsed){
  const key = betKeyFromParsed(parsed);
  const odds = parsed.oddsToBet.odds_ref;
  const lpWR = parsed.lp.WR;

  const matchP = pickMatchProbability_NEXT(parsed);
  const P_MATCH = matchP.p;
  const arch = getArchiveStatsForKey(key);
  const P_ARCH = arch.winrate;
  const N = arch.N;

  const warnings = [];
  if(odds===null || odds<=1) return {ok:false, reason:"Quota ODDS_TO_BET non valida", warnings, key};
  if(P_MATCH===null) warnings.push(matchP.reason || "Prob match non disponibile");
  if(lpWR===null) warnings.push("LP.WR non disponibile");
  if(P_ARCH===null) warnings.push("Archivio: nessuna bet chiusa per questo filtro (N=0)");

  let P_REF=null, source="LP/MATCH";
  if(N < 50){
    if(lpWR!==null && P_MATCH!==null) P_REF = 0.6*lpWR + 0.4*P_MATCH;
    else P_REF = (lpWR!==null) ? lpWR : P_MATCH;
  }else{
    source="ARCH/MATCH";
    if(P_ARCH!==null && P_MATCH!==null) P_REF = 0.6*P_ARCH + 0.4*P_MATCH;
    else P_REF = (P_ARCH!==null) ? P_ARCH : P_MATCH;
  }
  if(N>=30 && N<70){
    const w=(N-30)/40;
    const left = (lpWR!==null && P_MATCH!==null) ? (0.6*lpWR + 0.4*P_MATCH) : ((lpWR!==null)?lpWR:P_MATCH);
    const right = (P_ARCH!==null && P_MATCH!==null) ? (0.6*P_ARCH + 0.4*P_MATCH) : ((P_ARCH!==null)?P_ARCH:P_MATCH);
    if(left!==null && right!==null) { P_REF = (1-w)*left + w*right; source="BLEND"; }
  }

  const implied = (odds>1) ? 1/odds : null;
  const edge = (P_REF!==null && implied!==null) ? (P_REF - implied) : null;

  let stakePct = 0.02;
  let kelly = null;

  if(P_REF!==null && edge!==null){
    if(edge>0){
      kelly = edge / (odds - 1);
      let kAdj = 0.5 * kelly;
      stakePct = clamp(kAdj, 0.02, 0.05);
    }else{
      stakePct = 0.02;
      warnings.push("Edge negativo: stake impostato al minimo (2%)");
    }
  }else{
    warnings.push("Probabilit√† insufficiente: stake impostato al minimo (2%)");
  }

  if(N < 50 && stakePct >= 0.05){
    stakePct = 0.04;
    warnings.push("N<50: cap stake al 4% (mai massimo stake)");
  }
  if(parsed.lp.N!==null && parsed.lp.N < 500){
    stakePct *= 0.8;
    stakePct = Math.max(stakePct, 0.02);
    warnings.push("LP.N<500: stake ridotto del 20%");
  }

  return {
    ok:true, key, source,
    N_archive:N,
    P_REF, implied, edge,
    kelly,
    stake_pct:stakePct,
    needed_goals: matchP.needed,
    warnings
  };
}

/* =========================
   Daily snapshot & PnL
========================= */
function ensureDailySnapshot(){
  const t = todayISO();
  if(state.dailySnapshot.date !== t || state.dailySnapshot.bankroll === null){
    state.dailySnapshot.date = t;
    state.dailySnapshot.bankroll = Number(state.settings.bankroll || 0);
    saveState();
  }
}
function getStartBankrollForDate(dateISO){
  const bets = state.history.filter(b=>b.date===dateISO && b.calc?.bankroll_day);
  if(bets.length>0) return Number(bets[bets.length-1].calc.bankroll_day);
  if(state.dailySnapshot.date===dateISO && state.dailySnapshot.bankroll!==null) return Number(state.dailySnapshot.bankroll);
  return Number(state.settings.bankroll || 0);
}
function getTodayClosedPnL(){
  const t = todayISO();
  const brDay = (state.dailySnapshot.date===t) ? Number(state.dailySnapshot.bankroll || 0) : null;
  const todays = state.history.filter(b=>b.date===t && (b.result==="win" || b.result==="loss"));
  const profit = sum(todays.map(b=>b.profit_real));
  const roc = (brDay && brDay>0) ? (profit/brDay) : null;
  return {profit, roc, brDay, closedCount:todays.length};
}
function updateDailyPill(){
  const pillDot=document.getElementById("pillDot");
  const pillText=document.getElementById("pillText");
  const info=getTodayClosedPnL();
  if(info.brDay===null){
    pillDot.className="dot neu"; pillText.textContent="Giornata: neutra"; return;
  }
  if(info.roc!==null && info.roc>=0.03){
    pillDot.className="dot good"; pillText.textContent="Target profit raggiunto";
  }else if(info.roc!==null && info.roc<=-0.10){
    pillDot.className="dot bad"; pillText.textContent="Stop loss raggiunto";
  }else{
    pillDot.className="dot neu"; pillText.textContent="Giornata: neutra";
  }
}
function renderDailyBanner(){
  const wrap=document.getElementById("dailyBannerWrap");
  const info=getTodayClosedPnL();
  wrap.innerHTML="";
  if(info.brDay===null){
    wrap.innerHTML = `<div class="banner"><b>Bankroll giornaliero</b><small>Nessuno snapshot per oggi: verr√† creato alla prima bet aggiunta allo storico.</small></div>`;
    return;
  }
  const rocStr = info.roc===null ? "‚Äî" : fmtPct(info.roc);
  const pStr = fmtMoney(info.profit);
  const brStr = fmtMoney(info.brDay);
  if(info.roc!==null && info.roc>=0.03){
    wrap.innerHTML = `<div class="banner good"><b>TARGET PROFIT RAGGIUNTO</b><small>Oggi: <b>${pStr}</b> (ROC ${rocStr}) su BR day <b>${brStr}</b>.</small></div>`;
  }else if(info.roc!==null && info.roc<=-0.10){
    wrap.innerHTML = `<div class="banner bad"><b>STOP LOSS RAGGIUNTO</b><small>Oggi: <b>${pStr}</b> (ROC ${rocStr}) su BR day <b>${brStr}</b>.</small></div>`;
  }else{
    wrap.innerHTML = `<div class="banner"><b>Giornata in corso</b><small>Oggi: <b>${pStr}</b> (ROC ${rocStr}) su BR day <b>${brStr}</b>. (Bet chiuse: ${info.closedCount})</small></div>`;
  }
}

/* =========================
   Profit calc
========================= */
function calcProfit(result, stake, odds){
  const s = Number(stake);
  const o = Number(odds);
  if(!Number.isFinite(s) || s<=0) return null;
  if(result==="win"){
    if(!Number.isFinite(o) || o<=1) return null;
    return s * (o - 1);
  }
  if(result==="loss") return -s;
  return null;
}
function recalcAll(){
  for(const b of state.history){
    if(b.result==="win" || b.result==="loss"){
      b.profit_real = calcProfit(b.result, b.execution.stake_played, b.execution.odds_played);
    }else{
      b.profit_real = null;
    }
  }
  saveState();
  renderAll();
}

/* =========================
   Calcolatore UI
========================= */
const lpText=document.getElementById("lpText");
const btnParse=document.getElementById("btnParse");
const btnClear=document.getElementById("btnClear");
const btnResetAll=document.getElementById("btnResetAll");
const parseMsg=document.getElementById("parseMsg");
const actionWrap=document.getElementById("actionWrap");
const bankrollInput=document.getElementById("bankrollInput");
const bankrollDay=document.getElementById("bankrollDay");
const btnAddToHistory=document.getElementById("btnAddToHistory");

let lastParsed=null;
let lastStake=null;
let oddsPlayedInput=null;
let stakePlayedInput=null;

function syncBankrollInputs(){
  bankrollInput.value = Number(state.settings.bankroll||0);
  document.getElementById("bankrollInputDash").value = Number(state.settings.bankroll||0);
  bankrollDay.value = (state.dailySnapshot.date===todayISO() && state.dailySnapshot.bankroll!==null)
    ? fmtMoney(state.dailySnapshot.bankroll)
    : "‚Äî";
}
bankrollInput.addEventListener("change", ()=>{
  state.settings.bankroll = Number(bankrollInput.value||0);
  saveState(); syncBankrollInputs(); renderDailyBanner(); updateDailyPill();
});
document.getElementById("bankrollInputDash").addEventListener("change", ()=>{
  state.settings.bankroll = Number(document.getElementById("bankrollInputDash").value||0);
  saveState(); syncBankrollInputs(); renderDailyBanner(); updateDailyPill();
});

btnClear.addEventListener("click", ()=>{
  lpText.value=""; lastParsed=null; lastStake=null;
  parseMsg.innerHTML=""; actionWrap.innerHTML="";
  btnAddToHistory.disabled=true;
});
btnResetAll.addEventListener("click", ()=>{
  if(confirm("Sicuro di voler resettare TUTTO? (storico + impostazioni + snapshot)")) resetAll();
});

btnParse.addEventListener("click", ()=>{
  const res = parseNotification(lpText.value);
  actionWrap.innerHTML="";
  oddsPlayedInput=null; stakePlayedInput=null;

  if(!res.ok){
    lastParsed=null; lastStake=null; btnAddToHistory.disabled=true;
    parseMsg.innerHTML =
      `<div class="errLine"><b>Parse fallito:</b><br/>${res.errors.map(e=>`‚Ä¢ ${escapeHtml(e)}`).join("<br/>")}</div>` +
      (res.warnings.length ? `<div class="warnLine"><b>Warning:</b><br/>${res.warnings.map(w=>`‚Ä¢ ${escapeHtml(w)}`).join("<br/>")}</div>` : "");
    return;
  }

  lastParsed=res.data;
  lastStake=calcStakeV1(lastParsed);

  const warn = [...res.warnings, ...(lastStake.warnings||[])];
  parseMsg.innerHTML = `<div class="okLine"><b>Parse OK.</b> <span class="mono">${escapeHtml(lastParsed.meta.Match)}</span></div>` +
    (warn.length ? `<div class="warnLine"><b>Warning:</b><br/>${warn.map(w=>`‚Ä¢ ${escapeHtml(w)}`).join("<br/>")}</div>` : "");

  syncBankrollInputs();

  const brBase = (state.dailySnapshot.date===todayISO() && state.dailySnapshot.bankroll!==null)
    ? Number(state.dailySnapshot.bankroll) : Number(state.settings.bankroll||0);

  const stakeAmt = (lastStake.stake_pct || 0.02) * brBase;

  /* v1.6.1: ACTION BLOCK COMPACT ‚Äî show ONLY stake + fields */
  const needed = lastStake.needed_goals ?? "‚Äî";
  actionWrap.innerHTML = `
    <div class="actionBlock">
      <div class="stakeBig">
        <div>
          <div class="label">Stake suggerito</div>
          <div class="value">${escapeHtml(fmtMoney(stakeAmt))}</div>
          <div class="sub">Stake%: <span class="mono">${escapeHtml(fmtPct(lastStake.stake_pct))}</span> ‚Ä¢ BR base: <span class="mono">${escapeHtml(fmtMoney(brBase))}</span></div>
        </div>
        <div class="right">
          <div class="pillMini">PROB: <b class="mono">${escapeHtml(lastParsed.oddsToBet.phase||"‚Äî")}(+${needed})</b></div>
          <div class="pillMini">Fonte: <b>${escapeHtml(lastStake.source||"‚Äî")}</b> ‚Ä¢ N arch: <b class="mono">${lastStake.N_archive ?? 0}</b></div>
        </div>
      </div>

      <div class="grid two" style="margin-top:10px">
        <div>
          <label>Quota reale giocata (dopo)</label>
          <input id="oddsPlayed" type="number" min="1" step="0.01" placeholder="es: 1.40" />
        </div>
        <div>
          <label>Stake reale giocato (dopo)</label>
          <input id="stakePlayed" type="number" min="0" step="0.01" placeholder="${stakeAmt.toFixed(2)}" value="${stakeAmt.toFixed(2)}" />
        </div>
      </div>
    </div>
  `;

  oddsPlayedInput = document.getElementById("oddsPlayed");
  stakePlayedInput = document.getElementById("stakePlayed");

  btnAddToHistory.disabled=false;
});

btnAddToHistory.addEventListener("click", ()=>{
  if(!lastParsed || !lastStake || !lastStake.ok) return;

  ensureDailySnapshot();
  syncBankrollInputs();

  const brDay = Number(state.dailySnapshot.bankroll||0);
  const stakeAmt = (lastStake.stake_pct || 0.02) * brDay;

  const oddsPlayed = safeNum(oddsPlayedInput?.value);
  const stakePlayed = safeNum(stakePlayedInput?.value) ?? stakeAmt;

  const bet = {
    id: crypto.randomUUID ? crypto.randomUUID() : String(Date.now())+"_"+Math.random().toString(16).slice(2),
    date: todayISO(),
    key: lastStake.key,
    meta: lastParsed.meta,
    state: lastParsed.state,
    stats: lastParsed.stats,
    l10: lastParsed.l10,
    prob: lastParsed.prob,
    press: lastParsed.press,
    late: lastParsed.late,
    odds_to_bet: lastParsed.oddsToBet,
    lp: lastParsed.lp,
    calc: {
      stake_source: lastStake.source,
      N_archive_at_bet: lastStake.N_archive,
      P_REF: lastStake.P_REF,
      implied_prob: lastStake.implied,
      edge: lastStake.edge,
      kelly: lastStake.kelly,
      stake_suggested_pct: lastStake.stake_pct,
      bankroll_day: brDay,
      needed_goals: lastStake.needed_goals
    },
    execution: {
      odds_ref: lastParsed.oddsToBet.odds_ref,
      stake_suggested: stakeAmt,
      odds_played: oddsPlayed,
      stake_played: stakePlayed
    },
    result: "pending",
    profit_real: null,
    raw: lastParsed.raw
  };

  state.history.unshift(bet);
  saveState();
  renderAll();
  setPage("storico");
});

/* =========================
   Storico UI (mini-cards + inline edit)
========================= */
const historyList=document.getElementById("historyList");
const historyEmpty=document.getElementById("historyEmpty");
const historyResultFilter=document.getElementById("historyResultFilter");
const historyDateFilter=document.getElementById("historyDateFilter");
historyResultFilter.addEventListener("change", renderHistory);
historyDateFilter.addEventListener("change", renderHistory);

let selectedBetId=null;
let showRaw=false;
let editingBetId=null;

document.getElementById("btnToggleRaw").addEventListener("click", ()=>{
  if(!selectedBetId) return;
  showRaw = !showRaw;
  renderDetails(state.history.find(b=>b.id===selectedBetId));
});

function resultBadge(res){
  if(res==="win") return `<span class="badge win">Vinta</span>`;
  if(res==="loss") return `<span class="badge loss">Persa</span>`;
  if(res==="not_played") return `<span class="badge pending">Non giocata</span>`;
  return `<span class="badge neutral">Pending</span>`;
}
function profitChip(b){
  if(b.result==="win"){
    return `<span class="chip good">Profit <b>+${escapeHtml(fmtMoney(b.profit_real))}</b></span>`;
  }
  if(b.result==="loss"){
    return `<span class="chip bad">Profit <b>${escapeHtml(fmtMoney(b.profit_real))}</b></span>`;
  }
  return `<span class="chip warn">Profit <b>‚Äî</b></span>`;
}
function formatPick(b){
  return (b.odds_to_bet && b.odds_to_bet.label) ? b.odds_to_bet.label : `${b.odds_to_bet?.phase||""} ${b.odds_to_bet?.market||""} ${b.odds_to_bet?.line??""}`.trim();
}
function filterHistoryList(){
  let arr = state.history.slice();
  const rf = historyResultFilter.value;
  const df = historyDateFilter.value;
  if(rf!=="all") arr = arr.filter(b=>b.result===rf);
  if(df!=="all") arr = arr.filter(b=>inDateRange(b.date, df));
  return arr;
}
function renderHistory(){
  const arr = filterHistoryList();
  historyList.innerHTML="";
  historyEmpty.textContent="";
  if(arr.length===0){
    historyEmpty.textContent="Nessuna bet da mostrare.";
    return;
  }

  for(const b of arr){
    const pick = formatPick(b);
    const method = b.meta?.Method || "‚Äî";
    const match = b.meta?.Match || "‚Äî";
    const stakeS = fmtMoney(b.execution?.stake_suggested);
    const stakeP = fmtMoney(b.execution?.stake_played);
    const oddsRef = b.execution?.odds_ref ?? "‚Äî";
    const oddsP = (b.execution?.odds_played ?? "‚Äî");
    const badge = resultBadge(b.result);
    const isEditing = (editingBetId === b.id);

    const topLine = isEditing
      ? `
        <div class="t1">
          <input class="mono" data-edit="date" data-id="${b.id}" type="date" value="${escapeHtml(b.date)}" style="width:auto; min-width:160px"/>
          <span class="method">${escapeHtml(method)}</span>
        </div>
        <div class="t2">
          <input data-edit="match" data-id="${b.id}" type="text" value="${escapeHtml(match)}" />
        </div>`
      : `
        <div class="t1">
          <span class="date mono">${escapeHtml(b.date)}</span>
          <span class="method">${escapeHtml(method)}</span>
        </div>
        <div class="t2 mono">${escapeHtml(match)}</div>`;

    const midLine = isEditing
      ? `
        <span class="chip">Pick <b class="mono">${escapeHtml(pick)}</b></span>
        <span class="chip">Stake
          <input data-edit="stake_played" data-id="${b.id}" type="number" step="0.01" value="${escapeHtml(String(b.execution?.stake_played ?? ""))}" style="width:110px"/>
          <span class="muted">(${escapeHtml(stakeS)} sug)</span>
        </span>
        <span class="chip">Odds
          <input data-edit="odds_played" data-id="${b.id}" type="number" step="0.01" value="${escapeHtml(String(b.execution?.odds_played ?? ""))}" style="width:90px"/>
          <span class="muted">(${escapeHtml(String(oddsRef))} ref)</span>
        </span>
        <span class="chip">Esito
          <select data-edit="result" data-id="${b.id}" style="width:auto">
            <option value="win" ${b.result==="win"?"selected":""}>Vinta</option>
            <option value="loss" ${b.result==="loss"?"selected":""}>Persa</option>
            <option value="not_played" ${b.result==="not_played"?"selected":""}>Non giocata</option>
            <option value="pending" ${b.result==="pending"?"selected":""}>Pending</option>
          </select>
        </span>
        ${profitChip(b)}
      `
      : `
        <span class="chip">Pick <b class="mono">${escapeHtml(pick)}</b></span>
        <span class="chip">Stake <b class="mono">${escapeHtml(stakeP)}</b> <span class="muted">(${escapeHtml(stakeS)} sug)</span></span>
        <span class="chip">Odds <b class="mono">${escapeHtml(String(oddsP))}</b> <span class="muted">(${escapeHtml(String(oddsRef))} ref)</span></span>
        ${profitChip(b)}
      `;

    const actions = isEditing
      ? `
        <button class="miniBtn primary" data-act="save" data-id="${b.id}">Salva</button>
        <button class="miniBtn" data-act="cancel" data-id="${b.id}">Annulla</button>
        <button class="miniBtn" data-act="details" data-id="${b.id}">Dettagli</button>
      `
      : `
        <button class="miniBtn primary" data-act="edit" data-id="${b.id}">Modifica</button>
        <button class="miniBtn" data-act="details" data-id="${b.id}">Dettagli</button>
        <button class="miniBtn danger" data-act="del" data-id="${b.id}">Elimina</button>
      `;

    const el = document.createElement("div");
    el.className="betCard";
    el.innerHTML = `
      <div class="betTop">
        <div class="betTopLeft">
          ${topLine}
        </div>
        <div>${badge}</div>
      </div>

      <div class="betMid">
        ${midLine}
      </div>

      <div class="betActions">
        ${actions}
      </div>
    `;
    historyList.appendChild(el);
  }
}

historyList.addEventListener("click",(e)=>{
  const btn = e.target.closest("button[data-act]");
  if(!btn) return;
  const id = btn.getAttribute("data-id");
  const act = btn.getAttribute("data-act");
  const b = state.history.find(x=>x.id===id);
  if(!b) return;

  if(act==="del"){
    if(confirm("Eliminare questa bet?")){
      state.history = state.history.filter(x=>x.id!==id);
      saveState();
      if(selectedBetId===id){
        selectedBetId=null;
        document.getElementById("btnToggleRaw").disabled=true;
        document.getElementById("detailsBox").textContent="Seleziona ‚ÄúDettagli‚Äù su una bet.";
      }
      renderAll();
    }
    return;
  }

  if(act==="details"){
    selectedBetId=id;
    showRaw=false;
    document.getElementById("btnToggleRaw").disabled=false;
    document.getElementById("btnToggleRaw").textContent="Mostra JSON raw";
    renderDetails(b);
    return;
  }

  if(act==="edit"){
    editingBetId = id;
    renderHistory();
    return;
  }

  if(act==="cancel"){
    editingBetId = null;
    renderHistory();
    return;
  }

  if(act==="save"){
    const dateEl = document.querySelector(`[data-edit="date"][data-id="${CSS.escape(id)}"]`);
    const matchEl = document.querySelector(`[data-edit="match"][data-id="${CSS.escape(id)}"]`);
    const stakeEl = document.querySelector(`[data-edit="stake_played"][data-id="${CSS.escape(id)}"]`);
    const oddsEl  = document.querySelector(`[data-edit="odds_played"][data-id="${CSS.escape(id)}"]`);
    const resEl   = document.querySelector(`[data-edit="result"][data-id="${CSS.escape(id)}"]`);

    if(dateEl && dateEl.value) b.date = dateEl.value;
    if(matchEl && matchEl.value.trim()) b.meta.Match = matchEl.value.trim();

    const sp = safeNum(stakeEl?.value);
    const op = safeNum(oddsEl?.value);
    if(sp!==null) b.execution.stake_played = sp;
    if(op!==null) b.execution.odds_played = op;
    if(resEl && resEl.value) b.result = resEl.value;

    if(b.result==="win" || b.result==="loss"){
      b.profit_real = calcProfit(b.result, b.execution.stake_played, b.execution.odds_played);
    }else{
      b.profit_real = null;
    }

    saveState();
    editingBetId = null;
    renderAll();
    return;
  }
});

/* =========================
   Details view
========================= */
function renderDetails(b){
  const box=document.getElementById("detailsBox");
  if(!b){
    box.textContent="Seleziona ‚ÄúDettagli‚Äù su una bet.";
    return;
  }
  if(showRaw){
    document.getElementById("btnToggleRaw").textContent="Mostra vista leggibile";
    box.innerHTML = `<pre class="mono" style="white-space:pre-wrap;margin:0">${escapeHtml(JSON.stringify(b,null,2))}</pre>`;
    return;
  }
  document.getElementById("btnToggleRaw").textContent="Mostra JSON raw";

  const sec = (title, rows)=>`
    <div class="section">
      <div class="sectionTitle">${escapeHtml(title)}</div>
      <div class="kvList">
        ${rows.map(([k,v])=>`
          <div class="kvItem"><div class="k">${escapeHtml(k)}</div><div class="v">${escapeHtml(v)}</div></div>
        `).join("")}
      </div>
    </div>`;

  const sMeta = sec("INFO", [
    ["Data", b.date],
    ["Metodo", b.meta?.Method || "‚Äî"],
    ["Competizione", b.meta?.Comp || "‚Äî"],
    ["Match", b.meta?.Match || "‚Äî"],
    ["Pick", formatPick(b)],
    ["Odds ref", String(b.execution?.odds_ref ?? "‚Äî")],
    ["Odds reale", String(b.execution?.odds_played ?? "‚Äî")],
    ["Stake suggerito", fmtMoney(b.execution?.stake_suggested)],
    ["Stake reale", fmtMoney(b.execution?.stake_played)],
    ["Esito", b.result],
    ["Profitto", (b.result==="win"||b.result==="loss") ? fmtMoney(b.profit_real) : "‚Äî"]
  ]);

  const sState = sec("STATE", [
    ["Time", String(b.state?.Time ?? "‚Äî")],
    ["RemHT", String(b.state?.RemHT ?? "‚Äî")],
    ["RemFT", String(b.state?.RemFT ?? "‚Äî")],
    ["Score", b.state?.ScoreRaw || "‚Äî"]
  ]);

  const sStats = sec("STATS", b.stats ? [
    ["SOT (H/A)", `${b.stats.SOT?.home ?? "‚Äî"} / ${b.stats.SOT?.away ?? "‚Äî"}`],
    ["SOFF (H/A)", `${b.stats.SOFF?.home ?? "‚Äî"} / ${b.stats.SOFF?.away ?? "‚Äî"}`],
    ["COR (H/A)", `${b.stats.COR?.home ?? "‚Äî"} / ${b.stats.COR?.away ?? "‚Äî"}`],
    ["ATT (H/A)", `${b.stats.ATT?.home ?? "‚Äî"} / ${b.stats.ATT?.away ?? "‚Äî"}`],
    ["DATT (H/A)", `${b.stats.DATT?.home ?? "‚Äî"} / ${b.stats.DATT?.away ?? "‚Äî"}`]
  ] : [["‚Äî","‚Äî"]]);

  const sL10 = sec("L10", b.l10 ? [
    ["SOT (H/A)", `${b.l10.SOT?.home ?? "‚Äî"} / ${b.l10.SOT?.away ?? "‚Äî"}`],
    ["SOFF (H/A)", `${b.l10.SOFF?.home ?? "‚Äî"} / ${b.l10.SOFF?.away ?? "‚Äî"}`],
    ["COR (H/A)", `${b.l10.COR?.home ?? "‚Äî"} / ${b.l10.COR?.away ?? "‚Äî"}`],
    ["ATT (H/A)", `${b.l10.ATT?.home ?? "‚Äî"} / ${b.l10.ATT?.away ?? "‚Äî"}`],
    ["DATT (H/A)", `${b.l10.DATT?.home ?? "‚Äî"} / ${b.l10.DATT?.away ?? "‚Äî"}`]
  ] : [["‚Äî","‚Äî"]]);

  const probRows = [];
  const addProb = (phase)=>{
    const obj = b.prob?.[phase] || {};
    const keys = Object.keys(obj).sort((a,b)=>Number(a)-Number(b));
    for(const k of keys) probRows.push([`${phase}(+${k})`, String(obj[k])]);
  };
  addProb("HT"); addProb("FT");
  const sProb = sec("PROB", probRows.length?probRows:[["‚Äî","‚Äî"]]);

  const sPress = sec("PRESS", b.press ? [
    ["GPI M(all)", String(b.press.GPI?.M_all ?? "‚Äî")],
    ["GPI M(l10)", String(b.press.GPI?.M_l10 ?? "‚Äî")],
    ["GMS H(all/l10)", `${b.press.GMS?.H_all ?? "‚Äî"} / ${b.press.GMS?.H_l10 ?? "‚Äî"}`],
    ["GMS A(all/l10)", `${b.press.GMS?.A_all ?? "‚Äî"} / ${b.press.GMS?.A_l10 ?? "‚Äî"}`],
    ["GMS M(all/l10)", `${b.press.GMS?.M_all ?? "‚Äî"} / ${b.press.GMS?.M_l10 ?? "‚Äî"}`],
    ["SI M(all/l10)", `${b.press.SI?.M_all ?? "‚Äî"} / ${b.press.SI?.M_l10 ?? "‚Äî"}`]
  ] : [["‚Äî","‚Äî"]]);

  const sLate = sec("LATE", b.late ? [
    ["AT", String(b.late.AT ?? "‚Äî")],
    ["L10", String(b.late.L10 ?? "‚Äî")],
    ["L5", String(b.late.L5 ?? "‚Äî")]
  ] : [["‚Äî","‚Äî"]]);

  const sOdds = sec("ODDS_TO_BET", b.odds_to_bet ? [
    ["Label", b.odds_to_bet.label ?? "‚Äî"],
    ["Phase", b.odds_to_bet.phase ?? "‚Äî"],
    ["Market", b.odds_to_bet.market ?? "‚Äî"],
    ["Line", String(b.odds_to_bet.line ?? "‚Äî")],
    ["Odds ref", String(b.odds_to_bet.odds_ref ?? "‚Äî")]
  ] : [["‚Äî","‚Äî"]]);

  const sLP = sec("LIVEPICK", [
    ["WR", b.lp?.WR===null ? "‚Äî" : (b.lp.WR*100).toFixed(2)+"%"],
    ["ROI", b.lp?.ROI===null ? "‚Äî" : (b.lp.ROI*100).toFixed(2)+"%"],
    ["Profit", String(b.lp?.Profit ?? "‚Äî")],
    ["AO", String(b.lp?.AO ?? "‚Äî")],
    ["N", String(b.lp?.N ?? "‚Äî")]
  ]);

  const sCalc = sec("CALC", [
    ["Fonte stake", b.calc?.stake_source || "‚Äî"],
    ["N arch", String(b.calc?.N_archive_at_bet ?? "‚Äî")],
    ["P_REF", b.calc?.P_REF===null ? "‚Äî" : (b.calc.P_REF*100).toFixed(2)+"%"],
    ["Implied", b.calc?.implied_prob===null ? "‚Äî" : (b.calc.implied_prob*100).toFixed(2)+"%"],
    ["Edge", b.calc?.edge===null ? "‚Äî" : (b.calc.edge*100).toFixed(2)+"%"],
    ["Stake% sugg", b.calc?.stake_suggested_pct===null ? "‚Äî" : (b.calc.stake_suggested_pct*100).toFixed(2)+"%"],
    ["Bankroll day", b.calc?.bankroll_day===null ? "‚Äî" : fmtMoney(b.calc.bankroll_day)],
    ["Needed goals (NEXT)", String(b.calc?.needed_goals ?? "‚Äî")]
  ]);

  box.innerHTML = `<div class="detailsList">${sMeta}${sState}${sStats}${sL10}${sProb}${sPress}${sLate}${sOdds}${sLP}${sCalc}</div>`;
}

/* =========================
   Backup / Restore + actions
========================= */
document.getElementById("btnClearHistory").addEventListener("click", ()=>{
  if(confirm("Svuotare lo storico?")){
    state.history=[];
    saveState();
    selectedBetId=null;
    editingBetId=null;
    document.getElementById("btnToggleRaw").disabled=true;
    document.getElementById("detailsBox").textContent="Seleziona ‚ÄúDettagli‚Äù su una bet.";
    renderAll();
  }
});
document.getElementById("btnRecalc").addEventListener("click", ()=>{
  recalcAll();
  document.getElementById("backupMsg").innerHTML = `<div class="okLine">Ricalcolo completato.</div>`;
});
document.getElementById("btnBackup").addEventListener("click", ()=>{
  const blob = new Blob([JSON.stringify(state,null,2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `bettools_backup_${todayISO()}.json`;
  document.body.appendChild(a);
  a.click(); a.remove();
  URL.revokeObjectURL(url);
  document.getElementById("backupMsg").innerHTML = `<div class="okLine">Backup creato.</div>`;
});
document.getElementById("restoreFile").addEventListener("change", async (e)=>{
  const file = e.target.files && e.target.files[0];
  if(!file) return;
  try{
    const text = await file.text();
    const incoming = JSON.parse(text);
    const replace = confirm("OK = Sostituisci tutto.\nAnnulla = Unisci (merge).");
    if(replace){
      state = incoming;
    }else{
      const cur = loadState();
      const merged = structuredClone(cur);
      merged.settings = incoming.settings || merged.settings;
      merged.dailySnapshot = incoming.dailySnapshot || merged.dailySnapshot;
      const incHist = Array.isArray(incoming.history) ? incoming.history : [];
      const ids = new Set((merged.history||[]).map(b=>b.id));
      for(const b of incHist){
        if(b && b.id && !ids.has(b.id)){
          merged.history.push(b);
          ids.add(b.id);
        }
      }
      state = merged;
    }
    saveState();
    renderAll();
    document.getElementById("backupMsg").innerHTML = `<div class="okLine">Restore completato.</div>`;
  }catch(err){
    document.getElementById("backupMsg").innerHTML = `<div class="errLine">Errore restore: file non valido.</div>`;
  }finally{
    document.getElementById("restoreFile").value="";
  }
});

/* =========================
   Dashboard
========================= */
let dashRange = "all";
let profitRange = "1m";

document.getElementById("dashRangeSelect").addEventListener("change",(e)=>{
  dashRange = e.target.value;
  renderDashboard();
});
document.getElementById("profitRangeSelect").addEventListener("change",(e)=>{
  profitRange = e.target.value;
  renderDashboard();
});

document.getElementById("btnSaveBR").addEventListener("click", ()=>{
  const v = Number(document.getElementById("bankrollInputDash").value||0);
  state.settings.bankroll = v;
  saveState();
  syncBankrollInputs();
  document.getElementById("dashMsg").innerHTML = `<div class="okLine">Bankroll salvato: ${fmtMoney(v)}</div>`;
});
document.getElementById("btnNewDay").addEventListener("click", ()=>{
  if(confirm("Reset snapshot giornaliero?")){
    state.dailySnapshot.date=null;
    state.dailySnapshot.bankroll=null;
    saveState();
    renderAll();
  }
});

function closedBetsFiltered(range){
  return state.history.filter(b=> (b.result==="win" || b.result==="loss") && inDateRange(b.date, range));
}
function computeTotalsRange(range){
  const closed = closedBetsFiltered(range);
  const profit = sum(closed.map(b=>b.profit_real));
  const stakeTot = sum(closed.map(b=>Number(b.execution.stake_played)||0));
  const roi = stakeTot>0 ? (profit/stakeTot) : null;
  const wins = closed.filter(b=>b.result==="win").length;
  const losses = closed.filter(b=>b.result==="loss").length;
  const winrate = closed.length>0 ? wins/closed.length : null;
  return {closedCount:closed.length, wins, losses, profit, stakeTot, roi, winrate, closed};
}
function computeDrawdownFromClosed(closed){
  const sorted = closed.slice().sort((a,b)=> a.date<b.date ? -1 : (a.date>b.date ? 1 : 0));
  let eq=0, peak=0, maxDD=0;
  for(const b of sorted){
    eq += Number(b.profit_real)||0;
    if(eq>peak) peak=eq;
    const dd=peak-eq;
    if(dd>maxDD) maxDD=dd;
  }
  return {maxDD, eqEnd:eq};
}
function computeStreaksFromClosed(closed){
  const sorted = closed.slice().sort((a,b)=> a.date<b.date ? -1 : (a.date>b.date ? 1 : 0));
  let curW=0,curL=0,maxW=0,maxL=0;
  for(const b of sorted){
    if(b.result==="win"){curW++;curL=0;} else {curL++;curW=0;}
    if(curW>maxW) maxW=curW;
    if(curL>maxL) maxL=curL;
  }
  return {maxW,maxL};
}

function drawDonut(wins, losses){
  const c = document.getElementById("donut");
  const ctx = c.getContext("2d");
  const W=c.width, H=c.height;
  ctx.clearRect(0,0,W,H);

  const total = wins+losses;
  const winPct = total>0 ? wins/total : 0;
  const lossPct = total>0 ? losses/total : 0;

  const cx=W/2, cy=H/2, r=Math.min(W,H)*0.28;
  const thickness=r*0.45;

  function arc(pct, start, color){
    const end = start + pct*Math.PI*2;
    ctx.beginPath();
    ctx.strokeStyle=color;
    ctx.lineWidth=thickness;
    ctx.lineCap="butt";
    ctx.arc(cx, cy, r, start, end);
    ctx.stroke();
    return end;
  }

  ctx.beginPath();
  ctx.strokeStyle="rgba(255,255,255,.08)";
  ctx.lineWidth=thickness;
  ctx.arc(cx, cy, r, 0, Math.PI*2);
  ctx.stroke();

  const good="rgba(25,195,125,.95)";
  const bad="rgba(255,77,79,.95)";
  let a=-Math.PI/2;
  a = arc(winPct, a, good);
  arc(lossPct, a, bad);

  ctx.fillStyle="rgba(232,238,252,.92)";
  ctx.font="700 22px "+getComputedStyle(document.body).fontFamily;
  const wr = total>0 ? Math.round(winPct*100) : 0;
  ctx.textAlign="center";
  ctx.fillText(`${wr}%`, cx, cy+8);
  ctx.font="600 12px "+getComputedStyle(document.body).fontFamily;
  ctx.fillStyle="rgba(159,176,208,.95)";
  ctx.fillText("Win Rate", cx, cy+28);

  document.getElementById("wonLabel").innerHTML = `Won: <b>${Math.round(winPct*100)}%</b>`;
  document.getElementById("lostLabel").innerHTML = `Lost: <b>${Math.round(lossPct*100)}%</b>`;
}

function drawProfitChart(closed, mode){
  const c = document.getElementById("profitChart");
  const ctx = c.getContext("2d");
  const W=c.width, H=c.height;
  ctx.clearRect(0,0,W,H);

  let data = closed.slice().sort((a,b)=> a.date<b.date ? -1 : (a.date>b.date ? 1 : 0));
  if(mode==="1m") data = data.filter(b=>inMonthsBack(b.date,1));
  if(mode==="6m") data = data.filter(b=>inMonthsBack(b.date,6));
  if(mode==="12m") data = data.filter(b=>inMonthsBack(b.date,12));

  let eq=0;
  const pts = data.map(b=> (eq += Number(b.profit_real)||0));
  if(pts.length===0){
    ctx.strokeStyle="rgba(255,255,255,.10)";
    ctx.strokeRect(40,20,W-60,H-50);
    ctx.fillStyle="rgba(159,176,208,.95)";
    ctx.font="600 12px "+getComputedStyle(document.body).fontFamily;
    ctx.fillText("Nessun dato nel periodo", 50, 40);
    return;
  }

  const minY = Math.min(...pts);
  const maxY = Math.max(...pts);
  const pad = (maxY-minY)*0.12 || 1;
  const y0 = minY - pad;
  const y1 = maxY + pad;

  const left=40, top=20, right=W-20, bottom=H-30;
  const plotW = right-left;
  const plotH = bottom-top;

  const xAt = (i)=> left + (pts.length===1 ? plotW/2 : (i/(pts.length-1))*plotW);
  const yAt = (v)=> top + (1-(v-y0)/(y1-y0))*plotH;

  ctx.strokeStyle="rgba(255,255,255,.08)";
  ctx.strokeRect(left, top, plotW, plotH);

  const final = pts[pts.length-1];
  const isPos = final >= 0;
  const fill = isPos ? "rgba(25,195,125,.12)" : "rgba(255,77,79,.12)";
  const line = isPos ? "rgba(25,195,125,.85)" : "rgba(255,77,79,.85)";
  const dot = isPos ? "rgba(25,195,125,.95)" : "rgba(255,77,79,.95)";

  ctx.beginPath();
  ctx.moveTo(left, bottom);
  for(let i=0;i<pts.length;i++){
    ctx.lineTo(xAt(i), yAt(pts[i]));
  }
  ctx.lineTo(right, bottom);
  ctx.closePath();
  ctx.fillStyle = fill;
  ctx.fill();

  ctx.beginPath();
  for(let i=0;i<pts.length;i++){
    const x=xAt(i), y=yAt(pts[i]);
    if(i===0) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  }
  ctx.strokeStyle=line;
  ctx.lineWidth=2;
  ctx.stroke();

  ctx.fillStyle=dot;
  for(let i=0;i<pts.length;i++){
    const x=xAt(i), y=yAt(pts[i]);
    ctx.beginPath();
    ctx.arc(x,y,3,0,Math.PI*2);
    ctx.fill();
  }

  ctx.fillStyle="rgba(159,176,208,.95)";
  ctx.font="600 11px "+getComputedStyle(document.body).fontFamily;
  ctx.textAlign="right";
  ctx.fillText(`Cumulato: ${final.toFixed(2)}`, right, top-6);
}

function renderDashboard(){
  const t = computeTotalsRange(dashRange);
  const dd = computeDrawdownFromClosed(t.closed);
  const st = computeStreaksFromClosed(t.closed);

  const kpis=document.getElementById("dashKpis");
  kpis.innerHTML = `
    <div class="kpi"><span>Bet chiuse</span><b>${t.closedCount}</b></div>
    <div class="kpi"><span>Winrate</span><b>${t.winrate===null ? "‚Äî" : fmtPct(t.winrate)}</b></div>
    <div class="kpi"><span>Profitto</span><b class="${t.profit>=0?'good':'bad'}">${fmtMoney(t.profit)}</b></div>
    <div class="kpi"><span>ROI</span><b class="${(t.roi!==null && t.roi>=0)?'good':'bad'}">${t.roi===null?"‚Äî":fmtPct(t.roi)}</b></div>
  `;
  document.getElementById("dashMaxDD").textContent = fmtMoney(dd.maxDD);
  document.getElementById("dashStreak").textContent = `${st.maxW} / ${st.maxL}`;

  drawDonut(t.wins, t.losses);
  drawProfitChart(t.closed, profitRange);
}

/* =========================
   Riepilogo temporale
========================= */
document.getElementById("timeGroupSelect").addEventListener("change",(e)=>{
  timeGroup = e.target.value;
  renderTimeSummary();
});
let timeGroup="day";

function periodKey(dateISO, mode){
  if(mode==="day") return dateISO;
  if(mode==="week") return startOfWeekISO(dateISO);
  if(mode==="month") return monthKey(dateISO);
  return dateISO;
}
function periodLabel(key, mode){
  if(mode==="day") return key;
  if(mode==="week") return `Week ${key}`;
  if(mode==="month") return key;
  return key;
}
function dayStatusFromROC(roc){
  if(roc===null) return {label:"", cls:""};
  if(roc>=0.03) return {label:"Target", cls:"badge win"};
  if(roc<=-0.10) return {label:"Stop", cls:"badge loss"};
  return {label:"", cls:""};
}

function renderTimeSummary(){
  const empty=document.getElementById("timeEmpty");
  const table=document.getElementById("timeTable");
  const body=document.getElementById("timeBody");

  const closed = state.history.filter(b=>b.result==="win"||b.result==="loss");
  if(closed.length===0){
    empty.textContent="Nessuna bet chiusa: riepilogo non disponibile.";
    table.style.display="none";
    body.innerHTML="";
    return;
  }
  empty.textContent="";
  table.style.display="";
  body.innerHTML="";

  const map=new Map();
  for(const b of closed){
    const key=periodKey(b.date, timeGroup);
    if(!map.has(key)) map.set(key,{key,bets:0,wins:0,losses:0,stake:0,profit:0, brDay:null, dayKey:null});
    const o=map.get(key);
    o.bets++;
    if(b.result==="win") o.wins++; else o.losses++;
    o.stake += Number(b.execution.stake_played)||0;
    o.profit += Number(b.profit_real)||0;

    if(timeGroup==="day"){
      if(o.brDay===null){
        o.dayKey = b.date;
        o.brDay = getStartBankrollForDate(b.date);
      }
    }
  }

  const rows=[...map.values()].sort((a,b)=> a.key<b.key ? 1 : -1);
  for(const r of rows){
    const closedN=r.wins+r.losses;
    const wr=closedN>0 ? r.wins/closedN : null;
    const roi=r.stake>0 ? r.profit/r.stake : null;
    const roc = (timeGroup==="day" && r.brDay && r.brDay>0) ? (r.profit/r.brDay) : null;
    const status = (timeGroup==="day") ? dayStatusFromROC(roc) : {label:"", cls:""};

    const profitCls = r.profit>=0 ? "badge win" : "badge loss";
    const roiCls = (roi!==null && roi>=0) ? "badge win" : "badge loss";
    const rocCls = (roc!==null && roc>=0) ? "badge win" : (roc!==null ? "badge loss" : "badge neutral");

    const tr=document.createElement("tr");
    tr.innerHTML = `
      <td class="mono">${escapeHtml(periodLabel(r.key,timeGroup))}</td>
      <td>${r.bets}</td>
      <td class="mono">${wr===null?"‚Äî":fmtPct(wr)}</td>
      <td><span class="${profitCls}">${escapeHtml(fmtMoney(r.profit))}</span></td>
      <td><span class="${roiCls}">${roi===null?"‚Äî":escapeHtml(fmtPct(roi))}</span></td>
      <td><span class="${rocCls}">${roc===null?"‚Äî":escapeHtml(fmtPct(roc))}</span></td>
      <td>${status.label ? `<span class="${status.cls}">${escapeHtml(status.label)}</span>` : ""}</td>
    `;
    body.appendChild(tr);
  }
}

/* =========================
   Riepilogo filtri
========================= */
document.getElementById("filterSort").addEventListener("change", renderFilters);

function renderFilters(){
  const grid=document.getElementById("filtersGrid");
  const sort=document.getElementById("filterSort").value;

  const groups=new Map();
  for(const b of state.history){
    const name = `${b.meta?.Method || "‚Äî"} ‚Ä¢ ${formatPick(b)}`;
    if(!groups.has(name)){
      groups.set(name, {
        name, bets:0, wins:0, losses:0,
        stake:0, profit:0,
        oddsSum:0, oddsN:0,
        lastLP: null, lastDate: null
      });
    }
    const g=groups.get(name);
    g.bets++;

    if(!g.lastDate || b.date >= g.lastDate){
      g.lastDate = b.date;
      g.lastLP = b.lp || null;
    }

    const o = (b.execution?.odds_played ?? b.execution?.odds_ref);
    if(o && Number(o)>1){ g.oddsSum += Number(o); g.oddsN++; }

    if(b.result==="win"||b.result==="loss"){
      g.stake += Number(b.execution.stake_played)||0;
      g.profit += Number(b.profit_real)||0;
      if(b.result==="win") g.wins++; else g.losses++;
    }
  }

  let arr=[...groups.values()].map(g=>{
    const closedN=g.wins+g.losses;
    const winrate = closedN>0 ? g.wins/closedN : null;
    const roi = g.stake>0 ? g.profit/g.stake : null;
    const avgOdds = g.oddsN>0 ? g.oddsSum/g.oddsN : null;
    const lp = g.lastLP;
    const lpWR = lp?.WR ?? null;
    const lpROI = lp?.ROI ?? null;
    const lpProfit = (lp?.Profit ?? null);
    return {...g, closedN, winrate, roi, avgOdds, lpWR, lpROI, lpProfit};
  });

  arr.sort((a,b)=>{
    const va = (sort==="roi") ? (a.roi ?? -1e9)
      : (sort==="profit") ? a.profit
      : (sort==="winrate") ? (a.winrate ?? -1e9)
      : (sort==="bets") ? a.bets
      : a.name.localeCompare(b.name);
    const vb = (sort==="roi") ? (b.roi ?? -1e9)
      : (sort==="profit") ? b.profit
      : (sort==="winrate") ? (b.winrate ?? -1e9)
      : (sort==="bets") ? b.bets
      : 0;
    if(sort==="name") return va;
    return vb - va;
  });

  grid.innerHTML="";
  if(arr.length===0){
    grid.innerHTML = `<div class="card"><div class="help">Nessun dato.</div></div>`;
    return;
  }

  const compLine = (label, val, lpVal, delta, isPct=true)=>{
    const v = val===null ? "‚Äî" : (isPct ? fmtPct(val) : fmtMoney(val));
    const lpS = lpVal===null ? "" : ` (LP ${isPct?fmtPct(lpVal):fmtMoney(lpVal)})`;
    const dS = delta===null ? "" : ` ‚Ä¢ Œî ${isPct?fmtPct(delta):fmtMoney(delta)}`;
    return `<div class="help">${escapeHtml(label)}: <b>${escapeHtml(v)}</b>${escapeHtml(lpS)}${escapeHtml(dS)}</div>`;
  };

  for(const g of arr){
    const roiStr = g.roi===null ? "‚Äî" : fmtPct(g.roi);
    const roiCls = (g.roi!==null && g.roi>=0) ? "badge win" : "badge loss";
    const profitCls = g.profit>=0 ? "good" : "bad";

    const wrDelta = (g.winrate!==null && g.lpWR!==null) ? (g.winrate - g.lpWR) : null;
    const roiDelta = (g.roi!==null && g.lpROI!==null) ? (g.roi - g.lpROI) : null;
    const lpProfitNum = (g.lpProfit===null || g.lpProfit===undefined) ? null : Number(g.lpProfit);
    const pDelta = (lpProfitNum!==null) ? (g.profit - lpProfitNum) : null;

    const card=document.createElement("div");
    card.className="card";
    card.innerHTML = `
      <div class="cardHeader">
        <div>
          <b>${escapeHtml(g.name)}</b><br/>
          <small>${g.bets} bet</small>
        </div>
        <div class="${roiCls}">${g.roi===null?"ROI ‚Äî":"ROI "+roiStr}</div>
      </div>

      <div class="row">
        <span class="badge">Vinte: <b>${g.winrate===null?"‚Äî":fmtPct(g.winrate)}</b></span>
        <span class="badge">Quota media: <b class="mono">${g.avgOdds===null?"‚Äî":g.avgOdds.toFixed(2)}</b></span>
        <span class="badge">Profitto: <b class="${profitCls} mono">${fmtMoney(g.profit)}</b></span>
      </div>

      <div style="margin-top:8px">
        ${compLine("% Vinte", g.winrate, g.lpWR, wrDelta, true)}
        ${compLine("ROI", g.roi, g.lpROI, roiDelta, true)}
        ${compLine("Profit", g.profit, lpProfitNum, pDelta, false)}
      </div>
    `;
    grid.appendChild(card);
  }
}

/* =========================
   Daily UI refresh
========================= */
function renderAll(){
  syncBankrollInputs();
  renderDailyBanner();
  updateDailyPill();
  renderHistory();
  renderDashboard();
  renderTimeSummary();
  renderFilters();
}
renderAll();
document.getElementById("btnToggleRaw").disabled = true;

/* =========================
   Small page-specific refresh
========================= */
function openTo(page){ setPage(page); }
  </script>
</body>
</html>

