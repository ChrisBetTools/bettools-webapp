<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>LivePick iOS26 ‚Äî v1.7</title>
  <style>
    :root{
      --bg:#0b0f19;
      --card:#101a2b;
      --card2:#0f1626;
      --muted:#8aa0c2;
      --text:#e8f0ff;
      --line:rgba(255,255,255,.08);
      --accent:#4aa3ff;
      --accent2:#7c5cff;
      --good:#35d07f;
      --bad:#ff5d5d;
      --warn:#ffcc66;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:16px;
      --radius2:22px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: -apple-system, BlinkMacSystemFont, "SF Pro Display","SF Pro Text","Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }

    html,body{ height:100%; }
    body{
      margin:0;
      background: radial-gradient(1200px 900px at 20% -10%, rgba(124,92,255,.15), transparent 55%),
                  radial-gradient(1000px 700px at 110% 10%, rgba(74,163,255,.15), transparent 55%),
                  var(--bg);
      color:var(--text);
      font-family:var(--sans);
      -webkit-font-smoothing: antialiased;
      overflow-x:hidden;
    }

    .app{
      display:flex;
      flex-direction:column;
      min-height:100vh;
      padding-bottom: env(safe-area-inset-bottom);
    }

    .topbar{
      position:sticky;
      top:0;
      z-index:50;
      padding: 14px 14px 10px 14px;
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
      background: linear-gradient(to bottom, rgba(11,15,25,.88), rgba(11,15,25,.65));
      border-bottom:1px solid var(--line);
    }

    .toprow{
      display:flex;
      align-items:center;
      gap:10px;
    }

    .hamb{
      width:42px;height:42px;border-radius:14px;
      display:grid;place-items:center;
      background: rgba(255,255,255,.06);
      border:1px solid var(--line);
      box-shadow: var(--shadow);
      cursor:pointer;
      user-select:none;
    }
    .hamb:active{ transform:scale(.98); }

    .brand{
      display:flex;flex-direction:column;gap:2px;
      margin-right:auto;
    }
    .brand b{
      font-size:15px;
      letter-spacing:.2px;
    }
    .brand small{
      color:var(--muted);
      font-size:12px;
    }

    .pill{
      padding:8px 12px;
      border-radius:999px;
      background: rgba(255,255,255,.06);
      border:1px solid var(--line);
      color:var(--text);
      font-size:12px;
      display:flex;
      align-items:center;
      gap:8px;
      box-shadow: var(--shadow);
      white-space:nowrap;
    }
    .pill .dot{
      width:8px;height:8px;border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 0 4px rgba(74,163,255,.12);
    }

    .drawer{
      position:fixed;
      inset:0;
      z-index:80;
      display:none;
    }
    .drawer.open{ display:block; }
    .drawer .backdrop{
      position:absolute; inset:0;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(6px);
    }
    .drawer .panel{
      position:absolute;
      top:0; left:0;
      width:min(320px, 86vw);
      height:100%;
      background: linear-gradient(180deg, rgba(16,26,43,.98), rgba(16,26,43,.92));
      border-right:1px solid var(--line);
      box-shadow: var(--shadow);
      padding: 18px 14px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .menuTitle{
      display:flex;align-items:center;justify-content:space-between;
      margin-bottom:4px;
    }
    .menuTitle b{ font-size:15px; }
    .menuTitle small{ color:var(--muted); font-size:12px; }

    .navbtn{
      display:flex; align-items:center; gap:10px;
      padding: 12px 12px;
      border-radius: 14px;
      background: rgba(255,255,255,.04);
      border:1px solid var(--line);
      cursor:pointer;
      user-select:none;
    }
    .navbtn.active{
      background: rgba(74,163,255,.14);
      border-color: rgba(74,163,255,.35);
    }
    .navbtn .ic{
      width:30px; height:30px; border-radius:12px;
      display:grid;place-items:center;
      background: rgba(255,255,255,.06);
      border:1px solid var(--line);
      font-size:16px;
    }
    .navbtn .txt{ display:flex; flex-direction:column; gap:2px; }
    .navbtn .txt b{ font-size:13px; }
    .navbtn .txt small{ font-size:12px; color:var(--muted); }

    main{
      flex:1;
      padding: 14px;
      max-width: 920px;
      margin: 0 auto;
      width:100%;
      box-sizing:border-box;
    }

    .page{ display:none; }
    .page.active{ display:block; }

    .card{
      background: linear-gradient(180deg, rgba(16,26,43,.86), rgba(15,22,38,.86));
      border: 1px solid var(--line);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      padding: 14px;
    }

    .card h2{
      margin:0 0 10px 0;
      font-size:15px;
      letter-spacing:.2px;
    }

    .row{ display:flex; align-items:center; gap:10px; }
    .row.wrap{ flex-wrap:wrap; }

    .help{ color:var(--muted); font-size:12px; line-height:1.35; }
    .mono{ font-family: var(--mono); }

    textarea, input, select{
      width:100%;
      box-sizing:border-box;
      background: rgba(255,255,255,.04);
      border:1px solid var(--line);
      border-radius: 14px;
      padding: 12px;
      color:var(--text);
      font-size:14px;
      outline:none;
      font-family: var(--sans);
    }
    textarea{ resize: vertical; min-height: 180px; }
    input[type="date"]{ color-scheme: dark; }

    .btn{
      padding: 11px 12px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.06);
      color:var(--text);
      cursor:pointer;
      user-select:none;
      font-size:13px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
    }
    .btn.primary{
      background: linear-gradient(135deg, rgba(74,163,255,.9), rgba(124,92,255,.88));
      border-color: rgba(124,92,255,.35);
    }
    .btn.danger{
      background: rgba(255,93,93,.12);
      border-color: rgba(255,93,93,.35);
    }
    .btn:active{ transform: scale(.99); }

    .kpi{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .kpi .box{
      background: rgba(255,255,255,.04);
      border:1px solid var(--line);
      border-radius: 16px;
      padding: 12px;
    }
    .kpi .box b{ font-size:13px; }
    .kpi .box .v{ font-size:18px; margin-top:4px; }
    .kpi .box .s{ font-size:12px; color:var(--muted); margin-top:2px; }

    .pillMini{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.05);
      font-size:12px;
      color:var(--text);
      white-space:nowrap;
    }

    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }

    .list{ display:flex; flex-direction:column; gap:10px; }

    .bet{
      border-radius: var(--radius2);
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      padding: 12px;
    }
    .betTop{
      display:flex; align-items:flex-start; gap:10px;
    }
    .betTop .left{ flex:1; min-width:0; }
    .betTop .left b{ font-size:13px; }
    .betTop .left .sub{ margin-top:3px; color:var(--muted); font-size:12px; }
    .betTop .right{ display:flex; gap:8px; align-items:center; }
    .tag{
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.05);
      font-size:12px;
    }
    .tag.win{ border-color: rgba(53,208,127,.35); background: rgba(53,208,127,.10); }
    .tag.loss{ border-color: rgba(255,93,93,.35); background: rgba(255,93,93,.10); }
    .tag.pending{ border-color: rgba(255,204,102,.35); background: rgba(255,204,102,.10); }
    .tag.noplay{ border-color: rgba(138,160,194,.35); background: rgba(138,160,194,.10); }

    .betBody{
      margin-top:10px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }

    .kv{
      border:1px solid var(--line);
      background: rgba(0,0,0,.10);
      border-radius: 14px;
      padding: 10px;
    }
    .kv small{ color:var(--muted); display:block; font-size:12px; }
    .kv b{ font-size:14px; }

    details.card{ padding: 12px 14px; }
    details.card summary{ cursor:pointer; }
    details.card[open]{ outline:none; }

    table{
      width:100%;
      border-collapse: collapse;
      font-size:12px;
    }
    th, td{
      padding: 10px 8px;
      border-bottom: 1px solid var(--line);
      text-align:left;
      vertical-align: top;
    }
    th{ color:var(--muted); font-weight:600; }
    tr:last-child td{ border-bottom:none; }

    canvas{ width:100% !important; height:190px !important; }

    @media (max-width:420px){
      main{ padding: 12px; }
      .kpi{ grid-template-columns: 1fr 1fr; }
      canvas{ height:170px !important; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="topbar">
      <div class="toprow">
        <div class="hamb" id="btnHamb" aria-label="Menu">‚ò∞</div>

        <div class="brand">
          <b>LivePick iOS26</b>
          <small>UI v1.7 ‚Ä¢ mobile-first</small>
        </div>

        <div class="pill" id="dayPill"><span class="dot"></span><span id="dayPillTxt">Giornata: ‚Äî</span></div>
      </div>
    </header>

    <div class="drawer" id="drawer">
      <div class="backdrop" id="drawerBackdrop"></div>
      <div class="panel">
        <div class="menuTitle">
          <b>Menu</b>
          <small class="mono">v1.7</small>
        </div>

        <div class="navbtn active" data-page="calc">
          <div class="ic">üßÆ</div>
          <div class="txt"><b>Calcolatori</b><small>parse + EV + stake</small></div>
        </div>

        <div class="navbtn" data-page="storico">
          <div class="ic">üìú</div>
          <div class="txt"><b>Storico</b><small>pending / win / loss</small></div>
        </div>

        <div class="navbtn" data-page="dashboard">
          <div class="ic">üìä</div>
          <div class="txt"><b>Dashboard</b><small>profit / ROI / WR</small></div>
        </div>

        <div class="navbtn" data-page="time">
          <div class="ic">üïí</div>
          <div class="txt"><b>Riepilogo temporale</b><small>giorno/mese/trimestre</small></div>
        </div>

        <div class="navbtn" data-page="filters">
          <div class="ic">üß©</div>
          <div class="txt"><b>Riepilogo filtri</b><small>per Method</small></div>
        </div>

        <div style="margin-top:auto" class="help">
          Suggerimento: incolla una notifica in <b>Calcolatori</b> e premi <b>Parse</b>.
        </div>
      </div>
    </div>

    <main>
      <!-- CALC -->
      <section class="page active" id="page-calc">
        <div class="card">
          <h2>Risultato giornata</h2>
          <div class="kpi">
            <div class="box">
              <b>Bankroll giorno</b>
              <div class="v mono" id="kpiDayBR">‚Äî</div>
              <div class="s">base calcoli (si fissa alla 1¬™ bet del giorno)</div>
            </div>
            <div class="box">
              <b>ROC oggi</b>
              <div class="v mono" id="kpiDayROC">‚Äî</div>
              <div class="s" id="kpiStopTxt">‚Äî</div>
            </div>
          </div>
        </div>

        <div style="height:12px"></div>

        <div class="card">
          <h2>Notifica LivePick</h2>
          <textarea id="notifText" placeholder="Incolla qui la notifica..."></textarea>
          <div class="row" style="margin-top:10px">
            <button class="btn primary" id="btnParse">Parse</button>
            <button class="btn" id="btnClear">Pulisci</button>
            <span class="help" id="parseHint" style="margin-left:auto"></span>
          </div>
          <div id="parseMsg" class="help" style="margin-top:10px"></div>

          <details class="card" style="margin-top:10px">
            <summary><b>Modello NB (runtime_models.json)</b> <span class="help">(opzionale)</span></summary>
            <div class="help" style="margin-top:8px">Incolla qui il contenuto di <span class="mono">runtime_models.json</span> generato dallo script 02. Se vuoto, uso una stima da stats.</div>
            <textarea id="runtimeModelsText" spellcheck="false" placeholder='{"ft":{...},"ht":{...}}' style="min-height:140px; margin-top:8px"></textarea>
            <div class="row" style="margin-top:10px">
              <button class="btn" id="btnSaveRuntime">Salva modello</button>
              <button class="btn danger" id="btnClearRuntime">Rimuovi modello</button>
              <span class="help" id="runtimeStatus" style="margin-left:auto"></span>
            </div>
          </details>

          <!-- ACTION BLOCK -->
          <div id="actionWrap" style="margin-top:12px"></div>
        </div>

        <div style="height:12px"></div>

        <div class="card">
          <h2>Bankroll</h2>
          <div class="grid2">
            <div>
              <div class="help">Bankroll attuale (aggiornato a bet chiuse)</div>
              <input id="bankrollCurrent" type="number" step="0.01" min="0" />
            </div>
            <div>
              <div class="help">Bankroll giorno (si fissa alla 1¬™ bet del giorno)</div>
              <input id="bankrollDay" type="number" step="0.01" min="0" />
            </div>
          </div>
          <div class="row" style="margin-top:10px">
            <button class="btn" id="btnResetDay">Nuovo giorno</button>
            <span class="help" style="margin-left:auto">Target profit: <b>+3%</b> ROC ‚Ä¢ Stop loss: <b>-10%</b> ROC</span>
          </div>
        </div>
      </section>
      <!-- STORICO -->
      <section class="page" id="page-storico">
        <div class="card">
          <h2>Storico</h2>
          <div class="row wrap">
            <select id="historyResultFilter" style="width:auto; min-width:190px">
              <option value="all">Tutti gli stati</option>
              <option value="pending">Pending</option>
              <option value="win">Vinte</option>
              <option value="loss">Perse</option>
              <option value="not_played">Non giocate</option>
            </select>
            <input id="historyDateFilter" type="date" style="width:auto; min-width:160px" />
            <input id="historySearch" type="text" placeholder="Cerca match / method..." style="flex:1; min-width:200px" />
          </div>

          <div class="row" style="margin-top:12px; gap:10px">
            <button class="btn" id="btnManualAdd">Aggiungi manuale</button>
            <button class="btn" id="btnExportHistory">Esporta JSON</button>
            <label class="btn" style="display:inline-flex; align-items:center; gap:8px">
              Importa JSON <input id="fileImportHistory" type="file" accept="application/json" style="display:none"/>
            </label>
          </div>

          <div id="manualAddWrap" class="card" style="display:none; margin-top:12px">
            <div class="row" style="gap:10px; flex-wrap:wrap">
              <input id="manDate" type="date" style="width:auto; min-width:140px"/>
              <input id="manMatch" type="text" placeholder="Partita (Home-Away)" style="flex:1; min-width:220px"/>
            </div>
            <div class="row" style="gap:10px; margin-top:10px; flex-wrap:wrap">
              <input id="manMethod" type="text" placeholder="Metodo / Filtro" style="flex:1; min-width:220px"/>
              <select id="manPhase" style="width:auto; min-width:110px">
                <option value="FT">FT</option>
                <option value="HT">HT</option>
              </select>
              <input id="manLine" type="number" step="0.5" min="0.5" placeholder="Line" style="width:110px"/>
            </div>
            <div class="row" style="gap:10px; margin-top:10px; flex-wrap:wrap">
              <input id="manOdds" type="number" step="0.01" min="1" placeholder="Quota" style="width:120px"/>
              <input id="manStake" type="number" step="0.1" min="1" placeholder="Stake" style="width:120px"/>
              <select id="manResult" style="width:auto; min-width:160px">
                <option value="pending">Pending</option>
                <option value="win">Vinta</option>
                <option value="loss">Persa</option>
                <option value="not_played">Non giocata</option>
              </select>
              <button class="btn primary" id="btnManualSave">Salva</button>
              <button class="btn" id="btnManualCancel">Annulla</button>
            </div>
            <div class="help" style="margin-top:8px">Nota: le bet <b>pending</b> / <b>non giocate</b> non entrano in dashboard/statistiche.</div>
          </div>

          <div id="historyList" class="list" style="margin-top:12px"></div>
        </div>
      </section>

      <!-- DASHBOARD -->
      <section class="page" id="page-dashboard">
        <div class="card">
          <h2>Dashboard</h2>
          <div class="kpi" id="dashKpi"></div>
          <div style="height:12px"></div>
          <div class="grid2">
            <div class="card">
              <h2>Winrate</h2>
              <canvas id="donutCanvas"></canvas>
            </div>
            <div class="card">
              <h2>Profit</h2>
              <canvas id="profitCanvas"></canvas>
            </div>
          </div>
        </div>
      </section>

      <!-- TIME -->
      <section class="page" id="page-time">
        <div class="card">
          <h2>Riepilogo temporale</h2>
          <div class="row wrap">
            <select id="timeGroupSelect" style="width:auto; min-width:220px">
              <option value="day">Giorno</option>
              <option value="month">Mese</option>
              <option value="quarter">Trimestre</option>
            </select>
            <span class="help">Profit/ROI calcolati solo su bet chiuse (win/loss). Pending mostrati a parte.</span>
          </div>
          <div id="timeBody" style="margin-top:12px"></div>
        </div>
      </section>

      <!-- FILTERS -->
      <section class="page" id="page-filters">
        <div class="card">
          <h2>Riepilogo filtri (per Method)</h2>
          <div class="help">Raggruppamento basato solo su <b>Method</b>. I dettagli includono confronto con gli ultimi valori LP salvati.</div>
          <div style="height:12px"></div>
          <div id="filtersList" class="list"></div>
        </div>
      </section>
    </main>
  </div>

  <div id="toast" style="position:fixed; left:14px; right:14px; bottom:calc(14px + env(safe-area-inset-bottom)); z-index:200; display:none">
    <div class="card" style="padding:12px 14px; text-align:center" id="toastTxt">‚Äî</div>
  </div>
  <script>
    // -------------------------------
    // Helpers
    // -------------------------------
    function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
    function safeNum(v){
      if(v===null || v===undefined) return null;
      const s = String(v).trim();
      if(!s || s==="-" ) return null;
      const n = Number(s.replace(",", "."));
      return Number.isFinite(n) ? n : null;
    }
    function pct(x){
      if(x===null || x===undefined || !isFinite(x)) return "‚Äî";
      return (x*100).toFixed(1)+"%";
    }
    function fmtEuro(x){
      if(x===null || x===undefined || !isFinite(x)) return "‚Äî";
      const sign = x<0 ? "-" : "";
      const a = Math.abs(x);
      return sign + a.toFixed(2) + "‚Ç¨";
    }
    function escapeHtml(s){
      return String(s??"").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
    }
    function uuid(){
      return (crypto && crypto.randomUUID) ? crypto.randomUUID() : (Date.now()+"_"+Math.random().toString(16).slice(2));
    }
    function toast(msg){
      const t=document.getElementById("toast");
      const tx=document.getElementById("toastTxt");
      tx.textContent = msg;
      t.style.display="block";
      setTimeout(()=>t.style.display="none", 1700);
    }
    function roundStake1decMin1(x){
      const n = safeNum(x);
      if(n===null) return null;
      const r = Math.round(n*10)/10;
      return Math.max(1, r);
    }
    function calcProfit(result, stake, odds){
      if(result==="win") return stake*(odds-1);
      if(result==="loss") return -stake;
      return 0;
    }

    // -------------------------------
    // State + Storage
    // -------------------------------
    const STORAGE_KEY = "LP_IOS26_STATE_V17";

    const defaultState = {
      bankroll_current: 100.00,
      bankroll_day: 100.00,
      day_anchor_date: null,   // YYYY-MM-DD
      history: [],
      lastMethod: ""
    };

    let state = loadState();

    function loadState(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if(!raw) return {...defaultState};
        const obj = JSON.parse(raw);
        return {...defaultState, ...obj};
      }catch(e){
        return {...defaultState};
      }
    }

    function saveState(){
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }

    // -------------------------------
    // Navigation / Drawer
    // -------------------------------
    const drawer=document.getElementById("drawer");
    const btnHamb=document.getElementById("btnHamb");
    const drawerBackdrop=document.getElementById("drawerBackdrop");
    const navBtns=[...document.querySelectorAll(".navbtn")];

    function openDrawer(){ drawer.classList.add("open"); }
    function closeDrawer(){ drawer.classList.remove("open"); }

    btnHamb.addEventListener("click", openDrawer);
    drawerBackdrop.addEventListener("click", closeDrawer);

    navBtns.forEach(b=>{
      b.addEventListener("click", ()=>{
        navBtns.forEach(x=>x.classList.remove("active"));
        b.classList.add("active");
        const page=b.getAttribute("data-page");
        setActivePage(page);
        closeDrawer();
      });
    });

    function setActivePage(page){
      document.querySelectorAll(".page").forEach(p=>p.classList.remove("active"));
      const el=document.getElementById("page-"+page);
      if(el) el.classList.add("active");
      renderAll();
    }

    // -------------------------------
    // Parse notification
    // -------------------------------
    function splitBlocks(text){
      const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
      const blocks = {};
      let current = null;
      for(const line of lines){
        const m = line.match(/^([A-Z0-9_]+)\s*\|\s*(.*)$/);
        if(m){
          current = m[1];
          blocks[current] = blocks[current] ? (blocks[current]+"\n"+line) : line;
        }else if(current){
          blocks[current] += "\n"+line;
        }
      }
      return blocks;
    }

    function parseMETA(block){
      // META | Ver=V3 | Method=CHATGPT - FT Next Over 1.5 | Comp=... | Match=...
      const get = (k)=>{
        const m = block.match(new RegExp(`${k}=([^|\\n]+)`));
        return m ? m[1].trim() : null;
      };
      return {
        Ver: get("Ver"),
        Method: get("Method"),
        Comp: get("Comp"),
        Match: get("Match")
      };
    }

    function parseScorePair(s){
      const m = String(s||"").match(/(\d+)\s*-\s*(\d+)/);
      if(!m) return {home:null, away:null};
      return {home:Number(m[1]), away:Number(m[2])};
    }

    function parseSTATE(block){
      // STATE | Time=21 | RemHT=25 | RemFT=72 | Score=1-0
      const getN = (k)=>{
        const m = block.match(new RegExp(`${k}=(-?\\d+(?:\\.\\d+)?)`));
        return m ? Number(m[1]) : null;
      };
      const scoreRaw = (block.match(/Score=([^|\n]+)/) || [null,null])[1];
      const sc = parseScorePair(scoreRaw);
      return {
        Time: getN("Time"),
        RemHT: getN("RemHT"),
        RemFT: getN("RemFT"),
        ScoreHome: sc.home,
        ScoreAway: sc.away,
        ScoreTotal: (sc.home!==null && sc.away!==null) ? (sc.home+sc.away) : null,
        ScoreRaw: scoreRaw ? scoreRaw.trim() : null
      };
    }

    function parseStatLine(block, label){
      // STATS | SOT=2/0 | ...
      const m = block.match(new RegExp(`${label}=([0-9]+)\\/([0-9]+)`));
      if(!m) return null;
      return {h:Number(m[1]), a:Number(m[2])};
    }

    function parseSTATS(block){
      const line = block.split("\n")[0];
      return {
        SOT: parseStatLine(line,"SOT"),
        SOFF: parseStatLine(line,"SOFF"),
        COR: parseStatLine(line,"COR"),
        ATT: parseStatLine(line,"ATT"),
        DATT: parseStatLine(line,"DATT")
      };
    }

    function parseL10(block){
      // second line starts with L10 |
      const l = block.split("\n").find(x=>x.startsWith("L10"));
      if(!l) return null;
      return {
        SOT: parseStatLine(l,"SOT"),
        SOFF: parseStatLine(l,"SOFF"),
        COR: parseStatLine(l,"COR"),
        ATT: parseStatLine(l,"ATT"),
        DATT: parseStatLine(l,"DATT")
      };
    }

    function parsePRESS(block){
      // PRESS | GPI(M=75.58,L10=108.614) | ... | SI(M=40/25)
      const gpiM = safeNum((block.match(/GPI\(M=([0-9.]+)/)||[])[1]);
      const gpiL10 = safeNum((block.match(/GPI\(M=[0-9.]+,L10=([0-9.]+)/)||[])[1]);
      const siM = safeNum((block.match(/SI\(M=([0-9.]+)/)||[])[1]);
      const siL10 = safeNum((block.match(/SI\(M=[0-9.]+\/([0-9.]+)/)||[])[1]);
      return { GPI_M:gpiM, GPI_L10:gpiL10, SI_M:siM, SI_L10:siL10 };
    }

    function parseLATE(block){
      // LATE | AT=0.621 | L10=0.893| L5=25.175
      const at = safeNum((block.match(/AT=([0-9.]+)/)||[])[1]);
      const l10 = safeNum((block.match(/L10=([0-9.]+)/)||[])[1]);
      const l5 = safeNum((block.match(/L5=([0-9.]+)/)||[])[1]);
      return { AT:at, L10:l10, L5:l5 };
    }

    function parsePROB(block){
      // PROB | HT(+1=0.424,+2=0.105) | FT(+1=0.766,+2=0.409,+3=0.138)
      const res = {HT:null, FT:null};
      const ht = block.match(/HT\(([^)]+)\)/);
      const ft = block.match(/FT\(([^)]+)\)/);
      function parsePart(s){
        const obj = {};
        const pairs = s.split(",").map(x=>x.trim());
        for(const p of pairs){
          const m = p.match(/\+(\d+)\s*=\s*([0-9.]+)/);
          if(m) obj[Number(m[1])] = Number(m[2]);
        }
        return obj;
      }
      if(ht) res.HT = parsePart(ht[1]);
      if(ft) res.FT = parsePart(ft[1]);
      return res;
    }
    function parseODDSTOBET(block){
      // ODDS_TO_BET | FT Next Over 1.5 = 1.20
      const line = block.split("\n")[0];
      const m = line.match(/ODDS_TO_BET\s*\|\s*(HT|FT)\s+Next\s+Over\s+([0-9.]+)\s*=\s*([0-9.]+)/i);
      if(!m) return null;
      return {
        phase: m[1].toUpperCase(),
        line: Number(m[2]),
        odds: Number(m[3]),
        label: `${m[1].toUpperCase()} Next Over ${Number(m[2])}`
      };
    }

    function parseLP(block){
      // LP | WR=67 | ROI=-2.8 | Profit=-10 | AO=1.47| N=360
      const getN = (k)=>{
        const m = block.match(new RegExp(`${k}=(-?\\d+(?:\\.\\d+)?)`));
        return m ? Number(m[1]) : null;
      };
      return {
        WR: getN("WR"), ROI: getN("ROI"), Profit: getN("Profit"), AO: getN("AO"), N: getN("N")
      };
    }

    function parseNotification(raw){
      const blocks = splitBlocks(raw);
      const warnings = [];

      const required = ["META","STATE","ODDS_TO_BET","LP"];
      for(const r of required){
        if(!blocks[r]) return {ok:false, error:`Blocco mancante: ${r}`};
      }

      const meta = parseMETA(blocks.META);
      const st = parseSTATE(blocks.STATE);
      const stats = blocks.STATS ? parseSTATS(blocks.STATS) : null;
      const l10 = blocks.STATS ? parseL10(blocks.STATS) : null;
      const press = blocks.PRESS ? parsePRESS(blocks.PRESS) : null;
      const late = blocks.LATE ? parseLATE(blocks.LATE) : null;

      const prob = blocks.PROB ? parsePROB(blocks.PROB) : {HT:null, FT:null};
      if(!blocks.PROB) warnings.push("Blocco PROB assente: user√≤ il modello interno (se presente) o stima da stats.");

      const oddsToBet = parseODDSTOBET(blocks.ODDS_TO_BET);
      if(!oddsToBet) return {ok:false, error:"ODDS_TO_BET non valido"};

      const lp = parseLP(blocks.LP);

      return {ok:true, parsed:{ meta, state:st, stats, l10, press, late, prob, oddsToBet, lp }, warnings};
    }

    // -------------------------------
    // Probability + Stake
    // -------------------------------
    function neededGoalsFromLine_NEXT(line){
      // Next Over 0.5 => 1 goal; 1.5=>2 goals; 2.5=>3 goals...
      const x = safeNum(line);
      if(x===null) return null;
      return Math.floor(x) + 1;
    }

    function poissonTailProb(lambda, kPlus){
      if(lambda===null || !isFinite(lambda) || lambda<0) return null;
      if(kPlus<=0) return 1.0;
      let cdf = 0.0;
      let term = Math.exp(-lambda);
      cdf += term;
      for(let i=1;i<kPlus;i++){
        term *= lambda / i;
        cdf += term;
        if(term < 1e-12) break;
      }
      let p = 1.0 - cdf;
      if(p<0) p=0; if(p>1) p=1;
      return p;
    }

    function loadRuntimeModels(){
      try{
        const raw = localStorage.getItem("RUNTIME_MODELS_JSON");
        if(!raw) return null;
        return JSON.parse(raw);
      }catch(e){
        return null;
      }
    }

    function predictWithRuntimeModels(runtime, parsed, phase, needed){
      if(!runtime) return null;
      const key = (phase==="HT") ? ("ht" in runtime ? "ht" : "HT") : ("ft" in runtime ? "ft" : "FT");
      const model = runtime[key];
      if(!model) return null;

      const t = parsed.state.Time ?? null;
      const rem_ft = parsed.state.RemFT ?? null;
      const rem_ht = parsed.state.RemHT ?? null;
      const rem = (phase==="HT") ? rem_ht : rem_ft;
      if(rem===null || !isFinite(rem) || rem<=0) return null;

      const feats = {};
      const eps=1e-9;

      const sumStats = parsed.stats ? {
        sot: (parsed.stats.SOT?.h ?? 0) + (parsed.stats.SOT?.a ?? 0),
        soff:(parsed.stats.SOFF?.h ?? 0) + (parsed.stats.SOFF?.a ?? 0),
        cor: (parsed.stats.COR?.h ?? 0) + (parsed.stats.COR?.a ?? 0),
        att: (parsed.stats.ATT?.h ?? 0) + (parsed.stats.ATT?.a ?? 0),
        datt:(parsed.stats.DATT?.h ?? 0) + (parsed.stats.DATT?.a ?? 0),
      } : null;

      const sumL10 = parsed.l10 ? {
        sot: (parsed.l10.SOT?.h ?? 0) + (parsed.l10.SOT?.a ?? 0),
        soff:(parsed.l10.SOFF?.h ?? 0) + (parsed.l10.SOFF?.a ?? 0),
        cor: (parsed.l10.COR?.h ?? 0) + (parsed.l10.COR?.a ?? 0),
        att: (parsed.l10.ATT?.h ?? 0) + (parsed.l10.ATT?.a ?? 0),
        datt:(parsed.l10.DATT?.h ?? 0) + (parsed.l10.DATT?.a ?? 0),
      } : null;

      const denom = (t!==null && isFinite(t)) ? (t+1) : 1;

      if(sumStats){
        feats["sum_sot_rate"] = sumStats.sot / denom;
        feats["sum_soff_rate"] = sumStats.soff / denom;
        feats["sum_cor_rate"] = sumStats.cor / denom;
        feats["sum_att_rate"] = sumStats.att / denom;
        feats["sum_datt_rate"] = sumStats.datt / denom;
        feats["diff_sot_rate"] = ((parsed.stats.SOT?.h ?? 0) - (parsed.stats.SOT?.a ?? 0)) / denom;
        feats["diff_att_rate"] = ((parsed.stats.ATT?.h ?? 0) - (parsed.stats.ATT?.a ?? 0)) / denom;
        feats["diff_datt_rate"] = ((parsed.stats.DATT?.h ?? 0) - (parsed.stats.DATT?.a ?? 0)) / denom;
      }
      if(sumL10){
        feats["sum_sot_l10_rate"] = sumL10.sot / 10.0;
        feats["sum_soff_l10_rate"] = sumL10.soff / 10.0;
        feats["sum_cor_l10_rate"] = sumL10.cor / 10.0;
        feats["sum_att_l10_rate"] = sumL10.att / 10.0;
        feats["sum_datt_l10_rate"] = sumL10.datt / 10.0;
      }

      feats["goals_so_far"] = parsed.state.ScoreTotal ?? null;
      feats["t"] = t;
      feats["rem_ft"] = rem_ft;
      feats["rem_ht"] = rem_ht;

      let eta = (model.intercept ?? 0);
      const coef = model.coef ?? {};
      const featList = model.features ?? Object.keys(coef);

      for(const f of featList){
        const x = (feats[f]!==undefined && feats[f]!==null && isFinite(feats[f])) ? feats[f] : 0;
        const c = (coef[f]!==undefined && coef[f]!==null && isFinite(coef[f])) ? coef[f] : 0;
        eta += c * x;
      }

      eta += Math.log(rem + eps);

      const mu = Math.exp(eta);
      let p = poissonTailProb(mu, needed);

      try{
        const cal = model.calibration || model.cal || null;
        const kKey = "k"+String(needed);
        if(cal && cal[kKey] && p!==null){
          const A = cal[kKey].a ?? cal[kKey].A ?? null;
          const B = cal[kKey].b ?? cal[kKey].B ?? null;
          if(A!==null && B!==null){
            const logit = (q)=>Math.log(q/(1-q));
            const invlogit = (z)=>1/(1+Math.exp(-z));
            const z = A + B*logit(Math.min(0.999, Math.max(0.001, p)));
            p = invlogit(z);
          }
        }
      }catch(e){}

      return {p, mu, used:"RUNTIME"};
    }

    function estimateLambdaHeuristic(parsed, phase){
      const t = parsed.state.Time ?? null;
      const rem = (phase==="HT") ? parsed.state.RemHT : parsed.state.RemFT;
      if(rem===null || !isFinite(rem) || rem<=0) return null;

      const denom = (t!==null && isFinite(t)) ? (t+1) : 1;
      const s = parsed.stats;
      const l10 = parsed.l10;

      const sum = (obj, key)=> obj && obj[key] ? ((obj[key].h??0)+(obj[key].a??0)) : 0;

      const sot_r = sum(s,"SOT")/denom;
      const soff_r= sum(s,"SOFF")/denom;
      const cor_r = sum(s,"COR")/denom;
      const att_r = sum(s,"ATT")/denom;
      const datt_r= sum(s,"DATT")/denom;

      const sot10 = sum(l10,"SOT")/10.0;
      const soff10= sum(l10,"SOFF")/10.0;
      const cor10 = sum(l10,"COR")/10.0;
      const att10 = sum(l10,"ATT")/10.0;
      const datt10= sum(l10,"DATT")/10.0;

      const press = (wSOT,wSOFF,wCOR,wDA,wATT, SOT,SOFF,COR,DA,ATT)=> (wSOT*SOT + wSOFF*SOFF + wCOR*COR + wDA*DA + wATT*ATT);
      const p_all = press(0.35,0.20,0.15,0.20,0.10, sot_r,soff_r,cor_r,datt_r,att_r);
      const p_l10 = press(0.35,0.20,0.15,0.20,0.10, sot10,soff10,cor10,datt10,att10);

      const gpiM = parsed.press?.GPI_M ?? null;
      const gpiL10 = parsed.press?.GPI_L10 ?? null;
      const gpiBase = (gpiM!==null && isFinite(gpiM)) ? gpiM : 80;
      const gpi10 = (gpiL10!==null && isFinite(gpiL10)) ? gpiL10 : gpiBase;

      const intensity = clamp(0.55, 2.20, 0.60*(gpiBase/80) + 0.40*(gpi10/80));

      const late = parsed.late?.AT ?? null;
      const late10 = parsed.late?.L10 ?? null;
      const lateFactor = clamp(0.75, 1.35, 1 + 0.10*((late??0.6)-0.6) + 0.07*((late10??0.6)-0.6));

      const siM = parsed.press?.SI_M ?? null;
      const siL = parsed.press?.SI_L10 ?? null;
      const siFactor = clamp(0.75, 1.15, 1 - 0.004*((siM??50)-50) - 0.002*((siL??50)-50));

      const goalsSoFar = parsed.state.ScoreTotal ?? 0;
      const goalsFactor = clamp(0.85, 1.25, 1 + 0.05*goalsSoFar);

      const baseRate = 0.026;
      const pBoost = clamp(0.70, 1.35, 1 + 0.9*(p_all - 0.10));
      const p10Boost = clamp(0.75, 1.45, 1 + 0.8*(p_l10 - 0.10));

      const lambda = baseRate * rem * intensity * lateFactor * siFactor * goalsFactor * (0.55*pBoost + 0.45*p10Boost);
      return clamp(0, 12, lambda);
    }

    function pickMatchProbability_NEXT(parsed){
      const phase = parsed.oddsToBet.phase;
      const line = parsed.oddsToBet.line;
      if(!phase || line===null) return {p:null, needed:null, lambda:null, reason:"Phase o Line non disponibili"};
      const needed = neededGoalsFromLine_NEXT(line);

      const table = (phase==="HT") ? parsed.prob.HT : parsed.prob.FT;
      if(table && table[needed]!==undefined && table[needed]!==null){
        return {p: table[needed], needed, lambda:null, used:"PROB", reason:null};
      }

      const runtime = loadRuntimeModels();
      const rm = predictWithRuntimeModels(runtime, parsed, phase, needed);
      if(rm && rm.p!==null){
        return {p: rm.p, needed, lambda: rm.mu, used: rm.used, reason:null};
      }

      const lam = estimateLambdaHeuristic(parsed, phase);
      if(lam===null) return {p:null, needed, lambda:null, used:"NONE", reason:"Dati insufficienti per stimare Œª"};
      const p = poissonTailProb(lam, needed);
      return {p, needed, lambda: lam, used:"HEUR", reason:null};
    }

    function calcStakeV1(parsed){
      const warnings=[];
      const odds = parsed.oddsToBet.odds;
      const lpWR = parsed.lp?.WR;
      const lpN = parsed.lp?.N;

      const matchP = pickMatchProbability_NEXT(parsed);
      if(matchP.p===null){
        return {ok:false, error:"Impossibile calcolare probabilit√†", warnings, matchP};
      }

      const P_MODEL = matchP.p;
      const WR = (lpWR!==null && isFinite(lpWR)) ? clamp(lpWR/100, 0.05, 0.95) : null;

      let P_REF = P_MODEL;
      let source = "MODEL";
      if(WR!==null){
        const w = clamp((lpN||0) / 800, 0.10, 0.50);
        P_REF = (1-w)*P_MODEL + w*WR;
        source = "MODEL+WR";
      }

      const implied = 1/odds;
      const edge = P_REF - implied;
      const ev = P_REF*odds - 1;

      const b = odds - 1;
      let kelly = (b>0) ? edge / b : 0;

      const frac = 0.50;
      let stakePct = 0.01;

      if(kelly>0){
        const kAdj = kelly*frac;
        stakePct = clamp(kAdj, 0.01, 0.05);
      }else{
        stakePct = 0.01;
        warnings.push("Edge negativo: stake impostato al minimo (1%)");
      }

      if(lpN!==null && lpN<500){
        stakePct *= 0.85;
        stakePct = Math.max(stakePct, 0.01);
        warnings.push("LP N < 500: haircut stake -15%");
      }

      const stakeAmt = roundStake1decMin1(state.bankroll_day * stakePct);
      const stakePctEff = stakeAmt / state.bankroll_day;

      return {
        ok:true,
        p_model:P_MODEL,
        p_ref:P_REF,
        source,
        edge,
        ev,
        implied,
        odds,
        stake_pct: stakePctEff,
        stake_amt: stakeAmt,
        needed_goals: matchP.needed,
        lambda_est: matchP.lambda ?? null,
        match_source: matchP.used ?? null,
        warnings
      };
    }
    // -------------------------------
    // UI rendering + events
    // -------------------------------
    const notifText=document.getElementById("notifText");
    const btnParse=document.getElementById("btnParse");
    const btnClear=document.getElementById("btnClear");
    const parseMsg=document.getElementById("parseMsg");
    const parseHint=document.getElementById("parseHint");
    const actionWrap=document.getElementById("actionWrap");
    const runtimeModelsText=document.getElementById("runtimeModelsText");
    const btnSaveRuntime=document.getElementById("btnSaveRuntime");
    const btnClearRuntime=document.getElementById("btnClearRuntime");
    const runtimeStatus=document.getElementById("runtimeStatus");

    const bankrollCurrent=document.getElementById("bankrollCurrent");
    const bankrollDay=document.getElementById("bankrollDay");
    const btnResetDay=document.getElementById("btnResetDay");

    const kpiDayBR=document.getElementById("kpiDayBR");
    const kpiDayROC=document.getElementById("kpiDayROC");
    const kpiStopTxt=document.getElementById("kpiStopTxt");
    const dayPillTxt=document.getElementById("dayPillTxt");

    const historyList=document.getElementById("historyList");
    const historyResultFilter=document.getElementById("historyResultFilter");
    const historyDateFilter=document.getElementById("historyDateFilter");
    const historySearch=document.getElementById("historySearch");

    const btnManualAdd=document.getElementById("btnManualAdd");
    const manualAddWrap=document.getElementById("manualAddWrap");
    const manDate=document.getElementById("manDate");
    const manMatch=document.getElementById("manMatch");
    const manMethod=document.getElementById("manMethod");
    const manPhase=document.getElementById("manPhase");
    const manLine=document.getElementById("manLine");
    const manOdds=document.getElementById("manOdds");
    const manStake=document.getElementById("manStake");
    const manResult=document.getElementById("manResult");
    const btnManualSave=document.getElementById("btnManualSave");
    const btnManualCancel=document.getElementById("btnManualCancel");
    const btnExportHistory=document.getElementById("btnExportHistory");
    const fileImportHistory=document.getElementById("fileImportHistory");

    const donutCanvas=document.getElementById("donutCanvas");
    const profitCanvas=document.getElementById("profitCanvas");
    const dashKpi=document.getElementById("dashKpi");
    const filtersList=document.getElementById("filtersList");

    // runtime models UI
    function updateRuntimeUI(){
      if(!runtimeModelsText) return;
      const raw = localStorage.getItem("RUNTIME_MODELS_JSON");
      if(raw){
        runtimeModelsText.value = raw;
        try{
          const obj = JSON.parse(raw);
          const hasFT = !!(obj.ft||obj.FT);
          const hasHT = !!(obj.ht||obj.HT);
          runtimeStatus.textContent = `Modello caricato ‚úÖ (FT:${hasFT?"ok":"‚Äî"} HT:${hasHT?"ok":"‚Äî"})`;
        }catch(e){
          runtimeStatus.textContent = "JSON non valido ‚ö†Ô∏è";
        }
      }else{
        runtimeModelsText.value = "";
        runtimeStatus.textContent = "Nessun modello caricato";
      }
    }
    updateRuntimeUI();

    if(btnSaveRuntime){
      btnSaveRuntime.addEventListener("click", ()=>{
        const raw = (runtimeModelsText.value||"").trim();
        if(!raw){
          localStorage.removeItem("RUNTIME_MODELS_JSON");
          updateRuntimeUI();
          toast("Modello rimosso");
          return;
        }
        try{
          JSON.parse(raw);
          localStorage.setItem("RUNTIME_MODELS_JSON", raw);
          updateRuntimeUI();
          toast("Modello salvato ‚úÖ");
        }catch(e){
          toast("JSON non valido");
        }
      });
    }
    if(btnClearRuntime){
      btnClearRuntime.addEventListener("click", ()=>{
        localStorage.removeItem("RUNTIME_MODELS_JSON");
        updateRuntimeUI();
        toast("Modello rimosso");
      });
    }

    function syncBankrollInputs(){
      bankrollCurrent.value = state.bankroll_current.toFixed(2);
      bankrollDay.value = state.bankroll_day.toFixed(2);
    }
    syncBankrollInputs();

    bankrollCurrent.addEventListener("change", ()=>{
      const n = safeNum(bankrollCurrent.value);
      if(n!==null){ state.bankroll_current = n; saveState(); renderAll(); }
    });
    bankrollDay.addEventListener("change", ()=>{
      const n = safeNum(bankrollDay.value);
      if(n!==null){ state.bankroll_day = n; saveState(); renderAll(); }
    });

    btnResetDay.addEventListener("click", ()=>{
      state.day_anchor_date = null;
      state.bankroll_day = state.bankroll_current;
      saveState();
      syncBankrollInputs();
      renderAll();
      toast("Nuovo giorno ‚úÖ");
    });

    btnClear.addEventListener("click", ()=>{
      notifText.value="";
      parseMsg.textContent="";
      parseHint.textContent="";
      actionWrap.innerHTML="";
    });

    btnParse.addEventListener("click", ()=>{
      const raw = notifText.value;
      const r = parseNotification(raw);
      if(!r.ok){
        parseMsg.textContent = "Errore: "+r.error;
        actionWrap.innerHTML="";
        return;
      }
      const parsed = r.parsed;

      const stakeRes = calcStakeV1(parsed);
      const allWarn = [...(r.warnings||[]), ...(stakeRes.warnings||[])];

      parseHint.textContent = allWarn.length ? "‚ö†Ô∏è" : "‚úÖ";
      parseMsg.textContent = allWarn.join(" ‚Ä¢ ");

      if(!stakeRes.ok){
        actionWrap.innerHTML = `<div class="help">Errore calcolo: ${escapeHtml(stakeRes.error||"")}</div>`;
        return;
      }

      const stakeAmt = stakeRes.stake_amt;
      const odds = parsed.oddsToBet.odds;

      actionWrap.innerHTML = `
        <div class="card">
          <div class="row wrap" style="gap:8px">
            <div class="pillMini">Prob stimata: <b class="mono">${pct(stakeRes.p_ref)}</b></div>
            <div class="pillMini">Goal richiesti (NEXT): <b class="mono">${stakeRes.needed_goals}</b></div>
            <div class="pillMini">Market: <b>${escapeHtml(parsed.oddsToBet.label)}</b></div>
            <div class="pillMini">Fonte: <b>${escapeHtml((stakeRes.match_source? (String(stakeRes.source||"‚Äî")+"+"+String(stakeRes.match_source)) : (stakeRes.source||"‚Äî")))}</b></div>
            <div class="pillMini">Œª: <b class="mono">${(stakeRes.lambda_est!==null && stakeRes.lambda_est!==undefined)?escapeHtml(Number(stakeRes.lambda_est).toFixed(2)):"‚Äî"}</b></div>
          </div>
          <div style="height:10px"></div>
          <div class="row wrap" style="gap:8px">
            <div class="pillMini">Implied: <b class="mono">${pct(stakeRes.implied)}</b></div>
            <div class="pillMini">Edge: <b class="mono">${pct(stakeRes.edge)}</b></div>
            <div class="pillMini">EV/unit√†: <b class="mono">${stakeRes.ev.toFixed(3)}</b></div>
          </div>
          <div style="height:12px"></div>
          <div class="card" style="background: rgba(255,255,255,.04)">
            <div class="row wrap" style="align-items:flex-end">
              <div style="flex:1">
                <div class="help">Stake consigliato</div>
                <div style="font-size:26px; font-weight:700" class="mono">${stakeAmt.toFixed(1)}‚Ç¨</div>
              </div>
              <div style="flex:1">
                <div class="help">Quota</div>
                <input id="oddsBox" value="${odds.toFixed(2)}" />
              </div>
            </div>
            <div style="height:10px"></div>
            <div class="row wrap">
              <button class="btn primary" id="btnAddToHistory">Aggiungi allo storico (pending)</button>
            </div>
            <div class="help" style="margin-top:8px">Lo stake √® clampato 1%‚Äì5% e mai sotto 1‚Ç¨ (se EV negativo: 1%).</div>
          </div>
        </div>
      `;

      const btnAddToHistory = document.getElementById("btnAddToHistory");
      btnAddToHistory.addEventListener("click", ()=>{
        const oddsPlayed = safeNum(document.getElementById("oddsBox").value) ?? odds;

        const b = {
          id: uuid(),
          date: new Date().toISOString().slice(0,10),
          created_at: new Date().toISOString(),
          meta: parsed.meta,
          state: parsed.state,
          stats: parsed.stats,
          l10: parsed.l10,
          press: parsed.press,
          late: parsed.late,
          prob: parsed.prob,
          odds_to_bet: { phase: parsed.oddsToBet.phase, line: parsed.oddsToBet.line, label: parsed.oddsToBet.label },
          lp: parsed.lp,
          execution:{
            bankroll_day: state.bankroll_day,
            bankroll_current: state.bankroll_current,
            odds_ref: odds,
            odds_played: oddsPlayed,
            stake_suggested: stakeAmt,
            stake_played: stakeAmt,
            ev: stakeRes.ev,
            p_ref: stakeRes.p_ref,
            p_model: stakeRes.p_model
          },
          result:"pending",
          profit_real:null
        };

        state.history.unshift(b);
        state.lastMethod = parsed.meta?.Method || state.lastMethod;
        if(!state.day_anchor_date){
          state.day_anchor_date = b.date;
          state.bankroll_day = state.bankroll_current;
          syncBankrollInputs();
        }
        saveState();
        renderAll();
        toast("Salvato ‚úÖ");
      });
    });

    // Manual add handlers
    function openManualAdd(){
      if(!manualAddWrap) return;
      manualAddWrap.style.display = "block";
      const today = new Date();
      const y = today.getFullYear();
      const m = String(today.getMonth()+1).padStart(2,"0");
      const d = String(today.getDate()).padStart(2,"0");
      manDate.value = `${y}-${m}-${d}`;
      if(state.lastMethod) manMethod.value = state.lastMethod;
    }
    function closeManualAdd(){
      if(!manualAddWrap) return;
      manualAddWrap.style.display = "none";
      [manMatch,manOdds,manStake,manLine].forEach(el=>{ if(el) el.value=""; });
    }

    if(btnManualAdd) btnManualAdd.addEventListener("click", ()=>{
      if(manualAddWrap.style.display==="none" || manualAddWrap.style.display===""){
        openManualAdd();
      }else{
        closeManualAdd();
      }
    });
    if(btnManualCancel) btnManualCancel.addEventListener("click", closeManualAdd);

    if(btnManualSave) btnManualSave.addEventListener("click", ()=>{
      const date = (manDate.value||"").trim();
      const match = (manMatch.value||"").trim();
      const method = (manMethod.value||"").trim();
      const phase = (manPhase.value||"").trim();
      const line = safeNum(manLine.value);
      const odds = safeNum(manOdds.value);
      const stake = safeNum(manStake.value);
      const result = (manResult.value||"pending");

      if(!date || !match || !method || !phase || line===null || odds===null || stake===null){
        toast("Compila data, partita, metodo, fase, line, quota e stake");
        return;
      }
      state.lastMethod = method;

      const b = {
        id: uuid(),
        date,
        created_at: new Date().toISOString(),
        meta: { Method: method, Match: match },
        odds_to_bet: { phase, line, label: `${phase} Next Over ${line}` },
        state: null, stats: null, l10: null, press:null, late:null, prob:{HT:null,FT:null}, lp:null,
        execution: {
          bankroll_day: state.bankroll_day,
          bankroll_current: state.bankroll_current,
          odds_ref: odds,
          odds_played: odds,
          stake_suggested: roundStake1decMin1(stake),
          stake_played: roundStake1decMin1(stake),
          ev: null,
          p_ref: null,
          p_model: null
        },
        result,
        profit_real: (result==="win"||result==="loss") ? calcProfit(result, stake, odds) : null
      };

      state.history.unshift(b);
      saveState();
      closeManualAdd();
      renderAll();
      toast("Aggiunto ‚úÖ");
    });

    if(btnExportHistory) btnExportHistory.addEventListener("click", ()=>{
      const blob = new Blob([JSON.stringify(state.history, null, 2)], {type:"application/json"});
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = `history_${new Date().toISOString().slice(0,10)}.json`;
      a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
    });

    if(fileImportHistory) fileImportHistory.addEventListener("change", async (e)=>{
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      try{
        const txt = await f.text();
        const arr = JSON.parse(txt);
        if(!Array.isArray(arr)) throw new Error("not array");
        const existing = new Set(state.history.map(x=>x.id));
        for(const b of arr){
          if(b && b.id && !existing.has(b.id)) state.history.push(b);
        }
        state.history.sort((a,b)=>String(b.date).localeCompare(String(a.date)));
        saveState();
        renderAll();
        toast("Import completato ‚úÖ");
      }catch(err){
        toast("Import fallito");
      }finally{
        fileImportHistory.value="";
      }
    });

    // -------------------------------
    // History rendering + editing
    // -------------------------------
    let editingBetId = null;

    historyResultFilter.addEventListener("change", renderHistory);
    historyDateFilter.addEventListener("change", renderHistory);
    historySearch.addEventListener("input", renderHistory);

    function formatPick(b){
      return (b.odds_to_bet && b.odds_to_bet.label) ? b.odds_to_bet.label : "‚Äî";
    }

    function resultTag(r){
      if(r==="win") return `<span class="tag win">WIN</span>`;
      if(r==="loss") return `<span class="tag loss">LOSE</span>`;
      if(r==="pending") return `<span class="tag pending">PENDING</span>`;
      return `<span class="tag noplay">NO PLAY</span>`;
    }

    function renderBetCardHTML(b){
      const isEditing = (editingBetId===b.id);

      const method = b.meta?.Method || "‚Äî";
      const match = b.meta?.Match || "‚Äî";
      const date = b.date || "‚Äî";
      const pick = formatPick(b);
      const odds = safeNum(b.execution?.odds_played ?? b.execution?.odds_ref);
      const stake = safeNum(b.execution?.stake_played ?? b.execution?.stake_suggested);
      const profit = (b.result==="win"||b.result==="loss") ? calcProfit(b.result, stake||0, odds||0) : 0;

      const topLine = isEditing ? `
        <div class="betTop">
          <div class="left">
            <div class="row wrap" style="gap:8px">
              <input data-edit="date" data-id="${b.id}" type="date" value="${escapeHtml(date)}" style="width:auto; min-width:140px"/>
              <input data-edit="match" data-id="${b.id}" type="text" value="${escapeHtml(match)}" style="flex:1; min-width:200px"/>
              <input class="mono" data-edit="method" data-id="${b.id}" type="text" value="${escapeHtml(method)}" style="width:auto; min-width:140px"/>
            </div>
            <div class="sub">Pick: <span class="mono">${escapeHtml(pick)}</span></div>
          </div>
          <div class="right">
            ${resultTag(b.result)}
          </div>
        </div>
      ` : `
        <div class="betTop">
          <div class="left">
            <b>${escapeHtml(match)}</b>
            <div class="sub">
              <span class="mono">${escapeHtml(date)}</span> ‚Ä¢
              <span class="method">${escapeHtml(method)}</span> ‚Ä¢
              Pick: <span class="mono">${escapeHtml(pick)}</span>
            </div>
          </div>
          <div class="right">
            ${resultTag(b.result)}
          </div>
        </div>
      `;

      const body = `
        <div class="betBody">
          <div class="kv">
            <small>Quota</small>
            ${isEditing
              ? `<input data-edit="odds" data-id="${b.id}" type="number" step="0.01" min="1" value="${odds??""}"/>`
              : `<b class="mono">${odds?odds.toFixed(2):"‚Äî"}</b>`
            }
          </div>
          <div class="kv">
            <small>Stake</small>
            ${isEditing
              ? `<input data-edit="stake" data-id="${b.id}" type="number" step="0.1" min="1" value="${stake??""}"/>`
              : `<b class="mono">${stake?stake.toFixed(1)+"‚Ç¨":"‚Äî"}</b>`
            }
          </div>
          <div class="kv">
            <small>Profit (chiusa)</small>
            <b class="mono">${(b.result==="win"||b.result==="loss") ? fmtEuro(profit) : "‚Äî"}</b>
          </div>
          <div class="kv">
            <small>Stato</small>
            ${isEditing
              ? `
                <select data-edit="result" data-id="${b.id}">
                  <option value="pending" ${b.result==="pending"?"selected":""}>Pending</option>
                  <option value="win" ${b.result==="win"?"selected":""}>Vinta</option>
                  <option value="loss" ${b.result==="loss"?"selected":""}>Persa</option>
                  <option value="not_played" ${b.result==="not_played"?"selected":""}>Non giocata</option>
                </select>
              ` : `<b>${escapeHtml(b.result)}</b>`
            }
          </div>
        </div>
      `;

      const actions = `
        <div class="row wrap" style="margin-top:10px; gap:8px">
          ${isEditing
            ? `
              <button class="btn primary" data-act="save" data-id="${b.id}">Salva</button>
              <button class="btn" data-act="cancel" data-id="${b.id}">Annulla</button>
            `
            : `
              <button class="btn" data-act="edit" data-id="${b.id}">Modifica</button>
              <button class="btn danger" data-act="del" data-id="${b.id}">Elimina</button>
            `
          }
        </div>
      `;

      return `<div class="bet" data-bet="${b.id}">${topLine}${body}${actions}</div>`;
    }

    historyList.addEventListener("click", (e)=>{
      const btn = e.target.closest("button");
      if(!btn) return;
      const act = btn.getAttribute("data-act");
      const id = btn.getAttribute("data-id");
      const b = state.history.find(x=>x.id===id);
      if(!b) return;

      if(act==="edit"){
        editingBetId = id;
        renderHistory();
        return;
      }
      if(act==="cancel"){
        editingBetId = null;
        renderHistory();
        return;
      }
      if(act==="save"){
        const dateEl = document.querySelector(`[data-edit="date"][data-id="${CSS.escape(id)}"]`);
        const matchEl = document.querySelector(`[data-edit="match"][data-id="${CSS.escape(id)}"]`);
        const methodEl = document.querySelector(`[data-edit="method"][data-id="${CSS.escape(id)}"]`);
        const oddsEl = document.querySelector(`[data-edit="odds"][data-id="${CSS.escape(id)}"]`);
        const stakeEl= document.querySelector(`[data-edit="stake"][data-id="${CSS.escape(id)}"]`);
        const resEl  = document.querySelector(`[data-edit="result"][data-id="${CSS.escape(id)}"]`);

        if(dateEl && dateEl.value) b.date = dateEl.value;
        if(matchEl && matchEl.value.trim()) b.meta.Match = matchEl.value.trim();
        if(methodEl && methodEl.value.trim()) b.meta.Method = methodEl.value.trim();

        const o = safeNum(oddsEl?.value);
        const s = safeNum(stakeEl?.value);
        if(o!==null) b.execution.odds_played = o;
        if(s!==null) b.execution.stake_played = roundStake1decMin1(s);

        if(resEl) b.result = resEl.value;

        if(b.result==="win"||b.result==="loss"){
          const stake = safeNum(b.execution.stake_played) || 0;
          const odds = safeNum(b.execution.odds_played) || 0;
          b.profit_real = calcProfit(b.result, stake, odds);
        }else{
          b.profit_real = null;
        }

        editingBetId = null;
        saveState();
        renderAll();
        toast("Salvato ‚úÖ");
        return;
      }
      if(act==="del"){
        state.history = state.history.filter(x=>x.id!==id);
        saveState();
        renderAll();
        toast("Eliminata");
        return;
      }
    });

    function renderHistory(){
      const rFilter = historyResultFilter.value;
      const dFilter = historyDateFilter.value;
      const q = (historySearch.value||"").trim().toLowerCase();

      let arr = [...state.history];

      if(rFilter!=="all"){
        arr = arr.filter(b=>b.result===rFilter);
      }
      if(dFilter){
        arr = arr.filter(b=>b.date===dFilter);
      }
      if(q){
        arr = arr.filter(b=>{
          const s = `${b.meta?.Match||""} ${b.meta?.Method||""}`.toLowerCase();
          return s.includes(q);
        });
      }

      if(arr.length===0){
        historyList.innerHTML = `<div class="help">Nessun elemento nello storico con i filtri selezionati.</div>`;
        return;
      }

      historyList.innerHTML = arr.map(renderBetCardHTML).join("");
    }

    // -------------------------------
    // Dashboard
    // -------------------------------
    function getClosed(){
      return state.history.filter(b=>b.result==="win"||b.result==="loss");
    }

    function computeStats(arr){
      const bets = arr.length;
      const wins = arr.filter(b=>b.result==="win").length;
      const stakes = arr.reduce((acc,b)=>acc+(safeNum(b.execution?.stake_played)||0),0);
      const profit = arr.reduce((acc,b)=>{
        const stake = safeNum(b.execution?.stake_played)||0;
        const odds = safeNum(b.execution?.odds_played)||0;
        return acc + calcProfit(b.result, stake, odds);
      },0);
      const wr = bets>0 ? wins/bets : null;
      const roi = stakes>0 ? profit/stakes : null;
      return {bets,wins,wr,roi,profit,stakes};
    }

    function computeMaxDrawdown(profitSeries){
      let peak = 0;
      let dd = 0;
      for(const x of profitSeries){
        if(x>peak) peak=x;
        dd = Math.min(dd, x-peak);
      }
      return dd; // negative
    }

    function computeStreak(arr){
      let bestW=0, bestL=0;
      let currW=0, currL=0;
      for(const b of arr){
        if(b.result==="win"){ currW++; currL=0; bestW=Math.max(bestW,currW); }
        else if(b.result==="loss"){ currL++; currW=0; bestL=Math.max(bestL,currL); }
      }
      return {bestW, bestL};
    }

    function drawDonut(canvas, wr){
      const ctx = canvas.getContext("2d");
      const w = canvas.width = canvas.clientWidth*2;
      const h = canvas.height = canvas.clientHeight*2;
      const cx=w/2, cy=h/2;
      const r = Math.min(w,h)*0.32;
      ctx.clearRect(0,0,w,h);

      const p = wr===null ? 0 : wr;
      const a0 = -Math.PI/2;
      const a1 = a0 + p*2*Math.PI;

      ctx.lineWidth = r*0.28;
      ctx.lineCap="round";

      // track
      ctx.beginPath();
      ctx.strokeStyle = "rgba(255,255,255,.10)";
      ctx.arc(cx,cy,r,0,Math.PI*2);
      ctx.stroke();

      // value
      ctx.beginPath();
      ctx.strokeStyle = "rgba(74,163,255,.95)";
      ctx.arc(cx,cy,r,a0,a1);
      ctx.stroke();

      // text
      ctx.fillStyle="rgba(232,240,255,.95)";
      ctx.font = `${Math.round(r*0.55)}px ${getComputedStyle(document.body).fontFamily}`;
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      ctx.fillText(wr===null?"‚Äî":Math.round(wr*100)+"%", cx, cy);
    }

    function drawProfit(canvas, series){
      const ctx = canvas.getContext("2d");
      const w = canvas.width = canvas.clientWidth*2;
      const h = canvas.height = canvas.clientHeight*2;
      ctx.clearRect(0,0,w,h);

      if(series.length<2){
        ctx.fillStyle="rgba(138,160,194,.9)";
        ctx.font = `28px ${getComputedStyle(document.body).fontFamily}`;
        ctx.fillText("‚Äî", w/2-10, h/2);
        return;
      }

      const min = Math.min(...series);
      const max = Math.max(...series);
      const pad = 28;
      const x0 = pad, y0 = pad, x1 = w-pad, y1 = h-pad;

      const span = (max-min) || 1;
      const px = (i)=> x0 + (i/(series.length-1))*(x1-x0);
      const py = (v)=> y1 - ((v-min)/span)*(y1-y0);

      // area
      const last = series[series.length-1];
      ctx.beginPath();
      ctx.moveTo(px(0), py(0));
      for(let i=0;i<series.length;i++){
        ctx.lineTo(px(i), py(series[i]));
      }
      ctx.lineTo(px(series.length-1), py(min));
      ctx.lineTo(px(0), py(min));
      ctx.closePath();

      ctx.fillStyle = (last>=0) ? "rgba(53,208,127,.14)" : "rgba(255,93,93,.14)";
      ctx.fill();

      // line
      ctx.beginPath();
      ctx.moveTo(px(0), py(series[0]));
      for(let i=1;i<series.length;i++){
        ctx.lineTo(px(i), py(series[i]));
      }
      ctx.strokeStyle = (last>=0) ? "rgba(53,208,127,.90)" : "rgba(255,93,93,.90)";
      ctx.lineWidth = 6;
      ctx.lineCap="round";
      ctx.stroke();

      // axis labels (4-5 ticks)
      ctx.fillStyle="rgba(138,160,194,.9)";
      ctx.font = `22px ${getComputedStyle(document.body).fontFamily}`;
      ctx.textAlign="right";
      ctx.textBaseline="middle";
      const ticks=5;
      for(let i=0;i<ticks;i++){
        const v = min + (i/(ticks-1))*span;
        const y = py(v);
        ctx.fillText(v.toFixed(0), x0-8, y);
        ctx.strokeStyle="rgba(255,255,255,.06)";
        ctx.lineWidth=2;
        ctx.beginPath();
        ctx.moveTo(x0, y);
        ctx.lineTo(x1, y);
        ctx.stroke();
      }
    }

    function renderDashboard(){
      const closed = getClosed();
      const s = computeStats(closed);

      const profitSeries = [];
      let cum=0;
      const sorted = [...closed].sort((a,b)=>String(a.date).localeCompare(String(b.date)));
      for(const b of sorted){
        const stake = safeNum(b.execution?.stake_played)||0;
        const odds = safeNum(b.execution?.odds_played)||0;
        cum += calcProfit(b.result, stake, odds);
        profitSeries.push(cum);
      }

      const dd = computeMaxDrawdown(profitSeries);
      const streak = computeStreak(sorted);

      dashKpi.innerHTML = `
        <div class="box">
          <b>Numero bet</b>
          <div class="v mono">${s.bets}</div>
          <div class="s">chiuse</div>
        </div>
        <div class="box">
          <b>Winrate</b>
          <div class="v mono">${s.wr===null?"‚Äî":pct(s.wr)}</div>
          <div class="s">wins: ${s.wins}</div>
        </div>
        <div class="box">
          <b>ROI</b>
          <div class="v mono">${s.roi===null?"‚Äî":pct(s.roi)}</div>
          <div class="s">staked: ${fmtEuro(s.stakes)}</div>
        </div>
        <div class="box">
          <b>Profit</b>
          <div class="v mono">${fmtEuro(s.profit)}</div>
          <div class="s">cum</div>
        </div>
        <div class="box">
          <b>Max drawdown</b>
          <div class="v mono">${fmtEuro(dd)}</div>
          <div class="s">peggior drawdown</div>
        </div>
        <div class="box">
          <b>Streak</b>
          <div class="v mono">${streak.bestW}W / ${streak.bestL}L</div>
          <div class="s">max streak</div>
        </div>
      `;

      drawDonut(donutCanvas, s.wr);
      drawProfit(profitCanvas, profitSeries);
    }

    // -------------------------------
    // Time summary
    // -------------------------------
    function renderTimeSummary(){
      const sel = document.getElementById("timeGroupSelect");
      const body = document.getElementById("timeBody");
      if(!sel || !body) return;

      const mode = sel.value || "day";
      const closed = state.history.filter(b=>b && (b.result==="win" || b.result==="loss"));
      const pending = state.history.filter(b=>b && b.result==="pending");

      const keyFor = (d)=>{
        const dt = new Date(d+"T00:00:00");
        if(isNaN(dt.getTime())) return String(d);
        const y = dt.getFullYear();
        const m = String(dt.getMonth()+1).padStart(2,"0");
        const day = String(dt.getDate()).padStart(2,"0");
        if(mode==="day") return `${y}-${m}-${day}`;
        if(mode==="month") return `${y}-${m}`;
        const q = Math.floor((dt.getMonth())/3)+1;
        return `${y}-Q${q}`;
      };

      const agg = new Map();
      for(const b of closed){
        const k = keyFor(b.date);
        if(!agg.has(k)) agg.set(k, {bets:0, wins:0, profit:0, staked:0});
        const a = agg.get(k);
        a.bets += 1;
        if(b.result==="win") a.wins += 1;
        const stake = safeNum(b.execution?.stake_played ?? b.execution?.stake_suggested) ?? 0;
        const odds = safeNum(b.execution?.odds_played ?? b.execution?.odds_ref) ?? 0;
        a.staked += stake;
        a.profit += calcProfit(b.result, stake, odds);
      }

      const pendAgg = new Map();
      for(const b of pending){
        const k = keyFor(b.date);
        pendAgg.set(k, (pendAgg.get(k)||0)+1);
      }

      const keys = Array.from(new Set([...agg.keys(), ...pendAgg.keys()])).sort((a,b)=>String(b).localeCompare(String(a)));
      if(keys.length===0){
        body.innerHTML = `<div class="help">Nessun dato disponibile (serve almeno una bet chiusa).</div>`;
        return;
      }

      const rows = keys.map(k=>{
        const a = agg.get(k) || {bets:0,wins:0,profit:0,staked:0};
        const p = pendAgg.get(k) || 0;
        const wr = a.bets>0 ? (a.wins/a.bets) : null;
        const roi = a.staked>0 ? (a.profit/a.staked) : null;
        return {k, ...a, pending:p, wr, roi};
      });

      body.innerHTML = `
        <table>
          <thead>
            <tr><th>Periodo</th><th>Chiuse</th><th>WR</th><th>ROI</th><th>Profit</th><th>Pending</th></tr>
          </thead>
          <tbody>
            ${rows.map(r=>`
              <tr>
                <td>${escapeHtml(r.k)}</td>
                <td class="mono">${r.bets}</td>
                <td class="mono">${r.wr===null?"‚Äî":pct(r.wr)}</td>
                <td class="mono">${r.roi===null?"‚Äî":pct(r.roi)}</td>
                <td class="mono">${fmtEuro(r.profit)}</td>
                <td class="mono">${r.pending}</td>
              </tr>
            `).join("")}
          </tbody>
        </table>
      `;
    }

    document.getElementById("timeGroupSelect").addEventListener("change", renderTimeSummary);

    // -------------------------------
    // Filters (grouped by Method only)
    // -------------------------------
    function filterKeyName(b){
      return `${b.meta?.Method || "‚Äî"}`;
    }

    function renderFilters(){
      const closed = getClosed();
      const groups = new Map();
      for(const b of closed){
        const k = filterKeyName(b);
        if(!groups.has(k)) groups.set(k, []);
        groups.get(k).push(b);
      }

      const keys = [...groups.keys()].sort((a,b)=>String(a).localeCompare(String(b)));
      if(keys.length===0){
        filtersList.innerHTML = `<div class="help">Nessun filtro: servono bet chiuse nello storico.</div>`;
        return;
      }

      const cards = keys.map(k=>{
        const arr = groups.get(k);
        const s = computeStats(arr);

        // last LP snapshot for this method (any bet, even pending)
        const lastAny = state.history.find(b=> (b.meta?.Method||"‚Äî")===k && b.lp);
        const lp = lastAny?.lp || null;

        return `
          <details class="card">
            <summary>
              <div class="row wrap" style="gap:8px">
                <div style="flex:1; min-width:140px"><b>${escapeHtml(k)}</b></div>
                <div class="pillMini">Bet: <b class="mono">${s.bets}</b></div>
                <div class="pillMini">WR: <b class="mono">${s.wr===null?"‚Äî":pct(s.wr)}</b></div>
                <div class="pillMini">ROI: <b class="mono">${s.roi===null?"‚Äî":pct(s.roi)}</b></div>
                <div class="pillMini">Profit: <b class="mono">${fmtEuro(s.profit)}</b></div>
              </div>
            </summary>
            <div style="margin-top:10px">
              <div class="help"><b>Confronto con ultimo LP</b> (se presente nello storico per questo Method)</div>
              <div class="row wrap" style="gap:8px; margin-top:8px">
                <div class="pillMini">LP WR: <b class="mono">${lp?.WR!==null? lp.WR+"%":"‚Äî"}</b></div>
                <div class="pillMini">LP ROI: <b class="mono">${lp?.ROI!==null? lp.ROI+"%":"‚Äî"}</b></div>
                <div class="pillMini">LP AO: <b class="mono">${lp?.AO!==null? lp.AO.toFixed(2):"‚Äî"}</b></div>
                <div class="pillMini">LP N: <b class="mono">${lp?.N!==null? lp.N:"‚Äî"}</b></div>
              </div>
              <div style="height:10px"></div>
              <div class="help">Suggerimento: se vuoi fare analisi pi√π profonde (mesi/3m/6m/1y) aggiungiamo un grafico dedicato nel prossimo step.</div>
            </div>
          </details>
        `;
      });

      filtersList.innerHTML = cards.join("");
    }

    // -------------------------------
    // Day pill + KPI day
    // -------------------------------
    function computeDayROC(){
      const today = new Date().toISOString().slice(0,10);
      const anchor = state.day_anchor_date || today;
      const brDay = state.bankroll_day;

      const closedToday = state.history.filter(b=> (b.date===anchor) && (b.result==="win"||b.result==="loss"));
      const profit = closedToday.reduce((acc,b)=>{
        const stake = safeNum(b.execution?.stake_played)||0;
        const odds = safeNum(b.execution?.odds_played)||0;
        return acc + calcProfit(b.result, stake, odds);
      },0);

      const roc = brDay>0 ? profit/brDay : 0;
      return {anchor, brDay, profit, roc};
    }

    function renderDayBar(){
      const d = computeDayROC();
      kpiDayBR.textContent = d.brDay.toFixed(2)+"‚Ç¨";
      kpiDayROC.textContent = pct(d.roc);

      let msg="‚Äî";
      if(d.roc>=0.03) msg="‚úÖ Target profit raggiunto (+3% ROC): valuta stop.";
      else if(d.roc<=-0.10) msg="‚õî Stop loss raggiunto (-10% ROC): fermati.";
      kpiStopTxt.textContent = msg;

      dayPillTxt.textContent = `Giornata: ${d.anchor} ‚Ä¢ Profit ${fmtEuro(d.profit)} ‚Ä¢ ROC ${pct(d.roc)}`;
    }

    // -------------------------------
    // Render all
    // -------------------------------
    function renderAll(){
      renderDayBar();
      renderHistory();
      renderDashboard();
      renderTimeSummary();
      renderFilters();

      // auto-update bankroll_current from closed results
      const closed = getClosed();
      const profit = closed.reduce((acc,b)=>{
        const stake = safeNum(b.execution?.stake_played)||0;
        const odds = safeNum(b.execution?.odds_played)||0;
        return acc + calcProfit(b.result, stake, odds);
      },0);

      // bankroll_current starts from day bankroll? No: keep manual control. We just keep it synced if user wants.
      // For now: don't override user's bankroll_current automatically.

      saveState();
    }

    // init
    renderAll();
  </script>
</body>
</html>
