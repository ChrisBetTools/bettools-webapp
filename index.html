<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BetTools ‚Äî index</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#10182c;
      --panel2:#0d1528;
      --text:#e8eefc;
      --muted:#9fb0d0;
      --line:#223055;
      --accent:#5aa9ff;
      --good:#19c37d;
      --bad:#ff4d4f;
      --warn:#ffd166;
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --radius: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      background:linear-gradient(180deg,#070b14 0%, #0b1220 45%, #070b14 100%);
      color:var(--text);
    }

    /* Top bar */
    .topbar{
      position:sticky; top:0; z-index:30;
      display:flex; align-items:center; gap:10px;
      padding:12px 14px;
      background:rgba(10,16,31,.86);
      backdrop-filter: blur(10px);
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    .hamburger{
      width:42px; height:42px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(255,255,255,.04);
      display:grid; place-items:center;
      cursor:pointer;
      user-select:none;
    }
    .hamburger:active{transform:scale(.98)}
    .hamburger span{
      display:block; width:18px; height:2px; background:rgba(232,238,252,.92);
      border-radius:2px; position:relative;
    }
    .hamburger span::before,.hamburger span::after{
      content:""; position:absolute; left:0; width:18px; height:2px;
      background:rgba(232,238,252,.92); border-radius:2px;
    }
    .hamburger span::before{top:-6px}
    .hamburger span::after{top:6px}
    .brand{display:flex; flex-direction:column; line-height:1.05}
    .brand b{font-size:14px; letter-spacing:.2px}
    .brand small{color:var(--muted); font-size:12px}
    .topbar .spacer{flex:1}
    .pill{
      padding:7px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.05);
      color:var(--muted); font-size:12px;
      display:flex; gap:8px; align-items:center; white-space:nowrap;
    }
    .dot{width:8px;height:8px;border-radius:50%}
    .dot.good{background:var(--good)}
    .dot.bad{background:var(--bad)}
    .dot.neu{background:#7c8fb7}

    /* Sidebar */
    .overlay{
      position:fixed; inset:0;
      background:rgba(0,0,0,.55);
      opacity:0; pointer-events:none;
      transition:opacity .18s ease;
      z-index:40;
    }
    .overlay.show{opacity:1; pointer-events:auto}
    .sidebar{
      position:fixed; top:0; left:0; bottom:0;
      width:min(82vw, 320px);
      background:linear-gradient(180deg,#0b1220 0%, #0b1220 40%, #0a1020 100%);
      border-right:1px solid rgba(255,255,255,.08);
      transform:translateX(-105%);
      transition:transform .22s ease;
      z-index:50;
      padding:14px;
      box-shadow: var(--shadow);
      display:flex; flex-direction:column; gap:10px;
    }
    .sidebar.show{transform:translateX(0)}
    .sideHeader{display:flex; align-items:center; justify-content:space-between; margin-bottom:8px}
    .sideHeader b{font-size:14px}
    .closeBtn{
      width:38px;height:38px;border-radius:12px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(255,255,255,.04);
      color:var(--text); cursor:pointer;
    }
    .nav{display:flex; flex-direction:column; gap:8px; padding-top:6px}
    .nav button{
      text-align:left; padding:12px 12px; border-radius:14px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(255,255,255,.04);
      color:var(--text); cursor:pointer;
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; font-size:14px;
    }
    .nav button.active{border-color:rgba(90,169,255,.55); background:rgba(90,169,255,.12)}
    .nav button small{color:var(--muted); font-size:12px}
    .sideFooter{
      margin-top:auto;
      border-top:1px solid rgba(255,255,255,.08);
      padding-top:12px;
      color:var(--muted); font-size:12px; line-height:1.4;
    }

    /* Main */
    .main{padding:16px 14px 28px; max-width:1050px; margin:0 auto}
    .page{display:none}
    .page.active{display:block}
    h1{font-size:18px; margin:0 0 10px}
    h2{font-size:14px; margin:14px 0 8px; color:var(--text)}
    .muted{color:var(--muted)}
    .mono{font-family:var(--mono)}

    .grid{display:grid; grid-template-columns:1fr; gap:12px}
    @media (min-width:900px){
      .grid.two{grid-template-columns:1fr 1fr}
      .grid.three{grid-template-columns:1fr 1fr 1fr}
      .grid.leftwide{grid-template-columns:1.2fr .8fr}
    }
    .card{
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      padding:12px;
      box-shadow: 0 6px 18px rgba(0,0,0,.18);
    }
    .cardHeader{display:flex; align-items:flex-start; justify-content:space-between; gap:12px; margin-bottom:8px}
    .cardHeader b{font-size:14px}
    .cardHeader small{color:var(--muted)}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .btn{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:9px 11px;
      border-radius:12px;
      cursor:pointer;
      font-weight:650;
      font-size:13px;
    }
    .btn.primary{border-color:rgba(90,169,255,.55); background:rgba(90,169,255,.14)}
    .btn.danger{border-color:rgba(255,77,79,.55); background:rgba(255,77,79,.12)}
    .btn.good{border-color:rgba(25,195,125,.55); background:rgba(25,195,125,.12)}
    .btn:active{transform:scale(.99)}
    .btn:disabled{opacity:.5; cursor:not-allowed}

    input, textarea, select{
      width:100%;
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.10);
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      outline:none;
      font-family:var(--sans);
      font-size:14px;
    }
    textarea{min-height:150px; font-family:var(--mono); font-size:12.5px; line-height:1.35}
    label{display:block; color:var(--muted); font-size:12px; margin:10px 0 6px}
    .help{color:var(--muted); font-size:12px; line-height:1.35}
    .warnLine{color:var(--warn); font-size:12px; margin-top:8px}
    .okLine{color:var(--good); font-size:12px; margin-top:8px}
    .errLine{color:var(--bad); font-size:12px; margin-top:8px}

    .banner{
      border-radius:14px;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.04);
      margin-bottom:10px;
    }
    .banner.good{border-color:rgba(25,195,125,.55); background:rgba(25,195,125,.12)}
    .banner.bad{border-color:rgba(255,77,79,.55); background:rgba(255,77,79,.12)}
    .banner b{display:block; margin-bottom:2px; font-size:13px}
    .banner small{color:var(--muted); font-size:12px}

    .badge{
      display:inline-flex; align-items:center; gap:6px;
      padding:5px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.04);
      font-size:12px; color:var(--muted);
      white-space:nowrap;
    }
    .badge.win{border-color:rgba(25,195,125,.55); color:rgba(25,195,125,.95); background:rgba(25,195,125,.10)}
    .badge.loss{border-color:rgba(255,77,79,.55); color:rgba(255,77,79,.95); background:rgba(255,77,79,.10)}
    .badge.pending{border-color:rgba(255,209,102,.55); color:rgba(255,209,102,.95); background:rgba(255,209,102,.10)}
    .badge.neutral{border-color:rgba(124,143,183,.55); color:rgba(159,176,208,.95); background:rgba(124,143,183,.10)}

    /* Compact ‚ÄúLivePick-like‚Äù toggles */
    .seg{
      display:inline-flex; gap:6px; flex-wrap:wrap;
      padding:6px; border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
    }
    .seg button{
      padding:7px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(255,255,255,.03);
      color:var(--muted);
      cursor:pointer;
      font-weight:650;
      font-size:12px;
    }
    .seg button.active{
      border-color:rgba(90,169,255,.55);
      background:rgba(90,169,255,.14);
      color:var(--text);
    }

    /* History card list */
    .list{display:flex; flex-direction:column; gap:10px}
    .betCard{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      border-radius:14px;
      padding:10px 10px;
    }
    .betTop{
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
    }
    .betTopLeft{min-width:0}
    .betTopLeft .t1{
      display:flex; gap:8px; flex-wrap:wrap; align-items:center;
      font-size:13px; font-weight:700;
    }
    .betTopLeft .t1 .date{color:rgba(232,238,252,.92)}
    .betTopLeft .t1 .method{color:var(--muted); font-weight:650}
    .betTopLeft .t2{
      margin-top:4px;
      color:rgba(232,238,252,.92);
      font-size:13px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .betMid{
      margin-top:8px;
      display:flex; flex-wrap:wrap; gap:10px;
      align-items:center;
    }
    .chip{
      padding:6px 8px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      font-size:12px;
      color:var(--muted);
      display:flex; gap:6px; align-items:center;
    }
    .chip b{color:var(--text); font-size:12px}
    .chip.good b{color:rgba(25,195,125,.95)}
    .chip.bad b{color:rgba(255,77,79,.95)}
    .chip.warn b{color:rgba(255,209,102,.95)}
    .betActions{
      margin-top:10px;
      display:flex; gap:8px; flex-wrap:wrap;
    }
    .miniBtn{
      padding:7px 10px;
      border-radius:12px;
      font-weight:650;
      font-size:12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.04);
      color:var(--text);
      cursor:pointer;
    }
    .miniBtn.primary{border-color:rgba(90,169,255,.55); background:rgba(90,169,255,.14)}
    .miniBtn.danger{border-color:rgba(255,77,79,.55); background:rgba(255,77,79,.12)}

    /* Inline edit fields */
    .inlineEdit{
      display:inline-block;
      padding:2px 6px;
      border-radius:10px;
      border:1px dashed rgba(255,255,255,.14);
      cursor:pointer;
      user-select:none;
    }
    .inlineEdit:hover{border-color:rgba(90,169,255,.45)}
    .inlineEdit input{
      width:auto;
      min-width:90px;
      padding:6px 8px;
      border-radius:10px;
      font-size:12px;
    }
    .inlineSelect{
      width:auto;
      padding:6px 8px;
      border-radius:10px;
      font-size:12px;
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.10);
      color:var(--text);
    }

    /* Charts */
    .chartWrap{display:flex; flex-direction:column; gap:10px}
    .chartRow{display:grid; grid-template-columns:1fr; gap:12px; align-items:start}
    @media (min-width:900px){
      .chartRow{grid-template-columns:.9fr 1.1fr}
    }
    canvas{width:100%; height:auto; border-radius:14px;}
    .kpiRow{display:flex; flex-wrap:wrap; gap:10px}
    .kpi{
      min-width:140px;
      padding:8px 10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
    }
    .kpi span{display:block; color:var(--muted); font-size:12px}
    .kpi b{display:block; font-size:14px; margin-top:2px}
    .kpi b.good{color:rgba(25,195,125,.95)}
    .kpi b.bad{color:rgba(255,77,79,.95)}

    /* Details list */
    .detailsList{display:flex; flex-direction:column; gap:10px}
    .section{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      border-radius:14px;
      padding:10px;
    }
    .sectionTitle{font-weight:750; font-size:13px; margin-bottom:8px}
    .kvList{display:flex; flex-direction:column; gap:6px}
    .kvItem{display:flex; justify-content:space-between; gap:10px; font-size:12px}
    .kvItem .k{color:var(--muted)}
    .kvItem .v{color:var(--text); font-family:var(--mono); text-align:right; overflow-wrap:anywhere}

    table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      overflow:hidden;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
    }
    th, td{
      padding:10px 10px;
      border-bottom:1px solid rgba(255,255,255,.08);
      text-align:left;
      font-size:13px;
      vertical-align:top;
    }
    th{color:var(--muted); font-weight:700; background:rgba(255,255,255,.03)}
    tr:last-child td{border-bottom:none}
  </style>
</head>

<body>
  <div class="topbar">
    <div class="hamburger" id="hamburger" aria-label="Apri menu" title="Menu"><span></span></div>
    <div class="brand">
      <b>BetTools</b>
      <small>V3 ‚Ä¢ NEXT ‚Ä¢ Stake v1 ‚Ä¢ UI v1.1</small>
    </div>
    <div class="spacer"></div>
    <div class="pill" id="pillDaily">
      <span class="dot neu" id="pillDot"></span>
      <span id="pillText">Giornata: neutra</span>
    </div>
  </div>

  <div class="overlay" id="overlay"></div>

  <aside class="sidebar" id="sidebar" aria-label="Menu laterale">
    <div class="sideHeader">
      <b>Menu</b>
      <button class="closeBtn" id="closeSidebar" aria-label="Chiudi menu">‚úï</button>
    </div>
    <div class="nav" id="nav">
      <button data-page="calc" class="active">üßÆ Calcolatore <small>LivePick V3</small></button>
      <button data-page="storico">üìí Storico <small>Mini-card</small></button>
      <button data-page="dash">üìä Dashboard <small>Grafici</small></button>
      <button data-page="time">üóìÔ∏è Riepilogo temporale <small>G/W/M</small></button>
      <button data-page="filters">üßæ Riepilogo per filtri <small>ROI</small></button>
    </div>

    <div class="sideFooter">
      <div><b class="mono">Notifica V3</b></div>
      <div>Parser robusto: a capo/spazi ok. NEXT: soglia dipende solo dalla line.</div>
    </div>
  </aside>

  <main class="main">
    <!-- CALCOLATORE -->
    <section class="page active" id="page-calc">
      <h1>Calcolatore</h1>
      <div id="dailyBannerWrap"></div>

      <div class="grid leftwide">
        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Notifica LivePick (V3)</b><br/>
              <small>NEXT: la PROB usata dipende solo da Phase e Line (x.5 ‚áí + (x+1)).</small>
            </div>
          </div>

          <label for="lpText">Incolla notifica</label>
          <textarea id="lpText" spellcheck="false" placeholder="Incolla qui la notifica..."></textarea>

          <div class="row" style="margin-top:10px">
            <button class="btn primary" id="btnParse">Parse</button>
            <button class="btn" id="btnClear">Pulisci</button>
            <button class="btn danger" id="btnResetAll">Reset totale</button>
          </div>

          <div id="parseMsg" class="help" style="margin-top:10px"></div>
        </div>

        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Stake v1</b><br/>
              <small>Min 2% ‚Ä¢ Max 5% ‚Ä¢ BR giornaliero fisso.</small>
            </div>
          </div>

          <div class="grid two">
            <div>
              <label>Bankroll attuale</label>
              <input id="bankrollInput" type="number" min="0" step="0.01" />
              <div class="help">Snapshot giornaliero creato al primo ‚ÄúAggiungi a storico‚Äù.</div>
            </div>
            <div>
              <label>Bankroll giornaliero (oggi)</label>
              <input id="bankrollDay" type="text" disabled />
            </div>
          </div>

          <div style="margin-top:10px" id="previewWrap" class="help">Nessun parse ancora.</div>

          <div class="grid two" style="margin-top:10px">
            <div>
              <label>Quota reale giocata (dopo)</label>
              <input id="oddsPlayed" type="number" min="1" step="0.01" placeholder="es: 1.40" />
            </div>
            <div>
              <label>Stake reale giocato (dopo)</label>
              <input id="stakePlayed" type="number" min="0" step="0.01" placeholder="es: 30" />
            </div>
          </div>

          <div class="row" style="margin-top:10px">
            <button class="btn good" id="btnAddToHistory" disabled>‚ûï Aggiungi a storico</button>
          </div>

          <div class="help" style="margin-top:10px">
            Esito e correzioni in <b>Storico</b>. Pending/Non giocata non vengono conteggiate.
          </div>
        </div>
      </div>
    </section>

    <!-- STORICO -->
    <section class="page" id="page-storico">
      <h1>Storico</h1>

      <!-- FILTERS ON TOP (LivePick-like) -->
      <div class="card">
        <div class="cardHeader">
          <div>
            <b>Filtri</b><br/>
            <small>Pending/Non giocata non conteggiate.</small>
          </div>
          <div class="row">
            <select id="historyResultFilter" style="width:auto; min-width:160px">
              <option value="all">Tutte</option>
              <option value="win">Vinte</option>
              <option value="loss">Perse</option>
              <option value="pending">Pending</option>
              <option value="not_played">Non giocate</option>
            </select>
            <select id="historyDateFilter" style="width:auto; min-width:160px">
              <option value="all">Tutto</option>
              <option value="today">Oggi</option>
              <option value="yesterday">Ieri</option>
              <option value="week">Settimana corrente</option>
              <option value="month">Mese corrente</option>
            </select>
          </div>
        </div>

        <div id="historyList" class="list"></div>
        <div id="historyEmpty" class="help"></div>
      </div>

      <div class="grid two" style="margin-top:12px">
        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Dettagli bet</b><br/>
              <small>Vista leggibile per sezioni (no JSON di default).</small>
            </div>
            <div class="row">
              <button class="btn" id="btnToggleRaw" disabled>Mostra JSON raw</button>
            </div>
          </div>
          <div id="detailsBox" class="help">Seleziona ‚ÄúDettagli‚Äù su una bet.</div>
        </div>

        <!-- moved to bottom as requested -->
        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Backup / Restore</b><br/>
              <small>JSON completo (storico + impostazioni).</small>
            </div>
          </div>

          <div class="row">
            <button class="btn primary" id="btnBackup">‚¨áÔ∏è Backup</button>
            <label class="btn" style="cursor:pointer">
              ‚¨ÜÔ∏è Restore
              <input type="file" id="restoreFile" accept="application/json" style="display:none"/>
            </label>
          </div>

          <div class="row" style="margin-top:10px">
            <button class="btn danger" id="btnClearHistory">Svuota storico</button>
            <button class="btn" id="btnRecalc">Ricalcola</button>
          </div>

          <div class="help" style="margin-top:10px" id="backupMsg"></div>
        </div>
      </div>
    </section>

    <!-- DASHBOARD -->
    <section class="page" id="page-dash">
      <h1>Dashboard</h1>

      <div class="card">
        <div class="cardHeader">
          <div>
            <b>Filtro periodo</b><br/>
            <small>Influenza KPI e grafici.</small>
          </div>
          <div class="seg" id="dashRangeSeg">
            <button data-range="all" class="active">Tutto</button>
            <button data-range="today">Oggi</button>
            <button data-range="yesterday">Ieri</button>
            <button data-range="week">Settimana</button>
            <button data-range="month">Mese</button>
          </div>
        </div>

        <div class="kpiRow" id="dashKpis"></div>
      </div>

      <div class="chartRow" style="margin-top:12px">
        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Win Rate</b><br/>
              <small>Solo bet chiuse.</small>
            </div>
          </div>
          <canvas id="donut" width="520" height="360"></canvas>
          <div class="row" style="margin-top:8px; justify-content:space-between">
            <div class="badge win" id="wonLabel">Won: ‚Äî</div>
            <div class="badge loss" id="lostLabel">Lost: ‚Äî</div>
          </div>
        </div>

        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Profit Chart</b><br/>
              <small>Cumulato bet chiuse.</small>
            </div>
            <div class="seg" id="profitRangeSeg">
              <button data-pr="1m" class="active">1m</button>
              <button data-pr="6m">6m</button>
              <button data-pr="12m">12m</button>
              <button data-pr="all">all</button>
            </div>
          </div>
          <canvas id="profitChart" width="820" height="360"></canvas>
          <div class="help" style="margin-top:8px">Linea = profitto cumulato. Area sotto lo zero evidenziata.</div>
        </div>
      </div>

      <!-- moved bankroll to bottom as requested -->
      <div class="card" style="margin-top:12px">
        <div class="cardHeader">
          <div>
            <b>Impostazioni Bankroll</b><br/>
            <small>Usato per stake e snapshot giornaliero.</small>
          </div>
        </div>
        <div class="grid two">
          <div>
            <label>Bankroll attuale</label>
            <input id="bankrollInputDash" type="number" min="0" step="0.01" />
          </div>
          <div>
            <label>Azioni</label>
            <div class="row">
              <button class="btn primary" id="btnSaveBR">Salva bankroll</button>
              <button class="btn" id="btnNewDay">Nuova giornata</button>
            </div>
          </div>
        </div>
        <div class="help" id="dashMsg" style="margin-top:8px"></div>
      </div>
    </section>

    <!-- TIME SUMMARY -->
    <section class="page" id="page-time">
      <h1>Riepilogo temporale</h1>

      <div class="card">
        <div class="cardHeader">
          <div>
            <b>Raggruppa</b><br/>
            <small>Profit/ROI colorati + target/stop del periodo.</small>
          </div>
          <div class="seg" id="timeGroupSeg">
            <button data-tg="day" class="active">Giorni</button>
            <button data-tg="week">Settimane</button>
            <button data-tg="month">Mesi</button>
          </div>
        </div>

        <div class="help" id="timeEmpty"></div>
        <div style="overflow:auto">
          <table id="timeTable" style="display:none">
            <thead>
              <tr>
                <th>Periodo</th>
                <th>Bet</th>
                <th>Winrate</th>
                <th>Profitto</th>
                <th>ROI</th>
                <th>Stato</th>
              </tr>
            </thead>
            <tbody id="timeBody"></tbody>
          </table>
        </div>
      </div>
    </section>

    <!-- FILTER SUMMARY -->
    <section class="page" id="page-filters">
      <h1>Riepilogo per filtri</h1>

      <div class="card">
        <div class="cardHeader">
          <div>
            <b>Ordinamento</b><br/>
            <small>Default ROI (migliore ‚Üí peggiore).</small>
          </div>
          <div class="row">
            <select id="filterSort" style="width:auto; min-width:220px">
              <option value="roi" selected>Ordina: ROI</option>
              <option value="profit">Ordina: Profitto</option>
              <option value="winrate">Ordina: % Vinte</option>
              <option value="bets">Ordina: Bet giocate</option>
              <option value="name">Ordina: Tipo scommessa</option>
            </select>
          </div>
        </div>
        <div class="row" id="filtersMetaRow"></div>
        <div class="warnLine" id="filtersNotes"></div>
      </div>

      <div class="grid two" id="filtersGrid" style="margin-top:12px"></div>
    </section>
  </main>

<script>
/* =========================
   State
========================= */
const STORAGE_KEY = "bettools_v3_uiv11";
const DEFAULT_STATE = {
  version: "V3_SIMPLIFIED_UI11",
  settings: { bankroll: 1000 },
  dailySnapshot: { date: null, bankroll: null },
  history: []
};

function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return structuredClone(DEFAULT_STATE);
    const st = JSON.parse(raw);
    if(!st.settings) st.settings = structuredClone(DEFAULT_STATE.settings);
    if(!st.dailySnapshot) st.dailySnapshot = structuredClone(DEFAULT_STATE.dailySnapshot);
    if(!Array.isArray(st.history)) st.history = [];
    return st;
  }catch(e){
    return structuredClone(DEFAULT_STATE);
  }
}
function saveState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
function resetAll(){
  localStorage.removeItem(STORAGE_KEY);
  state = structuredClone(DEFAULT_STATE);
  saveState();
  renderAll();
}
let state = loadState();

/* =========================
   Utils
========================= */
function todayISO(){
  const d = new Date();
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth()+1).padStart(2,"0");
  const dd = String(d.getDate()).padStart(2,"0");
  return `${yyyy}-${mm}-${dd}`;
}
function yesterdayISO(){
  const d = new Date();
  d.setDate(d.getDate()-1);
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth()+1).padStart(2,"0");
  const dd = String(d.getDate()).padStart(2,"0");
  return `${yyyy}-${mm}-${dd}`;
}
function fmtMoney(x){
  if(x === null || x === undefined || Number.isNaN(Number(x))) return "‚Äî";
  return Number(x).toLocaleString("it-IT",{minimumFractionDigits:2, maximumFractionDigits:2});
}
function fmtPct(x){
  if(x === null || x === undefined || Number.isNaN(Number(x))) return "‚Äî";
  return (Number(x)*100).toLocaleString("it-IT",{minimumFractionDigits:2, maximumFractionDigits:2}) + "%";
}
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
function safeNum(v){
  if(v === null || v === undefined) return null;
  const s = String(v).trim();
  if(s.toLowerCase()==="null" || s==="") return null;
  const n = Number(s.replace(",", "."));
  return Number.isFinite(n) ? n : null;
}
function sum(arr){ return arr.reduce((a,b)=>a+(Number(b)||0),0); }
function escapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
function startOfWeekISO(dISO){
  // Monday as start (ISO week-ish)
  const d = new Date(dISO+"T00:00:00");
  const day = (d.getDay()+6)%7; // Mon=0 .. Sun=6
  d.setDate(d.getDate()-day);
  return d.toISOString().slice(0,10);
}
function monthKey(dISO){ return dISO.slice(0,7); } // YYYY-MM

function inDateRange(dISO, range){
  if(range==="all") return true;
  const d = new Date(dISO+"T00:00:00");
  const t = todayISO();
  if(range==="today") return dISO===t;
  if(range==="yesterday") return dISO===yesterdayISO();
  if(range==="week"){
    const sow = startOfWeekISO(t);
    return dISO >= sow && dISO <= t;
  }
  if(range==="month"){
    const ym = t.slice(0,7);
    return dISO.slice(0,7)===ym;
  }
  return true;
}
function inMonthsBack(dISO, months){
  const d = new Date(dISO+"T00:00:00");
  const now = new Date();
  const cutoff = new Date(now);
  cutoff.setMonth(cutoff.getMonth()-months);
  return d >= cutoff;
}

/* =========================
   Navigation
========================= */
const overlay = document.getElementById("overlay");
const sidebar = document.getElementById("sidebar");
document.getElementById("hamburger").addEventListener("click", ()=>{
  sidebar.classList.add("show"); overlay.classList.add("show");
});
document.getElementById("closeSidebar").addEventListener("click", closeSidebar);
overlay.addEventListener("click", closeSidebar);
function closeSidebar(){
  sidebar.classList.remove("show"); overlay.classList.remove("show");
}
document.getElementById("nav").addEventListener("click",(e)=>{
  const btn = e.target.closest("button[data-page]");
  if(!btn) return;
  setPage(btn.getAttribute("data-page"));
  closeSidebar();
});
function setPage(page){
  document.querySelectorAll(".page").forEach(p=>p.classList.remove("active"));
  document.getElementById("page-"+page).classList.add("active");
  document.querySelectorAll("#nav button").forEach(b=>b.classList.remove("active"));
  const active = document.querySelector(`#nav button[data-page="${page}"]`);
  if(active) active.classList.add("active");

  if(page==="storico") renderHistory();
  if(page==="dash") renderDashboard();
  if(page==="time") renderTimeSummary();
  if(page==="filters") renderFilters();
}

/* =========================
   Parser V3 (same tags as before)
========================= */
const TAGS = ["META","STATE","STATS","L10","PROB","PRESS","LATE","ODDS_TO_BET","LP"];
function normalizeText(s){
  return String(s || "")
    .replace(/\r/g,"\n")
    .replace(/[ \t]+/g," ")
    .replace(/\n+/g,"\n");
}
function extractBlocks(text){
  const t = normalizeText(text);
  const hits = [];
  const scanRe = new RegExp(`\\b(${TAGS.join("|")})\\s*\\|`, "g");
  let m;
  while((m=scanRe.exec(t))!==null){
    hits.push({tag:m[1], idx:m.index});
  }
  hits.sort((a,b)=>a.idx-b.idx);
  const blocks = {};
  for(let i=0;i<hits.length;i++){
    const start = hits[i].idx;
    const end = (i+1<hits.length) ? hits[i+1].idx : t.length;
    blocks[hits[i].tag] = t.slice(start, end).trim();
  }
  return blocks;
}
function parsePipeKVs(chunk){
  const parts = chunk.split("|").map(x=>x.trim()).filter(Boolean);
  const kvs = {};
  for(let i=1;i<parts.length;i++){
    const p = parts[i];
    const eq = p.indexOf("=");
    if(eq===-1) continue;
    const k = p.slice(0,eq).trim();
    const v = p.slice(eq+1).trim();
    kvs[k] = v;
  }
  return kvs;
}
function parseScore(s){
  if(!s) return {home:null, away:null};
  const m = String(s).match(/(\d+)\s*-\s*(\d+)/);
  if(!m) return {home:null, away:null};
  return {home:Number(m[1]), away:Number(m[2])};
}
function parseHA(s){
  if(!s) return {home:null, away:null};
  const m = String(s).match(/(-?\d+(\.\d+)?)\s*[/\-]\s*(-?\d+(\.\d+)?)/);
  if(!m) return {home:null, away:null};
  return {home:safeNum(m[1]), away:safeNum(m[3])};
}
function parsePROB(chunk){
  const out = {HT:{}, FT:{}};
  const ht = chunk.match(/HT\s*\(([^)]*)\)/i);
  const ft = chunk.match(/FT\s*\(([^)]*)\)/i);
  if(ht){
    ht[1].split(",").forEach(pair=>{
      const m = pair.match(/\+(\d+)\s*=\s*([0-9.,-]+)/);
      if(m) out.HT[Number(m[1])] = safeNum(m[2]);
    });
  }
  if(ft){
    ft[1].split(",").forEach(pair=>{
      const m = pair.match(/\+(\d+)\s*=\s*([0-9.,-]+)/);
      if(m) out.FT[Number(m[1])] = safeNum(m[2]);
    });
  }
  return out;
}
function parsePRESS(chunk){
  const out = {
    GPI: {M_all:null, M_l10:null},
    GMS: {H_all:null,H_l10:null, A_all:null,A_l10:null, M_all:null,M_l10:null},
    SI:  {M_all:null, M_l10:null}
  };
  const gpi = chunk.match(/GPI\s*\(\s*M\s*=\s*([0-9.,-]+)\s*,\s*L10\s*=\s*([0-9.,-]+)\s*\)/i);
  if(gpi){ out.GPI.M_all=safeNum(gpi[1]); out.GPI.M_l10=safeNum(gpi[2]); }
  const gms = chunk.match(/GMS\s*\(\s*H\s*=\s*([0-9.,-]+)\s*\/\s*([0-9.,-]+)\s*,\s*A\s*=\s*([0-9.,-]+)\s*\/\s*([0-9.,-]+)\s*,\s*M\s*=\s*([0-9.,-]+)\s*\/\s*([0-9.,-]+)\s*\)/i);
  if(gms){
    out.GMS.H_all=safeNum(gms[1]); out.GMS.H_l10=safeNum(gms[2]);
    out.GMS.A_all=safeNum(gms[3]); out.GMS.A_l10=safeNum(gms[4]);
    out.GMS.M_all=safeNum(gms[5]); out.GMS.M_l10=safeNum(gms[6]);
  }
  const si = chunk.match(/SI\s*\(\s*M\s*=\s*([0-9.,-]+)\s*\/\s*([0-9.,-]+)\s*\)/i);
  if(si){ out.SI.M_all=safeNum(si[1]); out.SI.M_l10=safeNum(si[2]); }
  return out;
}
function parseLATE(chunk){
  const kv = parsePipeKVs(chunk);
  return { AT:safeNum(kv.AT), L10:safeNum(kv.L10), L5:safeNum(kv.L5) };
}
function parseODDSTOBET(chunk){
  const m = chunk.match(/ODDS_TO_BET\s*\|\s*(.+?)\s*[:=]\s*([0-9.,]+)/i);
  if(!m) return null;
  const label = m[1].trim().replace(/\s+/g," ");
  const odds = safeNum(m[2]);
  const ph = label.match(/\b(HT|FT)\b/i);
  const phase = ph ? ph[1].toUpperCase() : null;
  const lineM = label.match(/([0-9]+(\.[0-9]+)?)\b/);
  const line = lineM ? safeNum(lineM[1]) : null;
  let market = label;
  if(phase) market = market.replace(new RegExp("\\b"+phase+"\\b","i"),"").trim();
  if(line !== null) market = market.replace(new RegExp(String(line).replace(".","\\.")),"").trim();
  market = market.replace(/\s+/g," ").trim();
  return { label, phase, market, line, odds_ref: odds };
}
function parseLP(chunk){
  // IMPORTANT: per tua regola, WR/ROI arrivano SEMPRE come percentuali => sempre /100
  const kv = parsePipeKVs(chunk);
  const wr = safeNum(kv.WR);
  const roi = safeNum(kv.ROI);
  return {
    WR: wr===null ? null : wr/100,
    ROI: roi===null ? null : roi/100,
    Profit: safeNum(kv.Profit),
    AO: safeNum(kv.AO),
    N: safeNum(kv.N)
  };
}
function parseStatsLine(chunk){
  const kv = parsePipeKVs(chunk);
  return { SOT:parseHA(kv.SOT), SOFF:parseHA(kv.SOFF), COR:parseHA(kv.COR), ATT:parseHA(kv.ATT), DATT:parseHA(kv.DATT) };
}
function parseMETA(chunk){
  const kv = parsePipeKVs(chunk);
  return { Ver:(kv.Ver||"").trim(), Method:(kv.Method||"").trim(), Comp:(kv.Comp||"").trim(), Match:(kv.Match||"").trim() };
}
function parseSTATE(chunk){
  const kv = parsePipeKVs(chunk);
  const sc = parseScore(kv.Score);
  const remht = safeNum(kv.RemHT);
  return {
    Time: safeNum(kv.Time),
    RemHT: remht!==null && remht<0 ? 0 : remht,
    RemFT: safeNum(kv.RemFT),
    ScoreHome: sc.home,
    ScoreAway: sc.away,
    ScoreRaw: kv.Score ? String(kv.Score).trim() : ""
  };
}
function parseNotification(text){
  const blocks = extractBlocks(text);
  const errors = [];
  const warnings = [];
  const required = ["META","STATE","PROB","ODDS_TO_BET","LP"];
  for(const r of required){ if(!blocks[r]) errors.push(`Manca blocco: ${r}`); }
  if(errors.length) return {ok:false, errors, warnings, data:null};

  const meta = parseMETA(blocks.META);
  const stateObj = parseSTATE(blocks.STATE);
  const prob = parsePROB(blocks.PROB);
  const oddsToBet = parseODDSTOBET(blocks.ODDS_TO_BET);
  const lp = parseLP(blocks.LP);

  const stats = blocks.STATS ? parseStatsLine(blocks.STATS) : null;
  const l10 = blocks.L10 ? parseStatsLine(blocks.L10) : null;
  const press = blocks.PRESS ? parsePRESS(blocks.PRESS) : null;
  const late = blocks.LATE ? parseLATE(blocks.LATE) : null;

  if(!oddsToBet || oddsToBet.odds_ref===null) errors.push("ODDS_TO_BET non parsabile (serve: '... = 1.45')");
  if(!oddsToBet?.phase) warnings.push("ODDS_TO_BET: Phase (HT/FT) non rilevata");
  if(oddsToBet?.line===null) warnings.push("ODDS_TO_BET: Line non rilevata (es 1.5)");
  if(lp.WR===null) warnings.push("LP.WR mancante");
  if(lp.ROI===null) warnings.push("LP.ROI mancante");
  if(errors.length) return {ok:false, errors, warnings, data:null};

  // Basic sanity: prob values in [0,1] (do not fail, just warn)
  const checkProb = (obj, label)=>{
    for(const k of Object.keys(obj)){
      const v = obj[k];
      if(v!==null && (v<0 || v>1)) warnings.push(`PROB ${label}(+${k}) fuori range (0-1): ${v}`);
    }
  };
  checkProb(prob.HT,"HT"); checkProb(prob.FT,"FT");

  return { ok:true, errors:[], warnings, data:{
    meta, state:stateObj, stats, l10, prob, press, late, oddsToBet, lp,
    raw: normalizeText(text)
  }};
}

/* =========================
   Stake v1 (NEXT logic)
========================= */
function betKeyFromParsed(parsed){
  const m = parsed.meta.Method || "";
  const phase = parsed.oddsToBet.phase || "";
  const market = parsed.oddsToBet.market || parsed.oddsToBet.label || "";
  const line = parsed.oddsToBet.line;
  return `${m}||${phase}||${market}||${line ?? ""}`.trim();
}
function neededGoalsFromLine_NEXT(line){
  // NEXT Over x.5 => need (x+1) goals from now. x.5 => integer.
  if(line===null) return null;
  return Math.floor(line) + 1; // 1.5->2, 2.5->3, 0.5->1
}
function pickMatchProbability_NEXT(parsed){
  const phase = parsed.oddsToBet.phase;
  const line = parsed.oddsToBet.line;
  if(!phase || line===null) return {p:null, needed:null, reason:"Phase o Line non disponibili"};
  const needed = neededGoalsFromLine_NEXT(line);
  const table = (phase==="HT") ? parsed.prob.HT : parsed.prob.FT;
  const p = table ? table[needed] : null;
  if(p === undefined || p === null) return {p:null, needed, reason:`Manca PROB ${phase}(+${needed})`};
  return {p, needed, reason:null};
}
function getArchiveStatsForKey(key){
  const closed = state.history.filter(b => b.key===key && (b.result==="win" || b.result==="loss"));
  const N = closed.length;
  if(N===0) return {N:0, winrate:null};
  const wins = closed.filter(b=>b.result==="win").length;
  return {N, winrate: wins/N};
}
function calcStakeV1(parsed){
  const key = betKeyFromParsed(parsed);
  const odds = parsed.oddsToBet.odds_ref;
  const lpWR = parsed.lp.WR; // already converted to 0-1 always

  const matchP = pickMatchProbability_NEXT(parsed);
  const P_MATCH = matchP.p;
  const arch = getArchiveStatsForKey(key);
  const P_ARCH = arch.winrate;
  const N = arch.N;

  const warnings = [];
  if(odds===null || odds<=1) return {ok:false, reason:"Quota ODDS_TO_BET non valida", warnings, key};
  if(P_MATCH===null) warnings.push(matchP.reason || "Prob match non disponibile");
  if(lpWR===null) warnings.push("LP.WR non disponibile");
  if(P_ARCH===null) warnings.push("Archivio: nessuna bet chiusa per questo filtro (N=0)");

  if(P_MATCH===null && lpWR===null && P_ARCH===null){
    return {ok:false, reason:"Impossibile calcolare P_REF (mancano probabilit√†)", warnings, key};
  }

  let P_REF=null, source="LP/MATCH";
  if(N < 50){
    if(lpWR!==null && P_MATCH!==null) P_REF = 0.6*lpWR + 0.4*P_MATCH;
    else P_REF = (lpWR!==null) ? lpWR : P_MATCH;
  }else{
    source="ARCH/MATCH";
    if(P_ARCH!==null && P_MATCH!==null) P_REF = 0.6*P_ARCH + 0.4*P_MATCH;
    else P_REF = (P_ARCH!==null) ? P_ARCH : P_MATCH;
  }
  if(N>=30 && N<70){
    const w=(N-30)/40;
    const left = (lpWR!==null && P_MATCH!==null) ? (0.6*lpWR + 0.4*P_MATCH) : ((lpWR!==null)?lpWR:P_MATCH);
    const right = (P_ARCH!==null && P_MATCH!==null) ? (0.6*P_ARCH + 0.4*P_MATCH) : ((P_ARCH!==null)?P_ARCH:P_MATCH);
    P_REF = (1-w)*left + w*right;
    source="BLEND";
  }

  const implied = 1/odds;
  const edge = (P_REF!==null) ? (P_REF - implied) : null;

  if(P_REF===null || edge===null || edge<=0){
    return {ok:true, key, source, N_archive:N, P_REF, implied, edge, kelly:0, stake_pct:0, stake_amount:0, no_bet:true, warnings};
  }

  const kelly = edge / (odds - 1);
  let kAdj = 0.5 * kelly;
  let stakePct = clamp(kAdj, 0.02, 0.05);

  if(N < 50 && stakePct >= 0.05){
    stakePct = 0.04;
    warnings.push("N<50: cap stake al 4% (mai massimo stake)");
  }
  if(parsed.lp.N!==null && parsed.lp.N < 500){
    stakePct *= 0.8;
    stakePct = Math.max(stakePct, 0.02);
    warnings.push("LP.N<500: stake ridotto del 20%");
  }

  return {ok:true, key, source, N_archive:N, P_REF, implied, edge, kelly, stake_pct:stakePct, stake_amount:null, no_bet:false, warnings, needed_goals: matchP.needed};
}

/* =========================
   Daily snapshot & PnL
========================= */
function ensureDailySnapshot(){
  const t = todayISO();
  if(state.dailySnapshot.date !== t || state.dailySnapshot.bankroll === null){
    state.dailySnapshot.date = t;
    state.dailySnapshot.bankroll = Number(state.settings.bankroll || 0);
    saveState();
  }
}
function getTodayClosedPnL(){
  const t = todayISO();
  const brDay = (state.dailySnapshot.date===t) ? Number(state.dailySnapshot.bankroll || 0) : null;
  const todays = state.history.filter(b=>b.date===t && (b.result==="win" || b.result==="loss"));
  const profit = sum(todays.map(b=>b.profit_real));
  const pct = (brDay && brDay>0) ? (profit/brDay) : null;
  return {profit, pct, brDay, closedCount:todays.length};
}
function updateDailyPill(){
  const pillDot=document.getElementById("pillDot");
  const pillText=document.getElementById("pillText");
  const info=getTodayClosedPnL();
  if(info.brDay===null){
    pillDot.className="dot neu"; pillText.textContent="Giornata: neutra"; return;
  }
  if(info.pct!==null && info.pct>=0.03){
    pillDot.className="dot good"; pillText.textContent="Target profit raggiunto";
  }else if(info.pct!==null && info.pct<=-0.10){
    pillDot.className="dot bad"; pillText.textContent="Stop loss raggiunto";
  }else{
    pillDot.className="dot neu"; pillText.textContent="Giornata: neutra";
  }
}
function renderDailyBanner(){
  const wrap=document.getElementById("dailyBannerWrap");
  const info=getTodayClosedPnL();
  wrap.innerHTML="";
  if(info.brDay===null){
    wrap.innerHTML = `<div class="banner"><b>Bankroll giornaliero</b><small>Nessuno snapshot per oggi: verr√† creato alla prima bet aggiunta allo storico.</small></div>`;
    return;
  }
  const pctStr = info.pct===null ? "‚Äî" : fmtPct(info.pct);
  const pStr = fmtMoney(info.profit);
  const brStr = fmtMoney(info.brDay);
  if(info.pct!==null && info.pct>=0.03){
    wrap.innerHTML = `<div class="banner good"><b>TARGET PROFIT RAGGIUNTO</b><small>Oggi: <b>${pStr}</b> (${pctStr}) su BR day <b>${brStr}</b>.</small></div>`;
  }else if(info.pct!==null && info.pct<=-0.10){
    wrap.innerHTML = `<div class="banner bad"><b>STOP LOSS RAGGIUNTO</b><small>Oggi: <b>${pStr}</b> (${pctStr}) su BR day <b>${brStr}</b>.</small></div>`;
  }else{
    wrap.innerHTML = `<div class="banner"><b>Giornata in corso</b><small>Oggi: <b>${pStr}</b> (${pctStr}) su BR day <b>${brStr}</b>. (Bet chiuse: ${info.closedCount})</small></div>`;
  }
}

/* =========================
   Profit calc
========================= */
function calcProfit(result, stake, odds){
  const s = Number(stake);
  const o = Number(odds);
  if(!Number.isFinite(s) || s<=0) return null;
  if(result==="win"){
    if(!Number.isFinite(o) || o<=1) return null;
    return s * (o - 1);
  }
  if(result==="loss") return -s;
  return null;
}
function recalcAll(){
  for(const b of state.history){
    if(b.result==="win" || b.result==="loss"){
      if(b.profit_manual===true) continue;
      b.profit_real = calcProfit(b.result, b.execution.stake_played, b.execution.odds_played);
    }else{
      b.profit_real = null;
    }
  }
  saveState();
  renderAll();
}

/* =========================
   Calcolatore UI
========================= */
const lpText=document.getElementById("lpText");
const btnParse=document.getElementById("btnParse");
const btnClear=document.getElementById("btnClear");
const btnResetAll=document.getElementById("btnResetAll");
const parseMsg=document.getElementById("parseMsg");
const previewWrap=document.getElementById("previewWrap");
const bankrollInput=document.getElementById("bankrollInput");
const bankrollDay=document.getElementById("bankrollDay");
const oddsPlayed=document.getElementById("oddsPlayed");
const stakePlayed=document.getElementById("stakePlayed");
const btnAddToHistory=document.getElementById("btnAddToHistory");

let lastParsed=null;
let lastStake=null;

function syncBankrollInputs(){
  bankrollInput.value = Number(state.settings.bankroll||0);
  document.getElementById("bankrollInputDash").value = Number(state.settings.bankroll||0);
  bankrollDay.value = (state.dailySnapshot.date===todayISO() && state.dailySnapshot.bankroll!==null)
    ? fmtMoney(state.dailySnapshot.bankroll)
    : "‚Äî";
}
bankrollInput.addEventListener("change", ()=>{
  state.settings.bankroll = Number(bankrollInput.value||0);
  saveState(); syncBankrollInputs(); renderDailyBanner(); updateDailyPill();
});
document.getElementById("bankrollInputDash").addEventListener("change", ()=>{
  state.settings.bankroll = Number(document.getElementById("bankrollInputDash").value||0);
  saveState(); syncBankrollInputs(); renderDailyBanner(); updateDailyPill();
});

btnClear.addEventListener("click", ()=>{
  lpText.value=""; lastParsed=null; lastStake=null;
  parseMsg.innerHTML=""; previewWrap.innerHTML="Nessun parse ancora.";
  btnAddToHistory.disabled=true;
});
btnResetAll.addEventListener("click", ()=>{
  if(confirm("Sicuro di voler resettare TUTTO? (storico + impostazioni + snapshot)")) resetAll();
});

btnParse.addEventListener("click", ()=>{
  const res = parseNotification(lpText.value);
  if(!res.ok){
    lastParsed=null; lastStake=null; btnAddToHistory.disabled=true;
    parseMsg.innerHTML = `<div class="errLine"><b>Parse fallito:</b><br/>${res.errors.map(e=>`‚Ä¢ ${escapeHtml(e)}`).join("<br/>")}</div>` +
      (res.warnings.length ? `<div class="warnLine"><b>Warning:</b><br/>${res.warnings.map(w=>`‚Ä¢ ${escapeHtml(w)}`).join("<br/>")}</div>` : "");
    previewWrap.innerHTML="Correggi la notifica e riprova.";
    return;
  }
  lastParsed=res.data;
  lastStake=calcStakeV1(lastParsed);

  const warn = [...res.warnings, ...(lastStake.warnings||[])];
  parseMsg.innerHTML = `<div class="okLine"><b>Parse OK.</b> <span class="mono">${escapeHtml(lastParsed.meta.Match)}</span></div>` +
    (warn.length ? `<div class="warnLine"><b>Warning:</b><br/>${warn.map(w=>`‚Ä¢ ${escapeHtml(w)}`).join("<br/>")}</div>` : "");

  syncBankrollInputs();

  const brBase = (state.dailySnapshot.date===todayISO() && state.dailySnapshot.bankroll!==null)
    ? Number(state.dailySnapshot.bankroll) : Number(state.settings.bankroll||0);

  const stakeAmt = lastStake.stake_pct ? (lastStake.stake_pct*brBase) : 0;

  if(!stakePlayed.value) stakePlayed.value = stakeAmt>0 ? stakeAmt.toFixed(2) : "";
  // oddsPlayed left empty by design

  const noBetLine = lastStake.no_bet ? `<div class="errLine"><b>NO BET</b>: edge ‚â§ 0 (o probabilit√† insufficiente).</div>` : "";
  const pRef = lastStake.P_REF!==null ? fmtPct(lastStake.P_REF) : "‚Äî";
  const implied = lastStake.implied!==null ? fmtPct(lastStake.implied) : "‚Äî";
  const edge = lastStake.edge!==null ? fmtPct(lastStake.edge) : "‚Äî";
  const needed = lastStake.needed_goals ?? "‚Äî";

  previewWrap.innerHTML = `
    <div class="row">
      <span class="badge">${escapeHtml(lastParsed.oddsToBet.label)} @ <span class="mono">${lastParsed.oddsToBet.odds_ref}</span></span>
      <span class="badge">PROB usata: <b class="mono">${escapeHtml(lastParsed.oddsToBet.phase||"‚Äî")}(+${needed})</b></span>
      <span class="badge">Fonte: <b>${escapeHtml(lastStake.source||"‚Äî")}</b></span>
      <span class="badge">N arch: <b>${lastStake.N_archive ?? 0}</b></span>
    </div>
    <div class="row" style="margin-top:8px">
      <span class="badge">P_REF: <b class="mono">${pRef}</b></span>
      <span class="badge">Implied: <b class="mono">${implied}</b></span>
      <span class="badge">Edge: <b class="mono">${edge}</b></span>
    </div>
    <div class="row" style="margin-top:8px">
      <span class="badge">Stake%: <b class="mono">${fmtPct(lastStake.stake_pct)}</b></span>
      <span class="badge">Stake ‚Ç¨ (base): <b class="mono">${fmtMoney(stakeAmt)}</b></span>
      <span class="badge">BR base: <b class="mono">${fmtMoney(brBase)}</b></span>
    </div>
    ${noBetLine}
  `;

  btnAddToHistory.disabled=false;
});

btnAddToHistory.addEventListener("click", ()=>{
  if(!lastParsed || !lastStake || !lastStake.ok) return;

  ensureDailySnapshot();
  syncBankrollInputs();

  const brDay = Number(state.dailySnapshot.bankroll||0);
  const stakeAmt = lastStake.stake_pct ? lastStake.stake_pct * brDay : 0;

  const bet = {
    id: crypto.randomUUID ? crypto.randomUUID() : String(Date.now())+"_"+Math.random().toString(16).slice(2),
    date: todayISO(),
    key: lastStake.key,
    meta: lastParsed.meta,
    state: lastParsed.state,
    stats: lastParsed.stats,
    l10: lastParsed.l10,
    prob: lastParsed.prob,
    press: lastParsed.press,
    late: lastParsed.late,
    odds_to_bet: lastParsed.oddsToBet,
    lp: lastParsed.lp,
    calc: {
      stake_source: lastStake.source,
      N_archive_at_bet: lastStake.N_archive,
      P_REF: lastStake.P_REF,
      implied_prob: lastStake.implied,
      edge: lastStake.edge,
      kelly: lastStake.kelly,
      stake_suggested_pct: lastStake.stake_pct,
      bankroll_day: brDay,
      needed_goals: lastStake.needed_goals
    },
    execution: {
      odds_ref: lastParsed.oddsToBet.odds_ref,
      stake_suggested: stakeAmt,
      odds_played: safeNum(oddsPlayed.value),
      stake_played: safeNum(stakePlayed.value) ?? stakeAmt
    },
    result: "pending", // pending by default
    profit_real: null,
    profit_manual: false,
    raw: lastParsed.raw
  };

  state.history.unshift(bet);
  saveState();
  renderAll();
  setPage("storico");
});

/* =========================
   Storico UI (mini-cards)
========================= */
const historyList=document.getElementById("historyList");
const historyEmpty=document.getElementById("historyEmpty");
const historyResultFilter=document.getElementById("historyResultFilter");
const historyDateFilter=document.getElementById("historyDateFilter");

historyResultFilter.addEventListener("change", renderHistory);
historyDateFilter.addEventListener("change", renderHistory);

let selectedBetId=null;
let showRaw=false;
document.getElementById("btnToggleRaw").addEventListener("click", ()=>{
  if(!selectedBetId) return;
  showRaw = !showRaw;
  renderDetails(state.history.find(b=>b.id===selectedBetId));
});

function resultBadge(res){
  if(res==="win") return `<span class="badge win">Vinta</span>`;
  if(res==="loss") return `<span class="badge loss">Persa</span>`;
  if(res==="not_played") return `<span class="badge pending">Non giocata</span>`;
  return `<span class="badge neutral">Pending</span>`;
}
function profitChip(b){
  if(b.result==="win"){
    return `<span class="chip good">Profit <b>+${escapeHtml(fmtMoney(b.profit_real))}</b></span>`;
  }
  if(b.result==="loss"){
    return `<span class="chip bad">Profit <b>${escapeHtml(fmtMoney(b.profit_real))}</b></span>`;
  }
  // pending/not played not counted
  return `<span class="chip warn">Profit <b>‚Äî</b></span>`;
}
function formatPick(b){
  // show "FT Next Over 1.5"
  return (b.odds_to_bet && b.odds_to_bet.label) ? b.odds_to_bet.label : `${b.odds_to_bet?.phase||""} ${b.odds_to_bet?.market||""} ${b.odds_to_bet?.line??""}`.trim();
}
function filterHistoryList(){
  let arr = state.history.slice();
  const rf = historyResultFilter.value;
  const df = historyDateFilter.value;

  if(rf!=="all"){
    arr = arr.filter(b=>b.result===rf);
  }
  if(df!=="all"){
    arr = arr.filter(b=>inDateRange(b.date, df));
  }
  return arr;
}
function renderHistory(){
  const arr = filterHistoryList();
  historyList.innerHTML="";
  historyEmpty.textContent="";
  if(arr.length===0){
    historyEmpty.textContent="Nessuna bet da mostrare.";
    return;
  }

  for(const b of arr){
    const pick = formatPick(b);
    const method = b.meta?.Method || "‚Äî";
    const match = b.meta?.Match || "‚Äî";
    const stakeS = fmtMoney(b.execution?.stake_suggested);
    const stakeP = fmtMoney(b.execution?.stake_played);
    const oddsRef = b.execution?.odds_ref ?? "‚Äî";
    const oddsP = (b.execution?.odds_played ?? "‚Äî");
    const badge = resultBadge(b.result);

    const el = document.createElement("div");
    el.className="betCard";
    el.innerHTML = `
      <div class="betTop">
        <div class="betTopLeft">
          <div class="t1">
            <span class="date mono">${escapeHtml(b.date)}</span>
            <span class="method">${escapeHtml(method)}</span>
          </div>
          <div class="t2 mono">${escapeHtml(match)}</div>
        </div>
        <div>${badge}</div>
      </div>

      <div class="betMid">
        <span class="chip">Pick <b class="mono">${escapeHtml(pick)}</b></span>
        <span class="chip">Stake <b class="mono">${escapeHtml(stakeP)}</b> <span class="muted">(${escapeHtml(stakeS)} sug)</span></span>
        <span class="chip">Odds <b class="mono">${escapeHtml(String(oddsP))}</b> <span class="muted">(${escapeHtml(String(oddsRef))} ref)</span></span>
        ${profitChip(b)}
      </div>

      <div class="betActions">
        <button class="miniBtn primary" data-act="edit" data-id="${b.id}">Modifica</button>
        <button class="miniBtn" data-act="details" data-id="${b.id}">Dettagli</button>
        <button class="miniBtn danger" data-act="del" data-id="${b.id}">Elimina</button>
      </div>
    `;
    historyList.appendChild(el);
  }
}

historyList.addEventListener("click",(e)=>{
  const btn = e.target.closest("button[data-act]");
  if(!btn) return;
  const id = btn.getAttribute("data-id");
  const act = btn.getAttribute("data-act");
  const b = state.history.find(x=>x.id===id);
  if(!b) return;

  if(act==="del"){
    if(confirm("Eliminare questa bet?")){
      state.history = state.history.filter(x=>x.id!==id);
      saveState();
      if(selectedBetId===id){
        selectedBetId=null;
        document.getElementById("btnToggleRaw").disabled=true;
        document.getElementById("detailsBox").textContent="Seleziona ‚ÄúDettagli‚Äù su una bet.";
      }
      renderAll();
    }
    return;
  }
  if(act==="details"){
    selectedBetId=id;
    showRaw=false;
    document.getElementById("btnToggleRaw").disabled=false;
    document.getElementById("btnToggleRaw").textContent="Mostra JSON raw";
    renderDetails(b);
    return;
  }
  if(act==="edit"){
    openInlineEditor(b);
    return;
  }
});

function renderDetails(b){
  const box=document.getElementById("detailsBox");
  if(!b){
    box.textContent="Seleziona ‚ÄúDettagli‚Äù su una bet.";
    return;
  }
  if(showRaw){
    document.getElementById("btnToggleRaw").textContent="Mostra vista leggibile";
    box.innerHTML = `<pre class="mono" style="white-space:pre-wrap;margin:0">${escapeHtml(JSON.stringify(b,null,2))}</pre>`;
    return;
  }
  document.getElementById("btnToggleRaw").textContent="Mostra JSON raw";

  const sec = (title, rows)=>`
    <div class="section">
      <div class="sectionTitle">${escapeHtml(title)}</div>
      <div class="kvList">
        ${rows.map(([k,v])=>`
          <div class="kvItem"><div class="k">${escapeHtml(k)}</div><div class="v">${escapeHtml(v)}</div></div>
        `).join("")}
      </div>
    </div>`;

  const sMeta = sec("INFO", [
    ["Data", b.date],
    ["Metodo", b.meta?.Method || "‚Äî"],
    ["Competizione", b.meta?.Comp || "‚Äî"],
    ["Match", b.meta?.Match || "‚Äî"],
    ["Pick", formatPick(b)],
    ["Odds ref", String(b.execution?.odds_ref ?? "‚Äî")],
    ["Odds reale", String(b.execution?.odds_played ?? "‚Äî")],
    ["Stake suggerito", fmtMoney(b.execution?.stake_suggested)],
    ["Stake reale", fmtMoney(b.execution?.stake_played)],
    ["Esito", b.result],
    ["Profitto", (b.result==="win"||b.result==="loss") ? fmtMoney(b.profit_real) : "‚Äî"]
  ]);

  const sState = sec("STATE", [
    ["Time", String(b.state?.Time ?? "‚Äî")],
    ["RemHT", String(b.state?.RemHT ?? "‚Äî")],
    ["RemFT", String(b.state?.RemFT ?? "‚Äî")],
    ["Score", b.state?.ScoreRaw || "‚Äî"]
  ]);

  const probRows = [];
  const addProb = (phase)=>{
    const obj = b.prob?.[phase] || {};
    const keys = Object.keys(obj).sort((a,b)=>Number(a)-Number(b));
    for(const k of keys){
      probRows.push([`${phase}(+${k})`, String(obj[k])]);
    }
  };
  addProb("HT"); addProb("FT");
  const sProb = sec("PROB", probRows.length?probRows:[["‚Äî","‚Äî"]]);

  const sLP = sec("LIVEPICK", [
    ["WR", b.lp?.WR===null ? "‚Äî" : (b.lp.WR*100).toFixed(2)+"%"],
    ["ROI", b.lp?.ROI===null ? "‚Äî" : (b.lp.ROI*100).toFixed(2)+"%"],
    ["Profit", String(b.lp?.Profit ?? "‚Äî")],
    ["AO", String(b.lp?.AO ?? "‚Äî")],
    ["N", String(b.lp?.N ?? "‚Äî")]
  ]);

  const sCalc = sec("CALC", [
    ["Fonte stake", b.calc?.stake_source || "‚Äî"],
    ["N arch", String(b.calc?.N_archive_at_bet ?? "‚Äî")],
    ["P_REF", b.calc?.P_REF===null ? "‚Äî" : (b.calc.P_REF*100).toFixed(2)+"%"],
    ["Implied", b.calc?.implied_prob===null ? "‚Äî" : (b.calc.implied_prob*100).toFixed(2)+"%"],
    ["Edge", b.calc?.edge===null ? "‚Äî" : (b.calc.edge*100).toFixed(2)+"%"],
    ["Stake% sugg", b.calc?.stake_suggested_pct===null ? "‚Äî" : (b.calc.stake_suggested_pct*100).toFixed(2)+"%"],
    ["Bankroll day", b.calc?.bankroll_day===null ? "‚Äî" : fmtMoney(b.calc.bankroll_day)],
    ["Needed goals (NEXT)", String(b.calc?.needed_goals ?? "‚Äî")]
  ]);

  box.innerHTML = `<div class="detailsList">${sMeta}${sState}${sProb}${sLP}${sCalc}</div>`;
}

/* ---- Inline editor modal-ish (simple, LivePick-like) ---- */
function openInlineEditor(b){
  // We build a small inline editor inside details box to avoid popups
  selectedBetId = b.id;
  showRaw = false;
  document.getElementById("btnToggleRaw").disabled = false;
  document.getElementById("btnToggleRaw").textContent = "Mostra JSON raw";

  const box=document.getElementById("detailsBox");
  const curRes = b.result;

  // editable: date, match, odds_played, stake_played
  // result: dropdown
  const mkField = (label, value, key, type="text", step=null)=>`
    <div class="kvItem">
      <div class="k">${escapeHtml(label)}</div>
      <div class="v">
        <span class="inlineEdit" data-key="${escapeHtml(key)}" data-type="${escapeHtml(type)}" ${step?`data-step="${step}"`:""}>${escapeHtml(String(value ?? "‚Äî"))}</span>
      </div>
    </div>
  `;

  const resSelect = `
    <select class="inlineSelect" id="editResult">
      <option value="win" ${curRes==="win"?"selected":""}>Vinta</option>
      <option value="loss" ${curRes==="loss"?"selected":""}>Persa</option>
      <option value="not_played" ${curRes==="not_played"?"selected":""}>Non giocata</option>
      <option value="pending" ${curRes==="pending"?"selected":""}>Pending</option>
    </select>`;

  const html = `
    <div class="section">
      <div class="sectionTitle">Modifica (clic sul valore per cambiare)</div>
      <div class="kvList">
        ${mkField("Data", b.date, "date", "date")}
        ${mkField("Partita", b.meta?.Match || "", "match", "text")}
        ${mkField("Quota reale", b.execution?.odds_played ?? "", "odds_played", "number", "0.01")}
        ${mkField("Stake reale", b.execution?.stake_played ?? "", "stake_played", "number", "0.01")}
        <div class="kvItem">
          <div class="k">Esito</div>
          <div class="v">${resSelect}</div>
        </div>
        <div class="kvItem">
          <div class="k">Profitto</div>
          <div class="v"><b class="mono">${(b.result==="win"||b.result==="loss") ? fmtMoney(b.profit_real) : "‚Äî"}</b> <span class="muted">(calcolato)</span></div>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <button class="btn primary" id="btnSaveEdit">Salva</button>
        <button class="btn" id="btnCancelEdit">Annulla</button>
      </div>
      <div class="help" style="margin-top:8px">Profitto non modificabile: viene ricalcolato da stake e quota reali (solo win/loss).</div>
    </div>
  `;
  box.innerHTML = html;

  // attach click-to-edit for fields
  box.querySelectorAll(".inlineEdit").forEach(span=>{
    span.addEventListener("click", ()=>{
      const key = span.getAttribute("data-key");
      const type = span.getAttribute("data-type") || "text";
      const step = span.getAttribute("data-step");
      const old = (span.textContent==="‚Äî") ? "" : span.textContent;

      const inp = document.createElement("input");
      inp.type = type;
      if(step) inp.step = step;
      inp.value = old;
      inp.className = "";
      inp.style.width = "160px";
      span.replaceWith(inp);
      inp.focus();

      inp.addEventListener("blur", ()=>{
        const newSpan = document.createElement("span");
        newSpan.className = "inlineEdit";
        newSpan.setAttribute("data-key", key);
        newSpan.setAttribute("data-type", type);
        if(step) newSpan.setAttribute("data-step", step);
        newSpan.textContent = inp.value.trim() || "‚Äî";
        inp.replaceWith(newSpan);
        // rebind
        newSpan.addEventListener("click", ()=>newSpan.click());
      }, {once:true});
    }, {once:true});
  });

  document.getElementById("btnCancelEdit").addEventListener("click", ()=>{
    renderDetails(b);
  });

  document.getElementById("btnSaveEdit").addEventListener("click", ()=>{
    // read values from fields: they may be spans (not converted) - easier: query section and parse.
    const sec = box.querySelector(".section");
    const getVal = (k)=>{
      const node = sec.querySelector(`[data-key="${CSS.escape(k)}"]`);
      if(!node) return null;
      const v = node.textContent?.trim();
      if(!v || v==="‚Äî") return "";
      return v;
    };

    const newDate = getVal("date") || b.date;
    const newMatch = getVal("match");
    const newOdds = getVal("odds_played");
    const newStake = getVal("stake_played");
    const newRes = document.getElementById("editResult").value;

    // apply
    b.date = newDate || b.date;
    if(typeof newMatch === "string" && newMatch.trim() !== ""){
      b.meta.Match = newMatch.trim();
    }
    const op = safeNum(newOdds);
    const sp = safeNum(newStake);
    if(op !== null) b.execution.odds_played = op;
    if(sp !== null) b.execution.stake_played = sp;

    b.result = newRes;

    // profit recalculation rules: profit not editable
    if(b.result==="win" || b.result==="loss"){
      b.profit_manual = false;
      b.profit_real = calcProfit(b.result, b.execution.stake_played, b.execution.odds_played);
    }else{
      b.profit_manual = false;
      b.profit_real = null;
    }

    saveState();
    renderHistory();
    renderDetails(b);
    updateDailyPill();
    renderDailyBanner();
  });
}

/* =========================
   Backup / Restore + quick actions
========================= */
document.getElementById("btnClearHistory").addEventListener("click", ()=>{
  if(confirm("Svuotare lo storico?")){
    state.history=[];
    saveState();
    selectedBetId=null;
    document.getElementById("btnToggleRaw").disabled=true;
    document.getElementById("detailsBox").textContent="Seleziona ‚ÄúDettagli‚Äù su una bet.";
    renderAll();
  }
});
document.getElementById("btnRecalc").addEventListener("click", ()=>{
  recalcAll();
  document.getElementById("backupMsg").innerHTML = `<div class="okLine">Ricalcolo completato.</div>`;
});

document.getElementById("btnBackup").addEventListener("click", ()=>{
  const blob = new Blob([JSON.stringify(state,null,2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `bettools_backup_${todayISO()}.json`;
  document.body.appendChild(a);
  a.click(); a.remove();
  URL.revokeObjectURL(url);
  document.getElementById("backupMsg").innerHTML = `<div class="okLine">Backup creato.</div>`;
});
document.getElementById("restoreFile").addEventListener("change", async (e)=>{
  const file = e.target.files && e.target.files[0];
  if(!file) return;
  try{
    const text = await file.text();
    const incoming = JSON.parse(text);
    const replace = confirm("OK = Sostituisci tutto.\nAnnulla = Unisci (merge).");
    if(replace){
      state = incoming;
    }else{
      const cur = loadState();
      const merged = structuredClone(cur);
      merged.settings = incoming.settings || merged.settings;
      merged.dailySnapshot = incoming.dailySnapshot || merged.dailySnapshot;
      const incHist = Array.isArray(incoming.history) ? incoming.history : [];
      const ids = new Set((merged.history||[]).map(b=>b.id));
      for(const b of incHist){
        if(b && b.id && !ids.has(b.id)){
          merged.history.push(b);
          ids.add(b.id);
        }
      }
      state = merged;
    }
    saveState();
    renderAll();
    document.getElementById("backupMsg").innerHTML = `<div class="okLine">Restore completato.</div>`;
  }catch(err){
    document.getElementById("backupMsg").innerHTML = `<div class="errLine">Errore restore: file non valido.</div>`;
  }finally{
    document.getElementById("restoreFile").value="";
  }
});

/* =========================
   Dashboard: totals, DD, streaks + charts
========================= */
let dashRange = "all";
let profitRange = "1m";

document.getElementById("dashRangeSeg").addEventListener("click",(e)=>{
  const b=e.target.closest("button[data-range]");
  if(!b) return;
  dashRange = b.getAttribute("data-range");
  document.querySelectorAll("#dashRangeSeg button").forEach(x=>x.classList.remove("active"));
  b.classList.add("active");
  renderDashboard();
});
document.getElementById("profitRangeSeg").addEventListener("click",(e)=>{
  const b=e.target.closest("button[data-pr]");
  if(!b) return;
  profitRange = b.getAttribute("data-pr");
  document.querySelectorAll("#profitRangeSeg button").forEach(x=>x.classList.remove("active"));
  b.classList.add("active");
  renderDashboard(); // redraw chart
});

document.getElementById("btnSaveBR").addEventListener("click", ()=>{
  const v = Number(document.getElementById("bankrollInputDash").value||0);
  state.settings.bankroll = v;
  saveState();
  syncBankrollInputs();
  document.getElementById("dashMsg").innerHTML = `<div class="okLine">Bankroll salvato: ${fmtMoney(v)}</div>`;
});
document.getElementById("btnNewDay").addEventListener("click", ()=>{
  if(confirm("Reset snapshot giornaliero?")){
    state.dailySnapshot.date=null;
    state.dailySnapshot.bankroll=null;
    saveState();
    renderAll();
  }
});

function closedBetsFiltered(range){
  return state.history
    .filter(b=> (b.result==="win" || b.result==="loss") && inDateRange(b.date, range));
}
function computeTotalsRange(range){
  const closed = closedBetsFiltered(range);
  const profit = sum(closed.map(b=>b.profit_real));
  const stakeTot = sum(closed.map(b=>Number(b.execution.stake_played)||0));
  const roi = stakeTot>0 ? (profit/stakeTot) : null;
  const wins = closed.filter(b=>b.result==="win").length;
  const losses = closed.filter(b=>b.result==="loss").length;
  const winrate = closed.length>0 ? wins/closed.length : null;
  return {closedCount:closed.length, wins, losses, profit, stakeTot, roi, winrate};
}
function computeDrawdownFromClosed(closed){
  const sorted = closed.slice().sort((a,b)=> a.date<b.date ? -1 : (a.date>b.date ? 1 : 0));
  let eq=0, peak=0, maxDD=0;
  for(const b of sorted){
    eq += Number(b.profit_real)||0;
    if(eq>peak) peak=eq;
    const dd=peak-eq;
    if(dd>maxDD) maxDD=dd;
  }
  return {maxDD, eqEnd:eq};
}
function computeStreaksFromClosed(closed){
  const sorted = closed.slice().sort((a,b)=> a.date<b.date ? -1 : (a.date>b.date ? 1 : 0));
  let curW=0,curL=0,maxW=0,maxL=0;
  for(const b of sorted){
    if(b.result==="win"){curW++;curL=0;} else {curL++;curW=0;}
    if(curW>maxW) maxW=curW;
    if(curL>maxL) maxL=curL;
  }
  return {maxW,maxL};
}

/* --- Donut chart (canvas) --- */
function drawDonut(wins, losses){
  const c = document.getElementById("donut");
  const ctx = c.getContext("2d");
  const W=c.width, H=c.height;
  ctx.clearRect(0,0,W,H);

  const total = wins+losses;
  const winPct = total>0 ? wins/total : 0;
  const lossPct = total>0 ? losses/total : 0;

  // base circle
  const cx=W/2, cy=H/2, r=Math.min(W,H)*0.28;
  const thickness=r*0.45;

  function arc(pct, start, color){
    const end = start + pct*Math.PI*2;
    ctx.beginPath();
    ctx.strokeStyle=color;
    ctx.lineWidth=thickness;
    ctx.lineCap="butt";
    ctx.arc(cx, cy, r, start, end);
    ctx.stroke();
    return end;
  }

  // background
  ctx.beginPath();
  ctx.strokeStyle="rgba(255,255,255,.08)";
  ctx.lineWidth=thickness;
  ctx.arc(cx, cy, r, 0, Math.PI*2);
  ctx.stroke();

  // colors
  const good="rgba(25,195,125,.95)";
  const bad="rgba(255,77,79,.95)";
  let a=-Math.PI/2;
  a = arc(winPct, a, good);
  arc(lossPct, a, bad);

  // text
  ctx.fillStyle="rgba(232,238,252,.92)";
  ctx.font="700 22px "+getComputedStyle(document.body).fontFamily;
  const wr = total>0 ? Math.round(winPct*100) : 0;
  ctx.textAlign="center";
  ctx.fillText(`${wr}%`, cx, cy+8);
  ctx.font="600 12px "+getComputedStyle(document.body).fontFamily;
  ctx.fillStyle="rgba(159,176,208,.95)";
  ctx.fillText("Win Rate", cx, cy+28);

  document.getElementById("wonLabel").innerHTML = `Won: <b>${Math.round(winPct*100)}%</b>`;
  document.getElementById("lostLabel").innerHTML = `Lost: <b>${Math.round(lossPct*100)}%</b>`;
}

/* --- Profit chart (canvas) --- */
function drawProfitChart(closed, monthsMode){
  const c = document.getElementById("profitChart");
  const ctx = c.getContext("2d");
  const W=c.width, H=c.height;
  ctx.clearRect(0,0,W,H);

  let data = closed.slice().sort((a,b)=> a.date<b.date ? -1 : (a.date>b.date ? 1 : 0));
  if(monthsMode==="1m") data = data.filter(b=>inMonthsBack(b.date,1));
  if(monthsMode==="6m") data = data.filter(b=>inMonthsBack(b.date,6));
  if(monthsMode==="12m") data = data.filter(b=>inMonthsBack(b.date,12));

  // Build cumulative series
  let eq=0;
  const pts = data.map(b=> (eq += Number(b.profit_real)||0));
  if(pts.length===0){
    // axes only
    ctx.strokeStyle="rgba(255,255,255,.10)";
    ctx.strokeRect(40,20,W-60,H-50);
    ctx.fillStyle="rgba(159,176,208,.95)";
    ctx.font="600 12px "+getComputedStyle(document.body).fontFamily;
    ctx.fillText("Nessun dato nel periodo", 50, 40);
    return;
  }

  const minY = Math.min(...pts, 0);
  const maxY = Math.max(...pts, 0);
  const pad = (maxY-minY)*0.12 || 1;
  const y0 = minY - pad;
  const y1 = maxY + pad;

  const left=40, top=20, right=W-20, bottom=H-30;
  const plotW = right-left;
  const plotH = bottom-top;

  // helper map
  const xAt = (i)=> left + (pts.length===1 ? plotW/2 : (i/(pts.length-1))*plotW);
  const yAt = (v)=> top + (1-(v-y0)/(y1-y0))*plotH;

  // grid + zero line
  ctx.strokeStyle="rgba(255,255,255,.08)";
  ctx.strokeRect(left, top, plotW, plotH);

  const zeroY = yAt(0);
  ctx.beginPath();
  ctx.strokeStyle="rgba(255,255,255,.12)";
  ctx.moveTo(left, zeroY);
  ctx.lineTo(right, zeroY);
  ctx.stroke();

  // fill negative area
  ctx.beginPath();
  ctx.moveTo(left, zeroY);
  for(let i=0;i<pts.length;i++){
    ctx.lineTo(xAt(i), yAt(pts[i]));
  }
  ctx.lineTo(right, zeroY);
  ctx.closePath();
  ctx.fillStyle="rgba(255,77,79,.10)";
  ctx.fill();

  // line
  ctx.beginPath();
  for(let i=0;i<pts.length;i++){
    const x=xAt(i), y=yAt(pts[i]);
    if(i===0) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  }
  ctx.strokeStyle="rgba(255,77,79,.80)";
  ctx.lineWidth=2;
  ctx.stroke();

  // points
  ctx.fillStyle="rgba(255,77,79,.95)";
  for(let i=0;i<pts.length;i++){
    const x=xAt(i), y=yAt(pts[i]);
    ctx.beginPath();
    ctx.arc(x,y,3,0,Math.PI*2);
    ctx.fill();
  }

  // y labels (few)
  ctx.fillStyle="rgba(159,176,208,.95)";
  ctx.font="600 11px "+getComputedStyle(document.body).fontFamily;
  ctx.textAlign="left";
  ctx.fillText(`${y1.toFixed(1)}`, 6, top+10);
  ctx.fillText(`${y0.toFixed(1)}`, 6, bottom);

  // last value
  const last = pts[pts.length-1];
  ctx.textAlign="right";
  ctx.fillText(`Cumulato: ${last.toFixed(2)}`, right, top-6);
}

function renderDashboard(){
  const t = computeTotalsRange(dashRange);
  const dd = computeDrawdownFromClosed(closedBetsFiltered(dashRange));
  const st = computeStreaksFromClosed(closedBetsFiltered(dashRange));

  const kpis=document.getElementById("dashKpis");
  kpis.innerHTML = `
    <div class="kpi"><span>Bet chiuse</span><b>${t.closedCount}</b></div>
    <div class="kpi"><span>Winrate</span><b>${t.winrate===null ? "‚Äî" : fmtPct(t.winrate)}</b></div>
    <div class="kpi"><span>Profitto</span><b class="${t.profit>=0?'good':'bad'}">${fmtMoney(t.profit)}</b></div>
    <div class="kpi"><span>ROI</span><b class="${(t.roi!==null && t.roi>=0)?'good':'bad'}">${t.roi===null?"‚Äî":fmtPct(t.roi)}</b></div>
    <div class="kpi"><span>Max DD</span><b>${fmtMoney(dd.maxDD)}</b></div>
    <div class="kpi"><span>Streak (W/L)</span><b>${st.maxW} / ${st.maxL}</b></div>
  `;

  drawDonut(t.wins, t.losses);

  // Profit chart uses closed across ALL by default but also respects dashRange? In LivePick screenshot, chart has its own buttons.
  // We'll filter by dashRange first, then apply 1m/6m/12m/all.
  const closed = closedBetsFiltered(dashRange);
  drawProfitChart(closed, profitRange);
}

/* =========================
   Riepilogo temporale
========================= */
let timeGroup="day";
document.getElementById("timeGroupSeg").addEventListener("click",(e)=>{
  const b=e.target.closest("button[data-tg]");
  if(!b) return;
  timeGroup=b.getAttribute("data-tg");
  document.querySelectorAll("#timeGroupSeg button").forEach(x=>x.classList.remove("active"));
  b.classList.add("active");
  renderTimeSummary();
});
function periodKey(dateISO, mode){
  if(mode==="day") return dateISO;
  if(mode==="week") return startOfWeekISO(dateISO); // label by week start
  if(mode==="month") return monthKey(dateISO);
  return dateISO;
}
function periodLabel(key, mode){
  if(mode==="day") return key;
  if(mode==="week") return `Week ${key}`;
  if(mode==="month") return key;
  return key;
}
function periodStatus(profit, br){
  if(!br || br<=0) return {label:"‚Äî", cls:"badge neutral"};
  const pct=profit/br;
  if(pct>=0.03) return {label:"Target profit", cls:"badge win"};
  if(pct<=-0.10) return {label:"Stop loss", cls:"badge loss"};
  return {label:"Neutra", cls:"badge neutral"};
}
function renderTimeSummary(){
  const empty=document.getElementById("timeEmpty");
  const table=document.getElementById("timeTable");
  const body=document.getElementById("timeBody");

  const closed = state.history.filter(b=>b.result==="win"||b.result==="loss");
  if(closed.length===0){
    empty.textContent="Nessuna bet chiusa: riepilogo non disponibile.";
    table.style.display="none";
    body.innerHTML="";
    return;
  }
  empty.textContent="";
  table.style.display="";
  body.innerHTML="";

  const map=new Map();
  for(const b of closed){
    const key=periodKey(b.date, timeGroup);
    if(!map.has(key)) map.set(key,{key,bets:0,wins:0,losses:0,stake:0,profit:0, br: null});
    const o=map.get(key);
    o.bets++;
    if(b.result==="win") o.wins++; else o.losses++;
    o.stake += Number(b.execution.stake_played)||0;
    o.profit += Number(b.profit_real)||0;

    // bankroll day for that bet (snapshot at time) stored in calc.bankroll_day
    if(o.br===null && b.calc?.bankroll_day) o.br = Number(b.calc.bankroll_day);
  }

  const rows=[...map.values()].sort((a,b)=> a.key<b.key ? 1 : -1);
  for(const r of rows){
    const closedN=r.wins+r.losses;
    const wr=closedN>0 ? r.wins/closedN : null;
    const roi=r.stake>0 ? r.profit/r.stake : null;

    const status = periodStatus(r.profit, r.br);
    const profitCls = r.profit>=0 ? "badge win" : "badge loss";
    const roiCls = (roi!==null && roi>=0) ? "badge win" : "badge loss";

    const tr=document.createElement("tr");
    tr.innerHTML = `
      <td class="mono">${escapeHtml(periodLabel(r.key,timeGroup))}</td>
      <td>${r.bets}</td>
      <td class="mono">${wr===null?"‚Äî":fmtPct(wr)}</td>
      <td><span class="${profitCls}">${escapeHtml(fmtMoney(r.profit))}</span></td>
      <td><span class="${roiCls}">${roi===null?"‚Äî":escapeHtml(fmtPct(roi))}</span></td>
      <td><span class="${status.cls}">${escapeHtml(status.label)}</span></td>
    `;
    body.appendChild(tr);
  }
}

/* =========================
   Riepilogo filtri (cards + LivePick compare)
========================= */
document.getElementById("filterSort").addEventListener("change", renderFilters);

function computeTotalsAllClosed(){
  const closed = state.history.filter(b=>b.result==="win"||b.result==="loss");
  const profit = sum(closed.map(b=>b.profit_real));
  const stakeTot = sum(closed.map(b=>Number(b.execution.stake_played)||0));
  const roi = stakeTot>0 ? profit/stakeTot : null;
  return {closedCount:closed.length, profit, stakeTot, roi};
}
function computeDrawdownGlobal(){
  const closed = state.history.filter(b=>b.result==="win"||b.result==="loss");
  return computeDrawdownFromClosed(closed);
}
function computeStreaksGlobal(){
  const closed = state.history.filter(b=>b.result==="win"||b.result==="loss");
  return computeStreaksFromClosed(closed);
}
function renderFilters(){
  const grid=document.getElementById("filtersGrid");
  const sort=document.getElementById("filterSort").value;
  const metaRow=document.getElementById("filtersMetaRow");
  const notes=document.getElementById("filtersNotes");

  const totals=computeTotalsAllClosed();
  const dd=computeDrawdownGlobal();
  const st=computeStreaksGlobal();

  metaRow.innerHTML = `
    <div class="kpi"><span>Bet totali</span><b>${state.history.length}</b></div>
    <div class="kpi"><span>Bet chiuse</span><b>${totals.closedCount}</b></div>
    <div class="kpi"><span>Profitto</span><b class="${totals.profit>=0?'good':'bad'}">${fmtMoney(totals.profit)}</b></div>
    <div class="kpi"><span>ROI</span><b class="${(totals.roi!==null && totals.roi>=0)?'good':'bad'}">${totals.roi===null?"‚Äî":fmtPct(totals.roi)}</b></div>
  `;
  notes.textContent = `Max DD: ${fmtMoney(dd.maxDD)} ‚Ä¢ Max win streak: ${st.maxW} ‚Ä¢ Max loss streak: ${st.maxL}`;

  // group by method + pick label
  const groups=new Map();
  for(const b of state.history){
    const name = `${b.meta?.Method || "‚Äî"} ‚Ä¢ ${formatPick(b)}`;
    if(!groups.has(name)){
      groups.set(name, {
        name, bets:0, wins:0, losses:0,
        stake:0, profit:0,
        oddsSum:0, oddsN:0,
        lastLP: null, lastDate: null
      });
    }
    const g=groups.get(name);
    g.bets++;

    // last LP values by temporal order (date then insertion)
    if(!g.lastDate || b.date >= g.lastDate){
      g.lastDate = b.date;
      g.lastLP = b.lp || null;
    }

    // odds avg (use played if exists else ref)
    const o = (b.execution?.odds_played ?? b.execution?.odds_ref);
    if(o && Number(o)>1){ g.oddsSum += Number(o); g.oddsN++; }

    if(b.result==="win"||b.result==="loss"){
      g.stake += Number(b.execution.stake_played)||0;
      g.profit += Number(b.profit_real)||0;
      if(b.result==="win") g.wins++; else g.losses++;
    }
  }

  let arr=[...groups.values()].map(g=>{
    const closedN=g.wins+g.losses;
    const winrate = closedN>0 ? g.wins/closedN : null;
    const roi = g.stake>0 ? g.profit/g.stake : null;
    const avgOdds = g.oddsN>0 ? g.oddsSum/g.oddsN : null;
    // livepick compare from last bet for that filter
    const lp = g.lastLP;
    const lpWR = lp?.WR ?? null;
    const lpROI = lp?.ROI ?? null;
    const lpProfit = lp?.Profit ?? null;
    return {...g, closedN, winrate, roi, avgOdds, lpWR, lpROI, lpProfit};
  });

  // sort
  arr.sort((a,b)=>{
    const va = (sort==="roi") ? (a.roi ?? -1e9)
      : (sort==="profit") ? a.profit
      : (sort==="winrate") ? (a.winrate ?? -1e9)
      : (sort==="bets") ? a.bets
      : a.name.localeCompare(b.name);
    const vb = (sort==="roi") ? (b.roi ?? -1e9)
      : (sort==="profit") ? b.profit
      : (sort==="winrate") ? (b.winrate ?? -1e9)
      : (sort==="bets") ? b.bets
      : 0;
    if(sort==="name") return va;
    return vb - va;
  });

  grid.innerHTML="";
  if(arr.length===0){
    grid.innerHTML = `<div class="card"><div class="help">Nessun dato.</div></div>`;
    return;
  }

  for(const g of arr){
    const winPct = g.winrate===null ? "‚Äî" : fmtPct(g.winrate);
    const roiStr = g.roi===null ? "‚Äî" : fmtPct(g.roi);
    const roiCls = (g.roi!==null && g.roi>=0) ? "badge win" : "badge loss";
    const profitCls = g.profit>=0 ? "good" : "bad";

    // Compare with LP (in parentheses) + delta
    const lpwr = g.lpWR===null ? null : g.lpWR;
    const lproi = g.lpROI===null ? null : g.lpROI;
    const lpp = (g.lpProfit===null || g.lpProfit===undefined) ? null : Number(g.lpProfit);

    const wrDelta = (g.winrate!==null && lpwr!==null) ? (g.winrate - lpwr) : null;
    const roiDelta = (g.roi!==null && lproi!==null) ? (g.roi - lproi) : null;
    const pDelta = (lpp!==null) ? (g.profit - lpp) : null;

    const compLine = (label, val, lpVal, delta, isPct=true)=>{
      const v = val===null ? "‚Äî" : (isPct ? fmtPct(val) : fmtMoney(val));
      const lpS = lpVal===null ? "" : ` (LP ${isPct?fmtPct(lpVal):fmtMoney(lpVal)})`;
      const dS = delta===null ? "" : ` ‚Ä¢ Œî ${isPct?fmtPct(delta):fmtMoney(delta)}`;
      return `<div class="help">${escapeHtml(label)}: <b>${escapeHtml(v)}</b>${escapeHtml(lpS)}${escapeHtml(dS)}</div>`;
    };

    const card=document.createElement("div");
    card.className="card";
    card.innerHTML = `
      <div class="cardHeader">
        <div>
          <b>${escapeHtml(g.name)}</b><br/>
          <small>${g.bets} bet</small>
        </div>
        <div class="${roiCls}">${g.roi===null?"ROI ‚Äî":"ROI "+roiStr}</div>
      </div>

      <div class="row">
        <span class="badge">Vinte: <b>${g.winrate===null?"‚Äî":winPct}</b></span>
        <span class="badge">Quota media: <b class="mono">${g.avgOdds===null?"‚Äî":g.avgOdds.toFixed(2)}</b></span>
        <span class="badge">Profitto: <b class="${profitCls} mono">${fmtMoney(g.profit)}</b></span>
      </div>

      <div style="margin-top:8px">
        ${compLine("% Vinte", g.winrate, lpwr, wrDelta, true)}
        ${compLine("ROI", g.roi, lproi, roiDelta, true)}
        ${compLine("Profit", g.profit, (lpp===null?null:lpp), pDelta, false)}
        <div class="help">LP preso dall‚Äôultima bet registrata per questo filtro.</div>
      </div>
    `;
    grid.appendChild(card);
  }
}

/* =========================
   Daily UI refresh
========================= */
function renderAll(){
  syncBankrollInputs();
  renderDailyBanner();
  updateDailyPill();
  renderHistory();
  renderDashboard();
  renderTimeSummary();
  renderFilters();
}
renderAll();

/* =========================
   Startup buttons
========================= */
document.getElementById("btnToggleRaw").disabled = true;
</script>
</body>
</html>
