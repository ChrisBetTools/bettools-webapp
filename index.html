<!doctype html>
<html lang="it" data-theme="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LivePick iOS26 ‚Äî UI v1.9.8</title>
  <style>
:root{
  color-scheme: light;
  --font: ui-sans-serif, system-ui, -apple-system, "SF Pro Text","SF Pro Display", Segoe UI, Roboto, Helvetica, Arial;
  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;

  --radius-sm:12px;
  --radius:16px;
  --radius-xl:22px;
  --blur:18px;

  /* Light */
  --bg:#f4f5f7;
  --bg2:#eef0f3;
  --card:rgba(255,255,255,.72);
  --card2:rgba(255,255,255,.52);
  --stroke:rgba(15,23,42,.10);
  --stroke2:rgba(15,23,42,.16);
  --text:rgba(15,23,42,.92);
  --muted:rgba(15,23,42,.60);

  --accent:#0a84ff;
  --good:#34c759;
  --bad:#ff3b30;
  --warn:#ff9f0a;

  --shadow: 0 14px 40px rgba(2,6,23,.14);
  --shadow2: 0 8px 22px rgba(2,6,23,.10);

  /* Charts */
  --chart-grid: rgba(15,23,42,.12);
  --chart-line: rgba(10,132,255,.85);
  --chart-profit: rgba(52,199,89,.85);
  --chart-loss: rgba(255,59,48,.80);
}

html[data-theme="dark"]{
  color-scheme: dark;
  --bg:#0b1220;
  --bg2:#070b14;
  --card:rgba(17,25,40,.62);
  --card2:rgba(17,25,40,.42);
  --stroke:rgba(226,232,240,.14);
  --stroke2:rgba(226,232,240,.22);
  --text:rgba(232,238,252,.94);
  --muted:rgba(159,176,208,.82);

  --shadow: 0 18px 48px rgba(0,0,0,.48);
  --shadow2: 0 10px 26px rgba(0,0,0,.32);

  --chart-grid: rgba(226,232,240,.14);
  --chart-line: rgba(90,200,250,.92);
  --chart-profit: rgba(48,209,88,.92);
  --chart-loss: rgba(255,69,58,.88);
}

*{box-sizing:border-box}
body{
  margin:0;
  font-family:var(--font);
  background:
    radial-gradient(1200px 650px at 12% -10%, rgba(10,132,255,.18), transparent 60%),
    radial-gradient(980px 560px at 88% -8%, rgba(52,199,89,.14), transparent 55%),
    linear-gradient(180deg, var(--bg2) 0%, var(--bg) 45%, var(--bg2) 100%);
  color:var(--text);
  -webkit-font-smoothing:antialiased;
  -moz-osx-font-smoothing:grayscale;
  padding-top: env(safe-area-inset-top);
}

.muted{color:var(--muted)}
.mono{font-family:var(--mono)}

/* Top bar */
.topbar{
  position:sticky; top:0; z-index:30;
  display:flex; align-items:center; gap:12px;
  padding: 12px 14px calc(12px + env(safe-area-inset-top)) 14px;
  background: linear-gradient(180deg, color-mix(in srgb, var(--card) 92%, transparent), color-mix(in srgb, var(--card2) 80%, transparent));
  border-bottom:1px solid var(--stroke);
  backdrop-filter: blur(var(--blur));
  -webkit-backdrop-filter: blur(var(--blur));
}

.hamburger{
  width:44px; height:38px;
  border-radius:14px;
  border:1px solid var(--stroke);
  background:var(--card2);
  display:grid; place-items:center;
  cursor:pointer;
  user-select:none;
  box-shadow: var(--shadow2);
  transition: transform .15s ease;
}
.hamburger:active{transform:translateY(1px) scale(.99)}
.hamburger span{
  display:block; width:18px; height:2px; background:color-mix(in srgb, var(--text) 92%, transparent);
  border-radius:999px; position:relative;
}
.hamburger span::before,.hamburger span::after{
  content:""; position:absolute; left:0; width:18px; height:2px;
  background:color-mix(in srgb, var(--text) 92%, transparent); border-radius:999px;
}
.hamburger span::before{top:-6px}
.hamburger span::after{top:6px}

.brand{display:flex; flex-direction:column; line-height:1.05}
.brand b{font-size:14px; letter-spacing:.2px}
.brand small{color:var(--muted); font-size:12px}

.topbar .spacer{flex:1}

.iconBtn{
  border:1px solid var(--stroke);
  background:var(--card2);
  color:var(--text);
  height:38px;
  min-width:44px;
  padding:0 12px;
  border-radius:14px;
  cursor:pointer;
  box-shadow: var(--shadow2);
  transition: transform .15s ease;
}
.iconBtn:active{transform:translateY(1px) scale(.99)}

.pill{
  padding:7px 10px; border-radius:999px;
  border:1px solid var(--stroke);
  background:var(--card2);
  color:var(--muted); font-size:12px;
  display:flex; gap:8px; align-items:center; white-space:nowrap;
  box-shadow: var(--shadow2);
}
.dot{width:8px;height:8px;border-radius:50%}
.dot.good{background:var(--good)}
.dot.bad{background:var(--bad)}
.dot.neu{background:#7c8fb7}

/* Sidebar */
.overlay{
  position:fixed; inset:0;
  background:rgba(0,0,0,.45);
  opacity:0; pointer-events:none;
  transition:opacity .18s ease;
  z-index:40;
}
.overlay.show{opacity:1; pointer-events:auto}

.sidebar{
  position:fixed; top:0; left:0; bottom:0;
  width:min(86vw, 340px);
  background: linear-gradient(180deg, color-mix(in srgb, var(--card) 92%, transparent), color-mix(in srgb, var(--card2) 75%, transparent));
  border-right:1px solid var(--stroke);
  transform:translateX(-105%);
  transition:transform .22s ease;
  z-index:50;
  padding: calc(14px + env(safe-area-inset-top)) 14px 14px 14px;
  box-shadow: var(--shadow);
  display:flex; flex-direction:column; gap:10px;
  backdrop-filter: blur(var(--blur));
  -webkit-backdrop-filter: blur(var(--blur));
}
.sidebar.show{transform:translateX(0)}
.sideHeader{display:flex; align-items:center; justify-content:space-between; margin-bottom:8px}
.sideHeader b{font-size:14px}
.closeBtn{
  width:40px;height:38px;border-radius:14px;
  border:1px solid var(--stroke);
  background:var(--card2);
  color:var(--text); cursor:pointer;
}
.nav{display:flex; flex-direction:column; gap:8px; padding-top:6px}
.nav button{
  text-align:left; padding:12px 12px; border-radius:16px;
  border:1px solid var(--stroke);
  background: color-mix(in srgb, var(--card2) 80%, transparent);
  color:var(--text); cursor:pointer;
  display:flex; align-items:center; justify-content:space-between;
  gap:10px; font-size:14px;
  transition: transform .15s ease, background .15s ease, border-color .15s ease;
}
.nav button:active{transform:translateY(1px)}
.nav button.active{border-color:rgba(10,132,255,.45); background:rgba(10,132,255,.14)}
.nav button small{color:var(--muted); font-size:12px}
.sideFooter{
  margin-top:auto;
  border-top:1px solid var(--stroke);
  padding-top:12px;
  color:var(--muted); font-size:12px; line-height:1.4;
}

/* Main */
.main{padding:16px 14px 28px; max-width:1050px; margin:0 auto}
.page{display:none}
.page.active{display:block; animation: fadeUp .18s ease both}
@keyframes fadeUp{from{opacity:0; transform:translateY(6px)} to{opacity:1; transform:translateY(0)}}
h1{font-size:18px; margin:0 0 10px}

.grid{display:grid; grid-template-columns:1fr; gap:12px}
@media (min-width:900px){
  .grid.two{grid-template-columns:1fr 1fr}
  .grid.leftwide{grid-template-columns:1.2fr .8fr}
}

.card{
  background:var(--card);
  border:1px solid var(--stroke);
  border-radius:var(--radius-xl);
  padding:12px;
  box-shadow: var(--shadow2);
  backdrop-filter: blur(var(--blur));
  -webkit-backdrop-filter: blur(var(--blur));
}
.cardHeader{display:flex; align-items:flex-start; justify-content:space-between; gap:12px; margin-bottom:8px}
.cardHeader b{font-size:14px}
.cardHeader small{color:var(--muted)}

.row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}

.btn, .miniBtn{
  border:1px solid var(--stroke);
  background:var(--card2);
  color:var(--text);
  padding:9px 11px;
  border-radius:14px;
  cursor:pointer;
  font-weight:700;
  font-size:13px;
  box-shadow: var(--shadow2);
  transition: transform .15s ease;
}
.btn.primary, .miniBtn.primary{border-color:rgba(10,132,255,.45); background:rgba(10,132,255,.16)}
.btn.danger, .miniBtn.danger{border-color:rgba(255,59,48,.42); background:rgba(255,59,48,.14)}
.btn.good{border-color:rgba(52,199,89,.42); background:rgba(52,199,89,.14)}
.btn:active, .miniBtn:active{transform:translateY(1px) scale(.99)}
.btn:disabled{opacity:.5; cursor:not-allowed}

input, textarea, select{
  width:100%;
  background: color-mix(in srgb, var(--card2) 92%, transparent);
  border:1px solid var(--stroke);
  color:var(--text);
  border-radius:14px;
  padding:10px 12px;
  outline:none;
  font-family:var(--font);
  font-size:14px;
}
textarea{min-height:150px; font-family:var(--mono); font-size:12.5px; line-height:1.35}
label{display:block; color:var(--muted); font-size:12px; margin:10px 0 6px}
.help{color:var(--muted); font-size:12px; line-height:1.35}
.warnLine{color:var(--warn); font-size:12px; margin-top:8px}
.okLine{color:var(--good); font-size:12px; margin-top:8px}
.errLine{color:var(--bad); font-size:12px; margin-top:8px}

.banner{
  border-radius:var(--radius-xl);
  padding:10px 12px;
  border:1px solid var(--stroke);
  background:var(--card2);
  margin-bottom:10px;
}
.banner.good{border-color:rgba(52,199,89,.45); background:rgba(52,199,89,.14)}
.banner.bad{border-color:rgba(255,59,48,.42); background:rgba(255,59,48,.14)}
.banner b{display:block; margin-bottom:2px; font-size:13px}
.banner small{color:var(--muted); font-size:12px}

.badge{
  display:inline-flex; align-items:center; gap:6px;
  padding:5px 8px; border-radius:999px;
  border:1px solid var(--stroke);
  background:var(--card2);
  font-size:12px; color:var(--muted);
  white-space:nowrap;
}
.badge.win{border-color:rgba(52,199,89,.45); color:rgba(52,199,89,.95); background:rgba(52,199,89,.12)}
.badge.loss{border-color:rgba(255,59,48,.42); color:rgba(255,59,48,.95); background:rgba(255,59,48,.12)}
.badge.pending{border-color:rgba(255,159,10,.45); color:rgba(255,159,10,.95); background:rgba(255,159,10,.12)}
.badge.neutral{border-color:rgba(124,143,183,.45); color:rgba(124,143,183,.95); background:rgba(124,143,183,.12)}

.list{display:flex; flex-direction:column; gap:10px}
.betCard{
  border:1px solid var(--stroke);
  background: color-mix(in srgb, var(--card2) 80%, transparent);
  border-radius:var(--radius-xl);
  padding:10px 10px;
  box-shadow: var(--shadow2);
}
.betTop{display:flex; align-items:flex-start; justify-content:space-between; gap:10px}
.betTopLeft{min-width:0; flex:1}
.betTopLeft .t1{display:flex; gap:8px; flex-wrap:wrap; align-items:center; font-size:13px; font-weight:800}
.betTopLeft .t1 .date{color:color-mix(in srgb, var(--text) 92%, transparent)}
.betTopLeft .t1 .method{color:var(--muted); font-weight:750}
.betTopLeft .t2{margin-top:6px; color:color-mix(in srgb, var(--text) 92%, transparent); font-size:13px; word-break:break-word; line-height:1.25}
.betMid{margin-top:10px; display:flex; flex-wrap:wrap; gap:10px; align-items:center}
.chip{
  padding:6px 8px; border-radius:14px;
  border:1px solid var(--stroke);
  background: color-mix(in srgb, var(--card2) 82%, transparent);
  font-size:12px; color:var(--muted);
  display:flex; gap:6px; align-items:center;
}
.chip b{color:var(--text); font-size:12px}
.chip.good b{color:rgba(52,199,89,.95)}
.chip.bad b{color:rgba(255,59,48,.95)}
.chip.warn b{color:rgba(255,159,10,.95)}
.betActions{margin-top:10px; display:flex; gap:8px; flex-wrap:wrap}

.actionBlock{
  border:1px solid var(--stroke);
  background: color-mix(in srgb, var(--card2) 82%, transparent);
  border-radius:var(--radius-xl);
  padding:12px;
  margin-top:10px;
}
.stakeBig{display:flex; align-items:baseline; justify-content:space-between; gap:10px; flex-wrap:wrap; margin-bottom:10px}
.stakeBig .label{color:var(--muted); font-size:12px}
.stakeBig .value{font-size:28px; font-weight:950; letter-spacing:.2px; font-family:var(--mono); line-height:1.05}
.stakeBig .sub{color:var(--muted); font-size:12px}
.stakeBig .right{display:flex; flex-direction:column; align-items:flex-end; gap:4px}
.stakeBig .right .pillMini{
  padding:6px 10px;
  border-radius:999px;
  border:1px solid var(--stroke);
  background: color-mix(in srgb, var(--card2) 82%, transparent);
  font-size:12px;
  color:var(--muted);
  white-space:nowrap;
}

.section{
  border:1px solid var(--stroke);
  background: color-mix(in srgb, var(--card2) 82%, transparent);
  border-radius:var(--radius-xl);
  padding:10px;
}
.sectionTitle{font-weight:800; font-size:13px; margin-bottom:8px}
.kvList{display:flex; flex-direction:column; gap:6px}
.kvItem{display:flex; justify-content:space-between; gap:10px; font-size:12px}
.kvItem .k{color:var(--muted)}
.kvItem .v{color:var(--text); font-family:var(--mono); text-align:right; overflow-wrap:anywhere}

table{
  width:100%;
  border-collapse:separate;
  border-spacing:0;
  overflow:hidden;
  border-radius:var(--radius-xl);
  border:1px solid var(--stroke);
  background: color-mix(in srgb, var(--card2) 78%, transparent);
}
th, td{
  padding:10px 10px;
  border-bottom:1px solid var(--stroke);
  text-align:left;
  font-size:13px;
  vertical-align:top;
}
th{color:var(--muted); font-weight:700; background: color-mix(in srgb, var(--card2) 70%, transparent)}
tr:last-child td{border-bottom:none}

.kpiGrid{display:grid; grid-template-columns:1fr 1fr; gap:10px}
.kpi{
  padding:10px 12px;
  border-radius:var(--radius-xl);
  border:1px solid var(--stroke);
  background: color-mix(in srgb, var(--card2) 82%, transparent);
  min-width:0;
}
.kpi span{display:block; color:var(--muted); font-size:12px}
.kpi b{display:block; font-size:16px; margin-top:2px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap}
.kpi b.good{color:rgba(52,199,89,.95)}
.kpi b.bad{color:rgba(255,59,48,.95)}
canvas{width:100%; height:auto; border-radius:var(--radius-xl); border:1px solid var(--stroke); background: color-mix(in srgb, var(--card2) 70%, transparent);}

details summary{cursor:pointer; color:color-mix(in srgb, var(--text) 92%, transparent); font-weight:850; list-style:none}
details summary::-webkit-details-marker{display:none}
.trendUp{color:rgba(52,199,89,.95)}
.trendDown{color:rgba(255,59,48,.95)}
.trendFlat{color:rgba(255,159,10,.95)}
  </style>
</head>

<body>
  <div class="topbar">
    <div class="hamburger" id="hamburger" aria-label="Apri menu" title="Menu"><span></span></div>
    <div class="brand">
      <b>BetTools</b>
      <small>V3 ‚Ä¢ NEXT ‚Ä¢ Stake v1 ‚Ä¢ UI v1.9.8</small>
    </div>
    <div class="spacer"></div>
    <button class="iconBtn" id="themeToggle" aria-label="Tema" title="Tema">‚òæ</button>
    <div class="pill" id="pillDaily">
      <span class="dot neu" id="pillDot"></span>
      <span id="pillText">Giornata: neutra</span>
    </div>
  </div>

  <div class="overlay" id="overlay"></div>

  <aside class="sidebar" id="sidebar" aria-label="Menu laterale">
    <div class="sideHeader">
      <b>Menu</b>
      <button class="closeBtn" id="closeSidebar" aria-label="Chiudi menu">‚úï</button>
    </div>
    <div class="nav" id="nav">
      <button data-page="calc" class="active">üßÆ Calcolatore <small>Operativo</small></button>
      <button data-page="storico">üìí Storico <small>Bettin.gs style</small></button>
      <button data-page="dash">üìä Dashboard <small>Latest + grafici</small></button>
      <button data-page="time">üóìÔ∏è Riepilogo temporale <small>ROC</small></button>
      <button data-page="filters">üßæ Riepilogo per filtri <small>Trend + dettaglio</small></button>
    </div>

    <div class="sideFooter">
      <div><b class="mono">Notifica V3</b></div>
      <div>Parser robusto: a capo/spazi ok. NEXT: soglia dipende solo dalla line.</div>
    </div>
  </aside>

  <main class="main">
    <!-- CALCOLATORE -->
    <section class="page active" id="page-calc">
      <h1>Calcolatore</h1>
      <div id="dailyBannerWrap"></div>

      <div class="grid leftwide">
        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Notifica LivePick (V3)</b><br/>
              <small>Incolla notifica, parse, poi aggiungi a storico.</small>
            </div>
          </div>

          <label for="lpText">Incolla notifica</label>
          <textarea id="lpText" spellcheck="false" placeholder="Incolla qui la notifica..."></textarea>

          <div class="row" style="margin-top:10px">
            <button class="btn primary" id="btnParse">Parse</button>
            <button class="btn" id="btnClear">Pulisci</button>
            <button class="btn danger" id="btnResetAll">Reset totale</button>
          </div>

          <div id="parseMsg" class="help" style="margin-top:10px"></div>

          <!-- ACTION BLOCK -->
          <div id="actionWrap"></div>
        </div>

        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Stake v1</b><br/>
              <small>Min 2% ‚Ä¢ Max 5% ‚Ä¢ BR giornaliero fisso.</small>
            </div>
          </div>

          <div class="grid" style="grid-template-columns:1fr 1fr; gap:10px">
            <div>
              <label>Bankroll attuale</label>
              <input id="bankrollInput" type="number" min="0" step="0.01" />
              <div class="help">Snapshot giornaliero creato al primo ‚ÄúAggiungi a storico‚Äù.</div>
            </div>
            <div>
              <label>Bankroll giornaliero (oggi)</label>
              <input id="bankrollDay" type="text" disabled />
            </div>
          </div>

          <div class="row" style="margin-top:10px">
            <button class="btn good" id="btnAddToHistory" disabled>‚ûï Aggiungi a storico</button>
          </div>

          <div class="help" style="margin-top:10px">
            Esito e correzioni in <b>Storico</b>. Pending/Non giocata non vengono conteggiate.
          </div>
        </div>
      </div>
    </section>

    <!-- STORICO -->
    <section class="page" id="page-storico">
      <h1>Storico</h1>

      <div class="card">
        <div class="cardHeader">
          <div>
            <b>Filtri</b><br/>
            <small>Pending/Non giocata non conteggiate.</small>
          </div>
          <div class="row">
            <select id="historyResultFilter" style="width:auto; min-width:160px">
              <option value="all">Tutte</option>
              <option value="win">Vinte</option>
              <option value="loss">Perse</option>
              <option value="pending">Pending</option>
              <option value="not_played">Non giocate</option>
            </select>
            <select id="historyDateFilter" style="width:auto; min-width:160px">
              <option value="all">Tutto</option>
              <option value="today">Oggi</option>
              <option value="yesterday">Ieri</option>
              <option value="week">Settimana corrente</option>
              <option value="month">Mese corrente</option>
            </select>
          </div>
        </div>

        <div id="historyList" class="list"></div>
        <div id="historyEmpty" class="help"></div>
      
      <div class="card" style="margin-top:12px">
        <div class="cardHeader">
          <div>
            <b>Aggiungi bet manuale</b><br/>
            <small>Inserisci i dati minimi (in pending di default). I metodi salvati compaiono in lista.</small>
          </div>
        </div>
        <div class="grid two">
          <div>
            <label class="lbl">Data</label>
            <input id="manDate" type="date"/>
          </div>
          <div>
            <label class="lbl">Metodo</label>
            <select id="manMethod"></select>
            <input id="manMethodNew" type="text" placeholder="oppure scrivi nuovo metodo..." style="margin-top:6px"/>
          </div>
        </div>
        <div style="margin-top:10px">
          <label class="lbl">Match</label>
          <input id="manMatch" type="text" placeholder="Es: TeamA-TeamB"/>
        </div>
        <div style="margin-top:10px">
          <label class="lbl">Pick (testo)</label>
          <input id="manPick" type="text" placeholder="Es: FT Next Over 1.5"/>
        </div>
        <div class="grid two" style="margin-top:10px">
          <div>
            <label class="lbl">Quota</label>
            <input id="manOdds" type="number" step="0.01" placeholder="1.80"/>
          </div>
          <div>
            <label class="lbl">Stake ‚Ç¨</label>
            <input id="manStake" type="number" step="0.1" placeholder="2.0"/>
          </div>
        </div>
        <div class="row" style="margin-top:12px; justify-content:space-between">
          <button class="btn" id="btnAddManual">Aggiungi manuale</button>
          <small class="help" id="manHelp"></small>
        </div>
      </div>
</div>

      <div class="grid two" style="margin-top:12px">
        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Dettagli bet</b><br/>
              <small>Qui vedi <b>TUTTI i campi arrivati dalla notifica</b>.</small>
            </div>
            <div class="row">
              <button class="btn" id="btnToggleRaw" disabled>Mostra JSON raw</button>
            </div>
          </div>
          <div id="detailsBox" class="help">Seleziona ‚ÄúDettagli‚Äù su una bet.</div>
        </div>

        
        <div class="card">
          <div class="cardHeader">
            <div><b>Modello NB (da Python)</b><br/><span class="muted">Incolla qui il JSON prodotto da <code>02_train_nb_calibrate.py</code> (model_ft.json + model_ht.json gi√† fusi).</span></div>
          </div>
          <div class="cardBody">
            <textarea id="nbJson" class="ta" rows="6" placeholder='{"version":"nb_offset_isotonic_v2", ...}'></textarea>
            <div class="row">
              <button class="btn" id="btnNbSave">Salva modello</button>
              <button class="btn ghost" id="btnNbClear">Svuota</button>
              <span class="pill" id="nbStatus">NB: non caricato</span>
            </div>
            <div class="help">Il modello viene salvato in locale (localStorage) sul telefono.</div>
          </div>
        </div>

<div class="card">
          <div class="cardHeader">
            <div>
              <b>Backup / Restore</b><br/>
              <small>JSON completo (storico + impostazioni).</small>
            </div>
          </div>

          <div class="row">
            <button class="btn primary" id="btnBackup">‚¨áÔ∏è Backup</button>
            <label class="btn" style="cursor:pointer">
              ‚¨ÜÔ∏è Restore
              <input type="file" id="restoreFile" accept="application/json" style="display:none"/>
            </label>
          </div>

          <div class="row" style="margin-top:10px">
            <button class="btn danger" id="btnClearHistory">Svuota storico</button>
            <button class="btn" id="btnRecalc">Ricalcola</button>
          </div>

          <div class="help" style="margin-top:10px" id="backupMsg"></div>
        </div>
      </div>
    </section>

    <!-- DASHBOARD -->
    <section class="page" id="page-dash">
      <h1>Dashboard</h1>

      <div class="card">
        <div class="cardHeader">
          <div>
            <b>Filtro periodo</b><br/>
            <small>Influenza KPI e grafici.</small>
          </div>
          <div class="row">
            <select id="dashRangeSelect" style="width:auto; min-width:220px">
              <option value="all" selected>Tutto</option>
              <option value="today">Oggi</option>
              <option value="yesterday">Ieri</option>
              <option value="week">Settimana corrente</option>
              <option value="month">Mese corrente</option>
            </select>
          </div>
        </div>

        <!-- 3 righe esatte (2 colonne) = 6 KPI -->
        <div class="kpiGrid" id="dashKpis"></div>
      </div>

      <div class="grid two" style="margin-top:12px">
        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Win Rate</b><br/>
              <small>Solo bet chiuse.</small>
            </div>
          </div>
          <canvas id="donut" width="520" height="360"></canvas>
          <div class="row" style="margin-top:8px; justify-content:space-between">
            <div class="badge win" id="wonLabel">Won: ‚Äî</div>
            <div class="badge loss" id="lostLabel">Lost: ‚Äî</div>
          </div>
        </div>

        <div class="card">
          <div class="cardHeader">
            <div>
              <b>Profit Chart</b><br/>
              <small>Cumulato bet chiuse.</small>
            </div>
            <div class="row">
              <select id="profitRangeSelect" style="width:auto; min-width:140px">
                <option value="1m" selected>1m</option>
                <option value="3m">3m</option>
                <option value="6m">6m</option>
                <option value="12m">12m</option>
                <option value="all">all</option>
              </select>
            </div>
          </div>
          <canvas id="profitChart" width="820" height="360"></canvas>
          <div class="help" style="margin-top:8px">Area tutta verde se cumulato finale > 0, tutta rossa se < 0.</div>
        </div>
      </div>

      <!-- Latest Bets -->
      <div class="card" style="margin-top:12px">
        <div class="cardHeader">
          <div>
            <b>Latest Bets</b><br/>
            <small>Ultime bet (layout identico a Storico).</small>
          </div>
          <div class="row">
            <button class="btn" id="btnGoStorico">Apri Storico</button>
          </div>
        </div>
        <div id="latestList" class="list"></div>
        <div id="latestEmpty" class="help"></div>
      </div>

      <div class="card" style="margin-top:12px">
        <div class="cardHeader">
          <div>
            <b>Impostazioni Bankroll</b><br/>
            <small>Usato per stake e snapshot giornaliero.</small>
          </div>
        </div>
        <div class="grid two">
          <div>
            <label>Bankroll attuale</label>
            <input id="bankrollInputDash" type="number" min="0" step="0.01" />
          </div>
          <div>
            <label>Azioni</label>
            <div class="row">
              <button class="btn primary" id="btnSaveBR">Salva bankroll</button>
              <button class="btn" id="btnNewDay">Nuova giornata</button>
            </div>
          </div>
        </div>
        <div class="help" id="dashMsg" style="margin-top:8px"></div>
      </div>
    </section>

    <!-- TIME SUMMARY -->
    <section class="page" id="page-time">
      <h1>Riepilogo temporale</h1>

      <div class="card">
        <div class="cardHeader">
          <div>
            <b>Raggruppa</b><br/>
            <small>Stato solo per Giorno. ROC basato su bankroll inizio giornata.</small>
          </div>
          <div class="row">
            <select id="timeGroupSelect" style="width:auto; min-width:180px">
              <option value="day" selected>Giorni</option>
              <option value="week">Settimane</option>
              <option value="month">Mesi</option>
            </select>
          </div>
        </div>

        <div class="help" id="timeEmpty"></div>
        <div style="overflow:auto">
          <table id="timeTable" style="display:none">
            <thead>
              <tr>
                <th>Periodo</th>
                <th>Bet</th>
                <th>Winrate</th>
                <th>Profitto</th>
                <th>ROI</th>
                <th>ROC</th>
                <th>Stato</th>
              </tr>
            </thead>
            <tbody id="timeBody"></tbody>
          </table>
        </div>
      </div>
    </section>

    <!-- FILTER SUMMARY -->
    <section class="page" id="page-filters">
      <h1>Riepilogo per filtri</h1>

      <div class="card">
        <div class="cardHeader">
          <div>
            <b>Ordinamento</b><br/>
            <small>Default ROI (migliore ‚Üí peggiore).</small>
          </div>
          <div class="row">
            <select id="filterSort" style="width:auto; min-width:220px">
              <option value="roi" selected>Ordina: ROI</option>
              <option value="profit">Ordina: Profitto</option>
              <option value="winrate">Ordina: % Vinte</option>
              <option value="bets">Ordina: Bet giocate</option>
              <option value="name">Ordina: Tipo scommessa</option>
            </select>
          </div>
        </div>
        <div class="help">Trend = confronto ROI ultimi 30 giorni vs 30 giorni precedenti (chiuse).</div>
      </div>

      <div class="grid two" id="filtersGrid" style="margin-top:12px"></div>
    </section>
  </main>


<script>
/* ================================
   BetTools ‚Äî UI v1.9 (hotfix)
   - adds toast()
   - fixes parseODDS -> parseODDSTOBET
   ================================ */
(function(){
  const HOST_ID = "toast-host";
  function ensureHost(){
    let host = document.getElementById(HOST_ID);
    if(host) return host;
    host = document.createElement("div");
    host.id = HOST_ID;
    host.style.position = "fixed";
    host.style.left = "0";
    host.style.right = "0";
    host.style.bottom = "18px";
    host.style.zIndex = "99999";
    host.style.display = "flex";
    host.style.flexDirection = "column";
    host.style.alignItems = "center";
    host.style.gap = "10px";
    host.style.pointerEvents = "none";
    document.body.appendChild(host);
    return host;
  }
  // toast("test"), toast("ok","success"), toast("warn","warn"), toast("err","error")
  window.toast = function(msg, kind="info", ms=2400){
    try{
      const host = ensureHost();
      const el = document.createElement("div");
      el.textContent = String(msg ?? "");
      el.style.maxWidth = "92vw";
      el.style.padding = "10px 12px";
      el.style.borderRadius = "14px";
      el.style.fontSize = "13px";
      el.style.fontWeight = "600";
      el.style.letterSpacing = ".2px";
      el.style.backdropFilter = "blur(12px)";
      el.style.webkitBackdropFilter = "blur(12px)";
      el.style.border = "1px solid rgba(255,255,255,.14)";
      el.style.boxShadow = "0 10px 30px rgba(0,0,0,.35)";
      el.style.pointerEvents = "none";
      const bg = {
        info: "rgba(40,40,48,.78)",
        success: "rgba(20,90,45,.78)",
        warn: "rgba(110,75,10,.80)",
        error: "rgba(120,25,25,.80)"
      }[kind] || "rgba(40,40,48,.78)";
      el.style.background = bg;
      el.style.color = "rgba(255,255,255,.92)";
      el.style.transform = "translateY(6px)";
      el.style.opacity = "0";
      el.style.transition = "opacity 160ms ease, transform 160ms ease";
      host.appendChild(el);
      requestAnimationFrame(()=>{ el.style.opacity="1"; el.style.transform="translateY(0)"; });
      setTimeout(()=>{
        el.style.opacity="0"; el.style.transform="translateY(6px)";
        setTimeout(()=>{ el.remove(); }, 220);
      }, Math.max(900, Number(ms)||2400));
    }catch(e){
      // last resort
      console.log("toast:", msg);
    }
  };
})();
</script>
<script>

/* =========================
   State
========================= */
const STORAGE_KEY = "bettools_v3_uiv1.7a";
const DEFAULT_STATE = {
  version: "V3_SIMPLIFIED_UI162",
  settings: { bankroll: 100 },
  dailySnapshot: { date: null, bankroll: null },
  history: []
};

function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return structuredClone(DEFAULT_STATE);
    const st = JSON.parse(raw);
    if(!st.settings) st.settings = structuredClone(DEFAULT_STATE.settings);
    if(!st.dailySnapshot) st.dailySnapshot = structuredClone(DEFAULT_STATE.dailySnapshot);
    if(!Array.isArray(st.history)) st.history = [];
    if(!Array.isArray(st.methods)) st.methods = [];
    if(!st.methodLP) st.methodLP = {};
    return st;
  }catch(e){
    return structuredClone(DEFAULT_STATE);
  }
}
function saveState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }

function upsertMethod(name, lpObj){
  const m = (name||"").trim();
  if(!m) return;
  if(!Array.isArray(state.methods)) state.methods=[];
  if(!state.methods.includes(m)) state.methods.unshift(m);
  // keep a light LP snapshot per method (from latest notification)
  if(lpObj){
    if(!state.methodLP) state.methodLP={};
    state.methodLP[m] = {
      WR: safeNum(lpObj.WR),
      ROI: safeNum(lpObj.ROI),
      Profit: safeNum(lpObj.Profit),
      AO: safeNum(lpObj.AO),
      N: safeNum(lpObj.N),
      ts: Date.now()
    };
  }
}
function upsertMethodFromBet(b){
  if(!b) return;
  upsertMethod(b?.meta?.Method, b?.lp);
}

function renderMethodSelect(){
  const sel = document.getElementById("manMethod");
  if(!sel) return;
  const methods = Array.isArray(state.methods) ? state.methods : [];
  const cur = sel.value;
  sel.innerHTML = "";
  const opt0 = document.createElement("option");
  opt0.value = "";
  opt0.textContent = "‚Äî seleziona ‚Äî";
  sel.appendChild(opt0);
  for(const m of methods){
    const o = document.createElement("option");
    o.value = m;
    o.textContent = m;
    sel.appendChild(o);
  }
  if(cur && methods.includes(cur)) sel.value = cur;
}


function resetAll(){
  localStorage.removeItem(STORAGE_KEY);
  state = structuredClone(DEFAULT_STATE);
  saveState();
  renderAll();
}
let state = loadState();

// --- NB model (from Python 02_train_nb_calibrate.py) ---
const NB_STORAGE_KEY = "bt_nb_model_json_v1";
function loadNbModel(){
  try{
    const raw = localStorage.getItem(NB_STORAGE_KEY);
    if(!raw) return null;
    return JSON.parse(raw);
  }catch(e){ console.warn("NB load failed", e); return null; }
}
function saveNbModel(rawStr){
  const obj = JSON.parse(rawStr);
  localStorage.setItem(NB_STORAGE_KEY, JSON.stringify(obj));
  return obj;
}
function clearNbModel(){ localStorage.removeItem(NB_STORAGE_KEY); }
function isoMap(x, xs, ys){
  // piecewise-constant isotonic mapping (threshold arrays may contain duplicates)
  if(!xs || !ys || !xs.length) return x;
  // If x is below first threshold -> first y
  if(x <= xs[0]) return ys[0];
  for(let i=1;i<xs.length;i++){
    if(x <= xs[i]) return ys[i];
  }
  return ys[ys.length-1];
}
function nbProbGE(mu, alpha, k){
  if(k<=0) return 1.0;
  const r = 1.0/Math.max(alpha, 1e-9);
  const p = r/(r+Math.max(mu, 1e-12)); // "success" prob in NB parameterization
  const q = 1.0 - p;
  // PMF(0) = p^r
  const P0 = Math.pow(p, r);
  if(k===1) return 1.0 - P0;
  // PMF(1) = r * q * p^r
  const P1 = P0 * r * q;
  if(k===2) return 1.0 - (P0 + P1);
  // PMF(2) = ((r)(r+1)/2) * q^2 * p^r
  const P2 = P1 * (r+1) * q / 2.0;
  return 1.0 - (P0 + P1 + P2);
}
function nbMatchProbFromModel(model, feats, rem, k){
  const coef = model.coef || {};
  let eta = (coef.const ?? 0);
  for(const f of (model.features||[])){
    if(f==="const") continue;
    if(f in feats) eta += (coef[f] ?? 0) * (Number(feats[f]) || 0);
  }
  eta += Math.log(Math.max(rem, 1e-6)); // offset
  const mu = Math.exp(eta);
  const raw = nbProbGE(mu, model.alpha ?? 0.5, k);
  const cal = (model.calibrators||{})[String(k)];
  const pcal = cal ? isoMap(raw, cal.x_thresholds, cal.y_thresholds) : raw;
  return {p: clamp01(pcal), raw: clamp01(raw), mu};
}


/* =========================
   Utils
========================= */
function todayISO(){
  const d = new Date();
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth()+1).padStart(2,"0");
  const dd = String(d.getDate()).padStart(2,"0");
  return `${yyyy}-${mm}-${dd}`;
}
function yesterdayISO(){
  const d = new Date();
  d.setDate(d.getDate()-1);
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth()+1).padStart(2,"0");
  const dd = String(d.getDate()).padStart(2,"0");
  return `${yyyy}-${mm}-${dd}`;
}
function fmtMoney(x){
  if(x === null || x === undefined || Number.isNaN(Number(x))) return "‚Äî";
  return Number(x).toLocaleString("it-IT",{minimumFractionDigits:2, maximumFractionDigits:2});
}
function fmtPct(x){
  if(x === null || x === undefined || Number.isNaN(Number(x))) return "‚Äî";
  return (Number(x)*100).toLocaleString("it-IT",{minimumFractionDigits:2, maximumFractionDigits:2}) + "%";
}
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
function clamp01(x){ return Math.max(0, Math.min(1, Number(x)||0)); }
function safeNum(v){
  if(v === null || v === undefined) return null;
  const s = String(v).trim();
  if(s.toLowerCase()==="null" || s==="") return null;
  const n = Number(s.replace(",", "."));
  return Number.isFinite(n) ? n : null;
}
function sum(arr){ return arr.reduce((a,b)=>a+(Number(b)||0),0); }
function escapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
function startOfWeekISO(dISO){
  const d = new Date(dISO+"T00:00:00");
  const day = (d.getDay()+6)%7; // Mon=0..Sun=6
  d.setDate(d.getDate()-day);
  return d.toISOString().slice(0,10);
}
function monthKey(dISO){ return dISO.slice(0,7); }
function inDateRange(dISO, range){
  if(range==="all") return true;
  const t = todayISO();
  if(range==="today") return dISO===t;
  if(range==="yesterday") return dISO===yesterdayISO();
  if(range==="week"){
    const sow = startOfWeekISO(t);
    return dISO >= sow && dISO <= t;
  }
  if(range==="month"){
    const ym = t.slice(0,7);
    return dISO.slice(0,7)===ym;
  }
  return true;
}
function addDays(dateISO, days){
  const d = new Date(dateISO+"T00:00:00");
  d.setDate(d.getDate()+days);
  return d.toISOString().slice(0,10);
}
function withinDays(dateISO, daysBack){
  const d = new Date(dateISO+"T00:00:00");
  const now = new Date();
  const cutoff = new Date(now);
  cutoff.setDate(cutoff.getDate()-daysBack);
  return d >= cutoff;
}
function roundStake1decMin1(x){
  const n = Number(x||0);
  const r = Math.round(n*10)/10;
  return Math.max(1, r);
}

/* =========================
   Navigation
========================= */
const overlay = document.getElementById("overlay");
const sidebar = document.getElementById("sidebar");
document.getElementById("hamburger").addEventListener("click", ()=>{
  sidebar.classList.add("show"); overlay.classList.add("show");
});
document.getElementById("closeSidebar").addEventListener("click", closeSidebar);
overlay.addEventListener("click", closeSidebar);
function closeSidebar(){
  sidebar.classList.remove("show"); overlay.classList.remove("show");
}
document.getElementById("nav").addEventListener("click",(e)=>{
  const btn = e.target.closest("button[data-page]");
  if(!btn) return;
  setPage(btn.getAttribute("data-page"));
  closeSidebar();
});
function setPage(page){
  document.querySelectorAll(".page").forEach(p=>p.classList.remove("active"));
  document.getElementById("page-"+page).classList.add("active");
  document.querySelectorAll("#nav button").forEach(b=>b.classList.remove("active"));
  const active = document.querySelector(`#nav button[data-page="${page}"]`);
  if(active) active.classList.add("active");

  if(page==="storico") renderHistory();
  if(page==="dash") renderDashboard();
  if(page==="time") renderTimeSummary();
  if(page==="filters") renderFilters();
}

/* =========================
   Parser V3
========================= */
const TAGS = ["META","STATE","STATS","L10","PROB","PRESS","LATE","ODDS_TO_BET","LP"];
function normalizeText(s){
  return String(s || "")
    .replace(/\r/g,"\n")
    .replace(/[ \t]+/g," ")
    .replace(/\n+/g,"\n");
}
function extractBlocks(text){
  const t = normalizeText(text);
  const hits = [];
  const scanRe = new RegExp(`\\b(${TAGS.join("|")})\\s*\\|`, "g");
  let m;
  while((m=scanRe.exec(t))!==null) hits.push({tag:m[1], idx:m.index});
  hits.sort((a,b)=>a.idx-b.idx);
  const blocks = {};
  for(let i=0;i<hits.length;i++){
    const start = hits[i].idx;
    const end = (i+1<hits.length) ? hits[i+1].idx : t.length;
    blocks[hits[i].tag] = t.slice(start, end).trim();
  }
  return blocks;
}
function parsePipeKVs(chunk){
  const parts = chunk.split("|").map(x=>x.trim()).filter(Boolean);
  const kvs = {};
  for(let i=1;i<parts.length;i++){
    const p = parts[i];
    const eq = p.indexOf("=");
    if(eq===-1) continue;
    const k = p.slice(0,eq).trim();
    const v = p.slice(eq+1).trim();
    kvs[k] = v;
  }
  return kvs;
}
function parseScore(s){
  if(!s) return {home:null, away:null};
  const m = String(s).match(/(\d+)\s*-\s*(\d+)/);
  if(!m) return {home:null, away:null};
  return {home:Number(m[1]), away:Number(m[2])};
}
function parseHA(s){
  if(!s) return {home:null, away:null};
  const m = String(s).match(/(-?\d+(\.\d+)?)\s*[/\-]\s*(-?\d+(\.\d+)?)/);
  if(!m) return {home:null, away:null};
  return {home:safeNum(m[1]), away:safeNum(m[3])};
}
function parsePROB(chunk){
  const out = {HT:{}, FT:{}};
  const ht = chunk.match(/HT\s*\(([^)]*)\)/i);
  const ft = chunk.match(/FT\s*\(([^)]*)\)/i);
  if(ht){
    ht[1].split(",").forEach(pair=>{
      const m = pair.match(/\+(\d+)\s*=\s*([0-9.,-]+)/);
      if(m) out.HT[Number(m[1])] = safeNum(m[2]);
    });
  }
  if(ft){
    ft[1].split(",").forEach(pair=>{
      const m = pair.match(/\+(\d+)\s*=\s*([0-9.,-]+)/);
      if(m) out.FT[Number(m[1])] = safeNum(m[2]);
    });
  }
  return out;
}
function parsePRESS(chunk){
  const out = {
    GPI: {M_all:null, M_l10:null},
    GMS: {H_all:null,H_l10:null, A_all:null,A_l10:null, M_all:null,M_l10:null},
    SI:  {M_all:null, M_l10:null}
  };
  const gpi = chunk.match(/GPI\s*\(\s*M\s*=\s*([0-9.,-]+)\s*,\s*L10\s*=\s*([0-9.,-]+)\s*\)/i);
  if(gpi){ out.GPI.M_all=safeNum(gpi[1]); out.GPI.M_l10=safeNum(gpi[2]); }
  const gms = chunk.match(/GMS\s*\(\s*H\s*=\s*([0-9.,-]+)\s*\/\s*([0-9.,-]+)\s*,\s*A\s*=\s*([0-9.,-]+)\s*\/\s*([0-9.,-]+)\s*,\s*M\s*=\s*([0-9.,-]+)\s*\/\s*([0-9.,-]+)\s*\)/i);
  if(gms){
    out.GMS.H_all=safeNum(gms[1]); out.GMS.H_l10=safeNum(gms[2]);
    out.GMS.A_all=safeNum(gms[3]); out.GMS.A_l10=safeNum(gms[4]);
    out.GMS.M_all=safeNum(gms[5]); out.GMS.M_l10=safeNum(gms[6]);
  }
  const si = chunk.match(/SI\s*\(\s*M\s*=\s*([0-9.,-]+)\s*\/\s*([0-9.,-]+)\s*\)/i);
  if(si){ out.SI.M_all=safeNum(si[1]); out.SI.M_l10=safeNum(si[2]); }
  return out;
}
function parseLATE(chunk){
  const kv = parsePipeKVs(chunk);
  return { AT:safeNum(kv.AT), L10:safeNum(kv.L10), L5:safeNum(kv.L5) };
}
function parseODDSTOBET(chunk){
  const m = chunk.match(/ODDS_TO_BET\s*\|\s*(.+?)\s*[:=]\s*([0-9.,]+)/i);
  if(!m) return null;
  const label = m[1].trim().replace(/\s+/g," ");
  const odds = safeNum(m[2]);
  const ph = label.match(/\b(HT|FT)\b/i);
  const phase = ph ? ph[1].toUpperCase() : null;
  const lineM = label.match(/([0-9]+(\.[0-9]+)?)\b/);
  const line = lineM ? safeNum(lineM[1]) : null;
  let market = label;
  if(phase) market = market.replace(new RegExp("\\b"+phase+"\\b","i"),"").trim();
  if(line !== null) market = market.replace(new RegExp(String(line).replace(".","\\.")),"").trim();
  market = market.replace(/\s+/g," ").trim();
  return { label, phase, market, line, odds_ref: odds };
}
// Backward-compat alias (older builds referenced parseODDS)
const parseODDS = parseODDSTOBET;

function parseLP(chunk){
  const kv = parsePipeKVs(chunk);
  const wr = safeNum(kv.WR);
  const roi = safeNum(kv.ROI);
  return {
    WR: wr===null ? null : wr/100,
    ROI: roi===null ? null : roi/100,
    Profit: safeNum(kv.Profit),
    AO: safeNum(kv.AO),
    N: safeNum(kv.N)
  };
}
/* ==========================================
   FIX LETTURA STATISTICHE (SOT, CORNER, ECC.)
   Cerca la funzione parseStatsLine e sostituiscila con questa
   ========================================== */
function parseStatsLine(chunk){
  // chunk like: "STATS | SOT=4/0 | SOFF=1/0 | COR=1/0 | ATT=34/16 | DATT=20/7"
  const kv = parsePipeKVs(chunk);
  const sot = parseHA(kv.SOT), soff = parseHA(kv.SOFF), cor = parseHA(kv.COR), att = parseHA(kv.ATT), datt = parseHA(kv.DATT);
  
  // FIX CRUCIALE: Uso .home e .away (come restituito da parseHA) invece di .h e .a
  return {
    SOT_H: sot.home, SOT_A: sot.away,
    SOFF_H: soff.home, SOFF_A: soff.away,
    COR_H: cor.home, COR_A: cor.away,
    ATT_H: att.home, ATT_A: att.away,
    DATT_H: datt.home, DATT_A: datt.away
  };
}
function parseMETA(chunk){
  const kv = parsePipeKVs(chunk);
  return { Ver:(kv.Ver||"").trim(), Method:(kv.Method||"").trim(), Comp:(kv.Comp||"").trim(), Match:(kv.Match||"").trim() };
}
function parseSTATE(chunk){
  const kv = parsePipeKVs(chunk);
  const sc = parseScore(kv.Score);
  const remht = safeNum(kv.RemHT);
  return {
    Time: safeNum(kv.Time),
    RemHT: remht!==null && remht<0 ? 0 : remht,
    RemFT: safeNum(kv.RemFT),
    ScoreHome: sc.home,
    ScoreAway: sc.away,
    ScoreRaw: kv.Score ? String(kv.Score).trim() : ""
  };
}
function parseNotification(text){
  const blocks = extractBlocks(text || "");
  
  // Controllo blocchi minimi richiesti
  if(!blocks.META || !blocks.STATE || !blocks.ODDS_TO_BET){
    // Restituisco un errore formattato correttamente per la tua UI
    return { 
      ok: false, 
      errors: ['Formato notifica non valido: mancano META, STATE o ODDS_TO_BET.'] 
    };
  }

  try {
    // Costruisco l'oggetto dati
    const parsedData = {
      raw:text,
      meta: parseMETA(blocks.META),
      state: parseSTATE(blocks.STATE),
      stats: blocks.STATS ? parseStatsLine(blocks.STATS) : {},
      l10: blocks.L10 ? parseStatsLine(blocks.L10) : {},
      press: blocks.PRESS ? parsePRESS(blocks.PRESS) : {},
      late: blocks.LATE ? parseLATE(blocks.LATE) : {},
      oddsToBet: parseODDSTOBET(blocks.ODDS_TO_BET),
      lp: blocks.LP ? parseLP(blocks.LP) : null,
      prob: blocks.PROB ? parsePROB(blocks.PROB) : null
    };

    // FIX: Avvolgo tutto in { ok: true, data: ... } come si aspetta il bottone Parse
    return {
      ok: true,
      data: parsedData,
      warnings: []
    };

  } catch (e) {
    return { 
      ok: false, 
      errors: ["Errore imprevisto durante la lettura dei dati: " + e.message] 
    };
  }
}

/* =========================
   Stake v1 (NEXT) ‚Äî ALWAYS RETURNS STAKE%
========================= */
function betKeyFromParsed(parsed){
  const m = (parsed?.meta?.Method || "").trim();
  return m;
}

function neededGoalsFromLine_NEXT(line){
  if(line===null) return null;
  return Math.floor(line) + 1;
}
function poissonTail(lmbda, kPlus){
  if(lmbda===null || !isFinite(lmbda) || lmbda<0) return null;
  if(kPlus<=0) return 1;
  // P(X>=k) = 1 - sum_{i=0}^{k-1} e^-Œª Œª^i / i!
  let cdf = 0;
  let term = Math.exp(-lmbda);
  cdf += term;
  for(let i=1;i<kPlus;i++){
    term *= (lmbda / i);
    cdf += term;
  }
  const tail = 1 - cdf;
  return Math.max(0, Math.min(1, tail));
}

// Coefficienti Poisson (dal tuo fit) mappati su feature calcolabili dalla notifica
const COEF_FT = {
  intercept: -2.6475635256031107,
  Minutes_Remaining_FT: -0.006482651719136978,
  Goals_Scored_So_far: -0.0044240769590670696,
  Avg_Pressure_Score_FT: 0.10380587431713764,
  Avg_SOT_per_min: 5.719900475694123,
  Avg_SOFF_per_min: 0.49538875040487773,
  Avg_CORNER_per_min: 63.719664341487004,
  Avg_DA_per_min: -6.269252023077126,
  Avg_ATT_per_min: 3.406240419112395,
  Avg_SOT_L10_perMin: -2.4686199505970894,
  Avg_SOFF_L10_perMin: 17.476960312147803,
  Avg_CORNERS_L10_perMin: -31.64183110501638,
  Avg_DA_L10_perMin: -0.1817192173389214,
  Avg_ATT_L10_perMin: -2.433659065386576,
  picked_minute: 0.006482651719135257
};

const COEF_HT = {
  intercept: 0.0933197447847644,
  Minutes_Remaining_HT: 0.024047541890786263,
  Goals_Scored_So_far: 0.019299705976413097,
  Avg_Pressure_Score_FT: 0.022092738498312343,
  Avg_SOT_per_min: 0.1439228811175211,
  Avg_SOFF_per_min: 4.532687953230974,
  Avg_CORNER_per_min: 38.028892067740664,
  Avg_DA_per_min: 1.4984146913952283,
  Avg_ATT_per_min: -4.212725592191199,
  Avg_SOT_L10_perMin: -0.5929748033384535,
  Avg_SOFF_L10_perMin: -1.503362285114244,
  Avg_CORNERS_L10_perMin: -7.347130283107119,
  Avg_DA_L10_perMin: -0.6784695295588267,
  Avg_ATT_L10_perMin: 1.6335777635106252,
  picked_minute: -0.0240475418907835
};

function safeNum(x){
  const n = Number(x);
  return (isFinite(n) ? n : 0);
}

function computeRatesFromParsed(parsed){
  const t = safeNum(parsed.state.Time);
  const denom = Math.max(1, t); // uso Time (minuti giocati)
  const stats = parsed.stats || {};
  const l10 = parsed.l10 || {};

  const hSOT = safeNum(stats.SOT_H), aSOT = safeNum(stats.SOT_A);
  const hSOFF = safeNum(stats.SOFF_H), aSOFF = safeNum(stats.SOFF_A);
  const hCOR = safeNum(stats.COR_H), aCOR = safeNum(stats.COR_A);
  const hATT = safeNum(stats.ATT_H), aATT = safeNum(stats.ATT_A);
  const hDA  = safeNum(stats.DATT_H), aDA  = safeNum(stats.DATT_A);

  const hSOT10 = safeNum(l10.SOT_H), aSOT10 = safeNum(l10.SOT_A);
  const hSOFF10 = safeNum(l10.SOFF_H), aSOFF10 = safeNum(l10.SOFF_A);
  const hCOR10 = safeNum(l10.COR_H), aCOR10 = safeNum(l10.COR_A);
  const hATT10 = safeNum(l10.ATT_H), aATT10 = safeNum(l10.ATT_A);
  const hDA10  = safeNum(l10.DATT_H), aDA10  = safeNum(l10.DATT_A);

  const sumSOTpm = (hSOT + aSOT) / denom;
  const sumSOFFpm = (hSOFF + aSOFF) / denom;
  const sumCORpm = (hCOR + aCOR) / denom;
  const sumATTpm = (hATT + aATT) / denom;
  const sumDApm  = (hDA + aDA) / denom;

  const sumSOTl10 = (hSOT10 + aSOT10) / 10.0;
  const sumSOFFl10 = (hSOFF10 + aSOFF10) / 10.0;
  const sumCORl10 = (hCOR10 + aCOR10) / 10.0;
  const sumATTl10 = (hATT10 + aATT10) / 10.0;
  const sumDAl10  = (hDA10 + aDA10) / 10.0;

  // pressure proxy: usa GPI(M) se disponibile, altrimenti 0
  const gpiM = parsed.press?.GPI_M;
  const pressure = (gpiM!==null && isFinite(gpiM)) ? (gpiM/100.0) : 0; // scala "ragionevole"

  return {
    t,
    sumSOTpm, sumSOFFpm, sumCORpm, sumATTpm, sumDApm,
    sumSOTl10, sumSOFFl10, sumCORl10, sumATTl10, sumDAl10,
    pressure
  };
}

function lambdaFromCoefs_FT(parsed){
  const r = computeRatesFromParsed(parsed);
  const goalsSoFar = safeNum(parsed.state.Score_H) + safeNum(parsed.state.Score_A);
  const remFT = safeNum(parsed.state.RemFT);
  const pm = safeNum(parsed.state.Time);

  let lin = COEF_FT.intercept;
  lin += COEF_FT.Minutes_Remaining_FT * remFT;
  lin += COEF_FT.Goals_Scored_So_far * goalsSoFar;
  lin += COEF_FT.Avg_Pressure_Score_FT * r.pressure;
  lin += COEF_FT.Avg_SOT_per_min * r.sumSOTpm;
  lin += COEF_FT.Avg_SOFF_per_min * r.sumSOFFpm;
  lin += COEF_FT.Avg_CORNER_per_min * r.sumCORpm;
  lin += COEF_FT.Avg_DA_per_min * r.sumDApm;
  lin += COEF_FT.Avg_ATT_per_min * r.sumATTpm;
  lin += COEF_FT.Avg_SOT_L10_perMin * r.sumSOTl10;
  lin += COEF_FT.Avg_SOFF_L10_perMin * r.sumSOFFl10;
  lin += COEF_FT.Avg_CORNERS_L10_perMin * r.sumCORl10;
  lin += COEF_FT.Avg_DA_L10_perMin * r.sumDAl10;
  lin += COEF_FT.Avg_ATT_L10_perMin * r.sumATTl10;
  lin += COEF_FT.picked_minute * pm;

  let lam = Math.exp(lin);
  if(!isFinite(lam)) lam = 0;
  lam = Math.max(0, Math.min(50, lam));
  return lam;
}

function lambdaFromCoefs_HT(parsed){
  const r = computeRatesFromParsed(parsed);
  const goalsSoFar = safeNum(parsed.state.Score_H) + safeNum(parsed.state.Score_A);
  const remHT = safeNum(parsed.state.RemHT);
  const pm = safeNum(parsed.state.Time);

  let lin = COEF_HT.intercept;
  lin += COEF_HT.Minutes_Remaining_HT * remHT;
  lin += COEF_HT.Goals_Scored_So_far * goalsSoFar;
  lin += COEF_HT.Avg_Pressure_Score_FT * r.pressure;
  lin += COEF_HT.Avg_SOT_per_min * r.sumSOTpm;
  lin += COEF_HT.Avg_SOFF_per_min * r.sumSOFFpm;
  lin += COEF_HT.Avg_CORNER_per_min * r.sumCORpm;
  lin += COEF_HT.Avg_DA_per_min * r.sumDApm;
  lin += COEF_HT.Avg_ATT_per_min * r.sumATTpm;
  lin += COEF_HT.Avg_SOT_L10_perMin * r.sumSOTl10;
  lin += COEF_HT.Avg_SOFF_L10_perMin * r.sumSOFFl10;
  lin += COEF_HT.Avg_CORNERS_L10_perMin * r.sumCORl10;
  lin += COEF_HT.Avg_DA_L10_perMin * r.sumDAl10;
  lin += COEF_HT.Avg_ATT_L10_perMin * r.sumATTl10;
  lin += COEF_HT.picked_minute * pm;

  let lam = Math.exp(lin);
  if(!isFinite(lam)) lam = 0;
  lam = Math.max(0, Math.min(50, lam));
  return lam;
}

function legacyMatchProbability_NEXT(parsed){
  const phase = parsed.oddsToBet.phase;
  const line = parsed.oddsToBet.line;
  if(!phase || line===null) return {p:null, needed:null, reason:"Phase o Line non disponibili"};
  const needed = neededGoalsFromLine_NEXT(line);

  // 1) Se il blocco PROB esiste, usalo (retrocompatibilit√†)
  if(parsed.prob && parsed.prob[phase]){
    const table = parsed.prob[phase];
    const p = table ? table[needed] : null;
    if(p!==undefined && p!==null) return {p, needed, reason:null};
  }

  // 2) Altrimenti calcola da modello Poisson (coeff del tuo fit)
  let lam = null;
  if(phase==="FT") lam = lambdaFromCoefs_FT(parsed);
  else lam = lambdaFromCoefs_HT(parsed);

  const p = poissonTail(lam, needed);
  if(p===null) return {p:null, needed, reason:"Impossibile stimare probabilit√† (lambda null)"};

  return {p, needed, reason:null, lambda: lam};
}
/* ==========================================
   PARTE 1: MOTORE MATEMATICO V2 (FIX DISPERSIONE R)
   Sostituisci le funzioni nbPmf, nbProbGE, extractFeaturesV2 e computeV2Mu
   ========================================== */

// FIX 1: Probabilit√† >= k. Ora usa 'r' direttamente dal JSON senza invertirlo.
function nbProbGE(mu, r_param, k) {
  if (k <= 0) return 1.0;
  
  // Il JSON passa direttamente 'r' (es. 24.0). NON invertirlo!
  const r = Math.max(r_param, 1e-9); 
  const p = r / (r + Math.max(mu, 1e-12)); // Probability of success
  const q = 1.0 - p;                       // Probability of failure (1-p)

  // Calcolo P(X=0) = p^r
  const p0 = Math.pow(p, r);

  if (k === 1) return 1.0 - p0;

  // Calcolo P(X=1) = r * q * p0
  const p1 = r * q * p0;

  if (k === 2) return 1.0 - (p0 + p1);

  // Calcolo P(X=2) = (r * (r+1) / 2) * q^2 * p0
  const p2 = (r * (r + 1) / 2.0) * (q * q) * p0;

  if (k === 3) return 1.0 - (p0 + p1 + p2);

  // Fallback per k > 3 (approssimazione o espansione futura)
  return 1.0 - (p0 + p1 + p2); 
}

// FIX 2: PMF Esatta (per calcoli Win/BTTS). Anche qui 'r' diretto.
function nbPmf(mu, r_param, k) {
  if (k < 0) return 0;
  const r = Math.max(r_param, 1e-9);
  const p = r / (r + Math.max(mu, 1e-12)); 
  
  // Log-space per stabilit√† numerica
  let logP = r * Math.log(p) + k * Math.log(1 - p);
  // Aggiungi log(Gamma(r+k)/(Gamma(r)*Gamma(k+1))) -> approx combinatoriale
  for (let i = 0; i < k; i++) {
    logP += Math.log(r + i) - Math.log(1 + i);
  }
  return Math.exp(logP);
}

// FIX 3: Feature Names allineati al JSON V3 (senza "Avg_")
function extractFeaturesV2(parsed) {
  const t = Number(parsed?.state?.Time ?? 0);
  const denom = (t + 1); 
  const st = parsed?.stats || {};
  const l10 = parsed?.l10 || {};
  const goalsH = Number(parsed?.state?.ScoreHome ?? 0);
  const goalsA = Number(parsed?.state?.ScoreAway ?? 0);

  // Somme Casa + Trasferta
  const sot = (st.SOT_H ?? 0) + (st.SOT_A ?? 0);
  const soff = (st.SOFF_H ?? 0) + (st.SOFF_A ?? 0);
  const cor = (st.COR_H ?? 0) + (st.COR_A ?? 0);
  const da = (st.DATT_H ?? 0) + (st.DATT_A ?? 0);
  const att = (st.ATT_H ?? 0) + (st.ATT_A ?? 0);

  const sot10 = (l10.SOT_H ?? 0) + (l10.SOT_A ?? 0);
  const soff10 = (l10.SOFF_H ?? 0) + (l10.SOFF_A ?? 0);
  const cor10 = (l10.COR_H ?? 0) + (l10.COR_A ?? 0);
  const da10 = (l10.DATT_H ?? 0) + (l10.DATT_A ?? 0);
  const att10 = (l10.ATT_H ?? 0) + (l10.ATT_A ?? 0);

  return {
    "const": 1.0,
    "picked_minute": t,
    "Goals_Scored_So_far": goalsH + goalsA,
    
    // Nomi corretti per JSON V3 Live
    "SOT_per_min": sot / denom,
    "SOFF_per_min": soff / denom,
    "CORNER_per_min": cor / denom,
    "DA_per_min": da / denom,
    "ATT_per_min": att / denom,

    "SOT_L10_perMin": sot10 / 10.0,
    "SOFF_L10_perMin": soff10 / 10.0,
    "CORNERS_L10_perMin": cor10 / 10.0, 
    "DA_L10_perMin": da10 / 10.0,
    "ATT_L10_perMin": att10 / 10.0,

    // Home
    "H_SOT_per_min": (st.SOT_H ?? 0) / denom,
    "H_SOFF_per_min": (st.SOFF_H ?? 0) / denom,
    "H_CORNER_per_min": (st.COR_H ?? 0) / denom,
    "H_DA_per_min": (st.DATT_H ?? 0) / denom,
    "H_ATT_per_min": (st.ATT_H ?? 0) / denom,
    "H_SOT_L10_perMin": (l10.SOT_H ?? 0) / 10.0,
    "H_SOFF_L10_perMin": (l10.SOFF_H ?? 0) / 10.0,
    "H_CORNERS_L10_perMin": (l10.COR_H ?? 0) / 10.0,
    "H_DA_L10_perMin": (l10.DATT_H ?? 0) / 10.0,
    "H_ATT_L10_perMin": (l10.ATT_H ?? 0) / 10.0,

    // Away
    "A_SOT_per_min": (st.SOT_A ?? 0) / denom,
    "A_SOFF_per_min": (st.SOFF_A ?? 0) / denom,
    "A_CORNER_per_min": (st.COR_A ?? 0) / denom,
    "A_DA_per_min": (st.DATT_A ?? 0) / denom,
    "A_ATT_per_min": (st.ATT_A ?? 0) / denom,
    "A_SOT_L10_perMin": (l10.SOT_A ?? 0) / 10.0,
    "A_SOFF_L10_perMin": (l10.SOFF_A ?? 0) / 10.0,
    "A_CORNERS_L10_perMin": (l10.COR_A ?? 0) / 10.0,
    "A_DA_L10_perMin": (l10.DATT_A ?? 0) / 10.0,
    "A_ATT_L10_perMin": (l10.ATT_A ?? 0) / 10.0
  };
}

// FIX 4: Compute Mu con gestione Standardizzazione + Protezione Infinity
function computeV2Mu(modelDef, features, minutesRemaining) {
  if (!modelDef || !modelDef.coef) return 0;
  let eta = modelDef.intercept || 0;
  const hasScaling = Array.isArray(modelDef.means) && Array.isArray(modelDef.stds);

  if(Array.isArray(modelDef.feature_cols) && Array.isArray(modelDef.coef)){
      eta = modelDef.intercept || 0;
      for(let i=0; i<modelDef.feature_cols.length; i++){
          const col = modelDef.feature_cols[i];
          let val = features[col] || 0;

          if(hasScaling){
              const mean = modelDef.means[i] || 0;
              let std = modelDef.stds[i];
              if (std < 0.0001) std = 1.0; // Protezione
              val = (val - mean) / std;
          }
          eta += val * (modelDef.coef[i] || 0);
      }
  }
  eta += Math.log(Math.max(minutesRemaining, 1e-6));
  eta = Math.max(-10, Math.min(4.0, eta)); // Tetto massimo
  return Math.exp(eta);
}
/* ==========================================
   PARTE 2: LOGICA PRINCIPALE (SOLO ODDS_TO_BET)
   Sostituisci interamente la funzione pickMatchProbability_NEXT
   ========================================== */
/* ==========================================
   PARTE 2: LOGICA PRINCIPALE (FIX BTTS STATE-AWARE + DYNAMIC CALIB)
   Sostituisci interamente la funzione pickMatchProbability_NEXT
   ========================================== */
function pickMatchProbability_NEXT(parsed){
  const nb = loadNbModel();
  const oddsObj = parsed?.oddsToBet; 
  
  // 1. FONTE UNICA DI VERIT√Ä: ODDS_TO_BET
  const label = (oddsObj?.market || oddsObj?.label || "").trim();
  const labelUp = label.toUpperCase(); // Es: "FT NEXT OVER 1.5" o "BTTS"

  // Dati base partita
  const t = Number(parsed?.state?.Time ?? 0);
  const remFT = Number(parsed?.state?.RemFT ?? 0);
  const remHT = Number(parsed?.state?.RemHT ?? 0);
  const scoreH = Number(parsed?.state?.ScoreHome ?? 0);
  const scoreA = Number(parsed?.state?.ScoreAway ?? 0);
  
  // Rilevamento fase
  let phase = "FT";
  if (labelUp.includes("HT")) phase = "HT";

  // 2. RILEVAMENTO "NEXT"
  const isNext = labelUp.includes("NEXT");
  
  const line = oddsObj?.line ?? 0.5;
  let k_needed = 1; 

  if (isNext) {
      k_needed = Math.floor(line) + 1;
  } else {
      const goalsSoFar = scoreH + scoreA;
      const totalNeeded = Math.floor(line) + 1;
      k_needed = Math.max(1, totalNeeded - goalsSoFar);
  }

  // Identificazione Outcome Key
  let outcomeKey = null;

  if (labelUp.includes("BOTH TEAMS") || labelUp.includes("BTTS")) {
      outcomeKey = "BTTS_FT";
      k_needed = 1; 
  } 
  else if (labelUp.includes("HOME") && labelUp.includes("WIN")) outcomeKey = "HOME_WIN_FT";
  else if (labelUp.includes("AWAY") && labelUp.includes("WIN")) outcomeKey = "AWAY_WIN_FT";
  else if (labelUp.includes("HOME") && labelUp.includes("OVER")) {
      outcomeKey = "HOME_NEXT_0_5_FT"; k_needed = 1; 
  } 
  else if (labelUp.includes("AWAY") && labelUp.includes("OVER")) {
      outcomeKey = "AWAY_NEXT_0_5_FT"; k_needed = 1; 
  } 
  else {
      // Default: Total Goals
      if (k_needed === 1) outcomeKey = phase + "_1plus";
      else if (k_needed === 2) outcomeKey = phase + "_2plus";
      else if (k_needed >= 3) outcomeKey = phase + "_3plus";
      else outcomeKey = phase + "_1plus"; 
  }

  // --- ESECUZIONE CALCOLO MODELLO ---
  if (nb && nb.outcomes && nb.outcomes[outcomeKey]) {
      const outDef = nb.outcomes[outcomeKey];
      const feats = extractFeaturesV2(parsed);
      const minutesRem = (outDef.phase === "HT") ? remHT : remFT;

      let rawProb = 0;
      let muVal = 0;
      // Importante: permettiamo di cambiare il calibratore dinamicamente (per il BTTS)
      let currentIsoKey = outDef.calibrator; 

      if (outDef.type === "total_goals_remaining" || outDef.type === "team_goals_remaining") {
          const muModel = nb.mu_models[outDef.mu_model];
          const dispersion = nb.dispersion[outDef.r]; 
          muVal = computeV2Mu(muModel, feats, minutesRem);
          rawProb = nbProbGE(muVal, dispersion, outDef.k); // Qui usiamo outDef.k come base, ma se √® un Totale dinamico usiamo k_needed
          if (outDef.type === "total_goals_remaining") {
             // Sovrascriviamo se stiamo cercando k diversi (es. next over 2.5 -> k=3)
             // Nota: per ora il JSON ha solo k fissi, ma nbProbGE supporta k dinamico.
             rawProb = nbProbGE(muVal, dispersion, k_needed);
          }
      }
      else if (outDef.type === "derived") {
          const modH = nb.mu_models["ft_home"];
          const modA = nb.mu_models["ft_away"];
          const rTeam = nb.dispersion["team_r"];
          const muH = computeV2Mu(modH, feats, minutesRem);
          const muA = computeV2Mu(modA, feats, minutesRem);
          
          // Default Mu medio
          muVal = (muH + muA) / 2;

          if (outcomeKey === "BTTS_FT") {
              // --- LOGICA BTTS STATE-AWARE AVANZATA ---
              if (scoreH > 0 && scoreA > 0) {
                  // Gi√† vinto (1-1, 2-1...)
                  rawProb = 1.0;
              } 
              else if (scoreH > 0 && scoreA === 0) {
                  // 1-0: Serve solo Away. 
                  // Usiamo Mu Away e il calibratore di Away Next 0.5!
                  muVal = muA;
                  rawProb = nbProbGE(muA, rTeam, 1);
                  currentIsoKey = "AWAY_NEXT_0_5_FT"; 
              } 
              else if (scoreH === 0 && scoreA > 0) {
                  // 0-1: Serve solo Home.
                  // Usiamo Mu Home e il calibratore di Home Next 0.5!
                  muVal = muH;
                  rawProb = nbProbGE(muH, rTeam, 1);
                  currentIsoKey = "HOME_NEXT_0_5_FT";
              } 
              else {
                  // 0-0: Servono entrambi
                  const pH = nbProbGE(muH, rTeam, 1);
                  const pA = nbProbGE(muA, rTeam, 1);
                  rawProb = pH * pA;
                  // Qui teniamo currentIsoKey originale ("BTTS_FT")
              }
          } 
          else if (outcomeKey.includes("WIN")) {
              let sumWin = 0;
              const limit = 15;
              const pmfH = [];
              const pmfA = [];
              for(let i=0; i<limit; i++) pmfH[i] = nbPmf(muH, rTeam, i);
              for(let i=0; i<limit; i++) pmfA[i] = nbPmf(muA, rTeam, i);

              if (outcomeKey === "HOME_WIN_FT") {
                  for (let hRem=0; hRem<limit; hRem++) {
                      for (let aRem=0; aRem<limit; aRem++) {
                          if ( (scoreH + hRem) > (scoreA + aRem) ) sumWin += (pmfH[hRem] * pmfA[aRem]);
                      }
                  }
              } else { // AWAY WIN
                   for (let hRem=0; hRem<limit; hRem++) {
                      for (let aRem=0; aRem<limit; aRem++) {
                          if ( (scoreA + aRem) > (scoreH + hRem) ) sumWin += (pmfH[hRem] * pmfA[aRem]);
                      }
                  }
              }
              rawProb = sumWin;
          }
      }

      // --- CALIBRAZIONE (Isotonic) ---
      let calProb = rawProb;
      if (nb.isotonic && nb.isotonic[currentIsoKey]) {
          const iso = nb.isotonic[currentIsoKey];
          calProb = isoMap(rawProb, iso.x, iso.y);
      }

      return {
          p: clamp01(calProb),
          p_match: clamp01(calProb),
          p_raw: clamp01(rawProb),
          mu: muVal,
          needed: k_needed,
          k: k_needed,
          source: `NB-V2 (${outcomeKey})`
      };
  }

  const legacy = legacyMatchProbability_NEXT(parsed);
  legacy.source = "HEUR";
  legacy.mu = legacy.lambda; 
  legacy.p_raw = legacy.p;
  return legacy;
}
function getArchiveStatsForKey(key){
  const closed = state.history.filter(b => b.key===key && (b.result==="win" || b.result==="loss"));
  const N = closed.length;
  if(N===0) return {N:0, winrate:null};
  const wins = closed.filter(b=>b.result==="win").length;
  return {N, winrate: wins/N};
}
function calcStakeV1(parsed){
  const key = betKeyFromParsed(parsed);
  const odds = parsed.oddsToBet.odds_ref;
  const lpWR = parsed.lp.WR;

  const matchP = pickMatchProbability_NEXT(parsed);
  const P_MATCH = matchP.p;
  const arch = getArchiveStatsForKey(key);
  const P_ARCH = arch.winrate;
  const N = arch.N;

  const warnings = [];
  if(odds===null || odds<=1) return {ok:false, reason:"Quota ODDS_TO_BET non valida", warnings, key};
  if(P_MATCH===null) warnings.push(matchP.reason || "Prob match non disponibile");
  if(lpWR===null) warnings.push("LP.WR non disponibile");
  if(P_ARCH===null) warnings.push("Archivio: nessuna bet chiusa per questo filtro (N=0)");

  const modelTag = (matchP.source === "NB+ISO") ? "NB" : "MATCH";
  let P_REF=null, source=`LP/${modelTag}`;

  // Logica Stake/Blend standard
  if(N < 50){
    if(lpWR!==null && P_MATCH!==null) P_REF = 0.6*lpWR + 0.4*P_MATCH;
    else P_REF = (lpWR!==null) ? lpWR : P_MATCH;
  }else{
    source=`ARCH/${modelTag}`;
    if(P_ARCH!==null && P_MATCH!==null) P_REF = 0.6*P_ARCH + 0.4*P_MATCH;
    else P_REF = (P_ARCH!==null) ? P_ARCH : P_MATCH;
  }
  if(N>=30 && N<70){
    const w=(N-30)/40;
    const left = (lpWR!==null && P_MATCH!==null) ? (0.6*lpWR + 0.4*P_MATCH) : ((lpWR!==null)?lpWR:P_MATCH);
    const right = (P_ARCH!==null && P_MATCH!==null) ? (0.6*P_ARCH + 0.4*P_MATCH) : ((P_ARCH!==null)?P_ARCH:P_MATCH);
    if(left!==null && right!==null) { P_REF = (1-w)*left + w*right; source="BLEND"; }
  }

  const implied = (odds>1) ? 1/odds : null;
  const edge = (P_REF!==null && implied!==null) ? (P_REF - implied) : null;
  let stakePct = 0.01;
  let kelly = null;

  if(P_REF!==null && edge!==null){
    if(edge>0){
      kelly = edge / (odds - 1);
      stakePct = clamp(0.5 * kelly, 0.01, 0.05);
    }else{
      stakePct = 0.01;
      warnings.push("Edge negativo: stake impostato al minimo (1%)");
    }
  }else{
    warnings.push("Probabilit√† insufficiente: stake 1%");
  }

  if(N < 50 && stakePct >= 0.05){ stakePct = 0.04; warnings.push("N<50: cap stake 4%"); }
  if(parsed.lp.N!==null && parsed.lp.N < 500){ stakePct *= 0.8; stakePct=Math.max(stakePct,0.01); warnings.push("LP.N<500: stake -20%"); }

  return {
    ok:true, key, source, N_archive:N, P_REF, implied, edge, kelly,
    stake_pct:stakePct,
    needed_goals: matchP.needed,
    warnings,
    // DEBUG DATA RICHIESTI DALLA IA
    debug: {
      k: matchP.needed,
      mu: matchP.mu,
      p_raw: matchP.p_raw,
      p_iso: matchP.p
    }
  };
}
/* =========================
   Daily snapshot & PnL
========================= */
function ensureDailySnapshot(){
  const t = todayISO();
  if(state.dailySnapshot.date !== t || state.dailySnapshot.bankroll === null){
    state.dailySnapshot.date = t;
    state.dailySnapshot.bankroll = Number(state.settings.bankroll || 0);
    saveState();
  }
}
function getStartBankrollForDate(dateISO){
  const bets = state.history.filter(b=>b.date===dateISO && b.calc?.bankroll_day);
  if(bets.length>0) return Number(bets[bets.length-1].calc.bankroll_day);
  if(state.dailySnapshot.date===dateISO && state.dailySnapshot.bankroll!==null) return Number(state.dailySnapshot.bankroll);
  return Number(state.settings.bankroll || 0);
}
function getTodayClosedPnL(){
  const t = todayISO();
  const brDay = (state.dailySnapshot.date===t) ? Number(state.dailySnapshot.bankroll || 0) : null;
  const todays = state.history.filter(b=>b.date===t && (b.result==="win" || b.result==="loss"));
  const profit = sum(todays.map(b=>b.profit_real));
  const roc = (brDay && brDay>0) ? (profit/brDay) : null;
  return {profit, roc, brDay, closedCount:todays.length};
}
function updateDailyPill(){
  const pillDot=document.getElementById("pillDot");
  const pillText=document.getElementById("pillText");
  const info=getTodayClosedPnL();
  if(info.brDay===null){
    pillDot.className="dot neu"; pillText.textContent="Giornata: neutra"; return;
  }
  if(info.roc!==null && info.roc>=0.03){
    pillDot.className="dot good"; pillText.textContent="Target profit raggiunto";
  }else if(info.roc!==null && info.roc<=-0.10){
    pillDot.className="dot bad"; pillText.textContent="Stop loss raggiunto";
  }else{
    pillDot.className="dot neu"; pillText.textContent="Giornata: neutra";
  }
}
function renderDailyBanner(){
  const wrap=document.getElementById("dailyBannerWrap");
  const info=getTodayClosedPnL();
  wrap.innerHTML="";
  if(info.brDay===null){
    wrap.innerHTML = `<div class="banner"><b>Bankroll giornaliero</b><small>Nessuno snapshot per oggi: verr√† creato alla prima bet aggiunta allo storico.</small></div>`;
    return;
  }
  const rocStr = info.roc===null ? "‚Äî" : fmtPct(info.roc);
  const pStr = fmtMoney(info.profit);
  const brStr = fmtMoney(info.brDay);
  if(info.roc!==null && info.roc>=0.03){
    wrap.innerHTML = `<div class="banner good"><b>TARGET PROFIT RAGGIUNTO</b><small>Oggi: <b>${pStr}</b> (ROC ${rocStr}) su BR day <b>${brStr}</b>.</small></div>`;
  }else if(info.roc!==null && info.roc<=-0.10){
    wrap.innerHTML = `<div class="banner bad"><b>STOP LOSS RAGGIUNTO</b><small>Oggi: <b>${pStr}</b> (ROC ${rocStr}) su BR day <b>${brStr}</b>.</small></div>`;
  }else{
    wrap.innerHTML = `<div class="banner"><b>Giornata in corso</b><small>Oggi: <b>${pStr}</b> (ROC ${rocStr}) su BR day <b>${brStr}</b>. (Bet chiuse: ${info.closedCount})</small></div>`;
  }
}

/* =========================
   Profit calc
========================= */
function calcProfit(result, stake, odds){
  const s = Number(stake);
  const o = Number(odds);
  if(!Number.isFinite(s) || s<=0) return null;
  if(result==="win"){
    if(!Number.isFinite(o) || o<=1) return null;
    return s * (o - 1);
  }
  if(result==="loss") return -s;
  return null;
}
function recalcAll(){
  for(const b of state.history){
    if(b.result==="win" || b.result==="loss"){
      b.profit_real = calcProfit(b.result, b.execution.stake_played, b.execution.odds_played);
    }else{
      b.profit_real = null;
    }
  }
  saveState();
  renderAll();
}

/* =========================
   Calcolatore UI
========================= */
const lpText=document.getElementById("lpText");
const btnParse=document.getElementById("btnParse");
const btnClear=document.getElementById("btnClear");
const btnResetAll=document.getElementById("btnResetAll");
const parseMsg=document.getElementById("parseMsg");
const actionWrap=document.getElementById("actionWrap");
const bankrollInput=document.getElementById("bankrollInput");
const bankrollDay=document.getElementById("bankrollDay");
const btnAddToHistory=document.getElementById("btnAddToHistory");

let lastParsed=null;
let lastStake=null;

// action inputs (created after parse)
let oddsPlayedInput=null;
let stakePlayedInput=null;

function syncBankrollInputs(){
  bankrollInput.value = Number(state.settings.bankroll||0);
  document.getElementById("bankrollInputDash").value = Number(state.settings.bankroll||0);
  bankrollDay.value = (state.dailySnapshot.date===todayISO() && state.dailySnapshot.bankroll!==null)
    ? fmtMoney(state.dailySnapshot.bankroll)
    : "‚Äî";
}
bankrollInput.addEventListener("change", ()=>{
  state.settings.bankroll = Number(bankrollInput.value||0);
  saveState(); syncBankrollInputs(); renderDailyBanner(); updateDailyPill();
});
document.getElementById("bankrollInputDash").addEventListener("change", ()=>{
  state.settings.bankroll = Number(document.getElementById("bankrollInputDash").value||0);
  saveState(); syncBankrollInputs(); renderDailyBanner(); updateDailyPill();
});

btnClear.addEventListener("click", ()=>{
  lpText.value=""; lastParsed=null; lastStake=null;
  parseMsg.innerHTML=""; actionWrap.innerHTML="";
  btnAddToHistory.disabled=true;
});
btnResetAll.addEventListener("click", ()=>{
  if(confirm("Sicuro di voler resettare TUTTO? (storico + impostazioni + snapshot)")) resetAll();
});


// Manual add (Storico)
const btnAddManual=document.getElementById("btnAddManual");
if(btnAddManual){
  btnAddManual.addEventListener("click", ()=>{
    const help=document.getElementById("manHelp");
    if(help) help.textContent="";
    const date = document.getElementById("manDate")?.value || todayISO();
    const methodSel = document.getElementById("manMethod")?.value || "";
    const methodNew = document.getElementById("manMethodNew")?.value || "";
    const method = (methodNew.trim() || methodSel.trim());
    const match = (document.getElementById("manMatch")?.value || "").trim();
    const pick  = (document.getElementById("manPick")?.value || "").trim();
    const odds  = safeNum(document.getElementById("manOdds")?.value);
    const stake = safeNum(document.getElementById("manStake")?.value);

    if(!method || !pick || !odds || !stake){
      if(help) help.textContent = "Compila almeno Metodo, Pick, Quota e Stake.";
      return;
    }
    const bet = {
      id: crypto.randomUUID(),
      date,
      meta:{ Method: method, Match: match || "‚Äî" },
      odds_to_bet:{ label: pick, phase: pick.startsWith("HT")?"HT":"FT", market: pick },
      execution:{ odds_played: odds, stake_played: stake },
      calc:null,
      result:"pending",
      profit_real:0,
      lp: null,
      key: method
    };
    upsertMethod(method, null);
    state.history.unshift(bet);
    saveState();
    renderAll();
    renderMethodSelect();
    // reset inputs
    document.getElementById("manMethodNew").value="";
    document.getElementById("manMatch").value="";
    document.getElementById("manPick").value="";
    document.getElementById("manOdds").value="";
    document.getElementById("manStake").value="";
    if(help) help.textContent="Aggiunta.";
  });
}
/* ==========================================
   TASTO PARSE CON DEBUG (Incolla questo al posto del vecchio btnParse)
   ========================================== */
btnParse.addEventListener("click", ()=>{
  let res;
  try { res = parseNotification(lpText.value); }
  catch(e){ console.error(e); parseMsg.innerHTML = `<div class="note danger">Parse error: ${escapeHtml(String(e?.message||e))}</div>`; return; }
  actionWrap.innerHTML="";
  oddsPlayedInput=null; stakePlayedInput=null;

  if(!res || !res.ok){
    parseMsg.innerHTML = `<div class="errLine"><b>Parse fallito.</b></div>`;
    return;
  }

  lastParsed=res.data;
  
  // --- DEBUG POPUP: CONTROLLIAMO I NUMERI ---
  const s = lastParsed.stats || {};
  alert(`CONTROLLO LETTURA DATI:\n\nTiri Casa: ${s.SOT_H}\nTiri Ospite: ${s.SOT_A}\nCorner Casa: ${s.COR_H}\nCorner Ospite: ${s.COR_A}\n\nSe questi numeri sono tutti 0 o undefined, il parser ha problemi. Se sono giusti, il modello funziona!`);
  // ------------------------------------------

  lastStake=calcStakeV1(lastParsed);

  const warn = [...res.warnings, ...(lastStake.warnings||[])];
  parseMsg.innerHTML = `<div class="okLine"><b>Parse OK.</b> <span class="mono">${escapeHtml(lastParsed.meta.Match)}</span></div>` +
    (warn.length ? `<div class="warnLine"><b>Warning:</b><br/>${warn.map(w=>`‚Ä¢ ${escapeHtml(w)}`).join("<br/>")}</div>` : "");

  syncBankrollInputs();
  const brBase = (state.dailySnapshot.date===todayISO() && state.dailySnapshot.bankroll!==null)
    ? Number(state.dailySnapshot.bankroll) : Number(state.settings.bankroll||0);

  const stakeAmt = roundStake1decMin1((lastStake.stake_pct || 0.01) * brBase);
  const pRef = lastStake.P_REF!==null ? fmtPct(lastStake.P_REF) : "‚Äî";
  const edge = lastStake.edge!==null ? fmtPct(lastStake.edge) : "‚Äî";
  const needed = lastStake.needed_goals ?? "‚Äî";
  const edgeTag = (lastStake.edge!==null && lastStake.edge<=0)
    ? `<span class="badge loss">Edge: ${escapeHtml(edge)} (neg)</span>`
    : `<span class="badge win">Edge: ${escapeHtml(edge)}</span>`;
  const oddsRef = lastParsed.oddsToBet?.odds_ref ?? null;

  // DEBUG STRING AGGIORNATA
  const d = lastStake.debug || {};
  // Mostriamo pi√π dettagli nel box piccolo
  const debugStr = (d.mu !== undefined) 
    ? `k=${d.k} ‚Ä¢ Œº=${Number(d.mu).toFixed(3)} ‚Ä¢ raw=${(Number(d.p_raw)*100).toFixed(1)}%` 
    : "No debug data";

  actionWrap.innerHTML = `
    <div class="actionBlock">
      <div class="stakeBig">
        <div>
          <div class="label">Stake suggerito</div>
          <div class="value">${escapeHtml(fmtMoney(stakeAmt))}</div>
          <div class="sub">Stake%: <span class="mono">${escapeHtml(fmtPct(lastStake.stake_pct))}</span></div>
        </div>
        <div class="right">
          <div class="pillMini">PROB: <b class="mono">${escapeHtml(lastParsed.oddsToBet.phase||"‚Äî")}(+${needed})</b></div>
          <div class="pillMini" style="font-size:10px; opacity:0.8; margin-top:2px">${debugStr}</div>
        </div>
      </div>

      <div class="row" style="margin-top:4px">
        <span class="badge">${escapeHtml(lastParsed.oddsToBet.label)} @ <b class="mono">${escapeHtml(String(lastParsed.oddsToBet.odds_ref))}</b></span>
        <span class="badge">P_REF: <b class="mono">${escapeHtml(pRef)}</b></span>
        ${edgeTag}
      </div>

      <div class="grid" style="grid-template-columns:1fr 1fr; gap:10px; margin-top:12px">
        <div>
          <label>Quota reale</label>
          <input id="oddsPlayed" type="number" min="1" step="0.01" value="${oddsRef!==null ? String(oddsRef) : ""}" />
        </div>
        <div>
          <label>Stake reale</label>
          <input id="stakePlayed" type="number" min="1" step="0.1" value="${stakeAmt.toFixed(1)}" />
        </div>
      </div>
    </div>
  `;
  oddsPlayedInput = document.getElementById("oddsPlayed");
  stakePlayedInput = document.getElementById("stakePlayed");
  btnAddToHistory.disabled=false;
});
btnAddToHistory.addEventListener("click", ()=>{
  if(!lastParsed || !lastStake || !lastStake.ok) return;

  ensureDailySnapshot();
  syncBankrollInputs();

  const brDay = Number(state.dailySnapshot.bankroll||0);
  const stakeAmtRaw = (lastStake.stake_pct || 0.01) * brDay;
  const stakeAmt = roundStake1decMin1(stakeAmtRaw);

  const oddsPlayed = safeNum(oddsPlayedInput?.value) ?? safeNum(lastParsed.oddsToBet?.odds_ref);
  const stakePlayed = safeNum(stakePlayedInput?.value);
  const stakePlayedFinal = roundStake1decMin1(stakePlayed ?? stakeAmt);

  const bet = {
    id: crypto.randomUUID ? crypto.randomUUID() : String(Date.now())+"_"+Math.random().toString(16).slice(2),
    date: todayISO(),
    key: lastStake.key,
    meta: lastParsed.meta,
    state: lastParsed.state,
    stats: lastParsed.stats,
    l10: lastParsed.l10,
    prob: lastParsed.prob,
    press: lastParsed.press,
    late: lastParsed.late,
    odds_to_bet: lastParsed.oddsToBet,
    lp: lastParsed.lp,
    calc: {
      stake_source: lastStake.source,
      N_archive_at_bet: lastStake.N_archive,
      P_REF: lastStake.P_REF,
      implied_prob: lastStake.implied,
      edge: lastStake.edge,
      kelly: lastStake.kelly,
      stake_suggested_pct: lastStake.stake_pct,
      bankroll_day: brDay,
      needed_goals: lastStake.needed_goals
    },
    execution: {
      odds_ref: lastParsed.oddsToBet.odds_ref,
      stake_suggested: stakeAmt,
      odds_played: oddsPlayed,
      stake_played: stakePlayedFinal
    },
    result: "pending",
    profit_real: null,
    raw: lastParsed.raw
  };

  state.history.unshift(bet);
  upsertMethodFromBet(bet);
  saveState();
  renderAll();
  setPage("storico");
});

/* =========================
   Storico UI (bettin.gs style cards)
========================= */
const historyList=document.getElementById("historyList");
const historyEmpty=document.getElementById("historyEmpty");
const historyResultFilter=document.getElementById("historyResultFilter");
const historyDateFilter=document.getElementById("historyDateFilter");
historyResultFilter.addEventListener("change", renderHistory);
historyDateFilter.addEventListener("change", renderHistory);

let selectedBetId=null;
let showRaw=false;
let editingBetId=null;

document.getElementById("btnToggleRaw").addEventListener("click", ()=>{
  if(!selectedBetId) return;
  showRaw = !showRaw;
  renderDetails(state.history.find(b=>b.id===selectedBetId));
});

function resultBadge(res){
  if(res==="win") return `<span class="badge win">Vinta</span>`;
  if(res==="loss") return `<span class="badge loss">Persa</span>`;
  if(res==="not_played") return `<span class="badge pending">Non giocata</span>`;
  return `<span class="badge neutral">Pending</span>`;
}
function profitChip(b){
  if(b.result==="win"){
    return `<span class="chip good">Profit <b>+${escapeHtml(fmtMoney(b.profit_real))}</b></span>`;
  }
  if(b.result==="loss"){
    return `<span class="chip bad">Profit <b>${escapeHtml(fmtMoney(b.profit_real))}</b></span>`;
  }
  return `<span class="chip warn">Profit <b>‚Äî</b></span>`;
}
function stripOddsFromLabel(label){
  if(!label) return "";
  const s=String(label);
  const i=s.indexOf("=");
  return (i>=0 ? s.slice(0,i) : s).trim();
}
function formatPick(b){
  const lab = b?.odds_to_bet?.label || b?.odds_to_bet?.market || "";
  return stripOddsFromLabel(lab);
}

function filterHistoryList(){
  let arr = state.history.slice();
  const rf = historyResultFilter.value;
  const df = historyDateFilter.value;
  if(rf!=="all") arr = arr.filter(b=>b.result===rf);
  if(df!=="all") arr = arr.filter(b=>inDateRange(b.date, df));
  return arr;
}
function renderBetCardHTML(b, mode){
  // mode: "history" or "latest" (same UI)
  const pick = formatPick(b);
  const method = b.meta?.Method || "‚Äî";
  const match = b.meta?.Match || "‚Äî";
  const stakeS = fmtMoney(b.execution?.stake_suggested);
  const stakeP = fmtMoney(b.execution?.stake_played);
  const oddsRef = b.execution?.odds_ref ?? "‚Äî";
  const oddsP = (b.execution?.odds_played ?? "‚Äî");
  const badge = resultBadge(b.result);

  const isEditing = (editingBetId === b.id && mode==="history");

  const topLine = isEditing
    ? `
      <div class="t1">
        <input class="mono" data-edit="date" data-id="${b.id}" type="date" value="${escapeHtml(b.date)}" style="width:auto; min-width:160px"/>
        <input data-edit="method" data-id="${b.id}" type="text" value="${escapeHtml(method)}" style="max-width:220px"/>
      </div>
      <div class="t2">
        <input data-edit="match" data-id="${b.id}" type="text" value="${escapeHtml(match)}" />
      </div>`
    : `
      <div class="t1">
        <span class="date mono">${escapeHtml(b.date)}</span>
        <input data-edit="method" data-id="${b.id}" type="text" value="${escapeHtml(method)}" style="max-width:220px"/>
      </div>
      <div class="t2 mono">${escapeHtml(match)}</div>`;

  const midLine = isEditing
    ? `
      <span class="chip">Pick <b class="mono">${escapeHtml(pick)}</b></span>
      <span class="chip">Stake
        <input data-edit="stake_played" data-id="${b.id}" type="number" step="0.1" min="1"
               value="${escapeHtml(String(b.execution?.stake_played ?? ""))}" style="width:110px"/>
        <span class="muted">(${escapeHtml(stakeS)} sug)</span>
      </span>
      <span class="chip">Odds
        <input data-edit="odds_played" data-id="${b.id}" type="number" step="0.01" min="1"
               value="${escapeHtml(String(b.execution?.odds_played ?? ""))}" style="width:90px"/>
        <span class="muted">(${escapeHtml(String(oddsRef))} ref)</span>
      </span>
      <span class="chip">Esito
        <select data-edit="result" data-id="${b.id}" style="width:auto">
          <option value="win" ${b.result==="win"?"selected":""}>Vinta</option>
          <option value="loss" ${b.result==="loss"?"selected":""}>Persa</option>
          <option value="not_played" ${b.result==="not_played"?"selected":""}>Non giocata</option>
          <option value="pending" ${b.result==="pending"?"selected":""}>Pending</option>
        </select>
      </span>
      ${profitChip(b)}
    `
    : `
      <span class="chip">Pick <b class="mono">${escapeHtml(pick)}</b></span>
      <span class="chip">Stake <b class="mono">${escapeHtml(stakeP)}</b> <span class="muted">(${escapeHtml(stakeS)} sug)</span></span>
      <span class="chip">Odds <b class="mono">${escapeHtml(String(oddsP))}</b> <span class="muted">(${escapeHtml(String(oddsRef))} ref)</span></span>
      ${profitChip(b)}
    `;

  const actions = (mode==="history")
    ? (isEditing
        ? `
          <button class="miniBtn primary" data-act="save" data-id="${b.id}">Salva</button>
          <button class="miniBtn" data-act="cancel" data-id="${b.id}">Annulla</button>
          <button class="miniBtn" data-act="details" data-id="${b.id}">Dettagli</button>
        `
        : `
          <button class="miniBtn primary" data-act="edit" data-id="${b.id}">Modifica</button>
          <button class="miniBtn" data-act="details" data-id="${b.id}">Dettagli</button>
          <button class="miniBtn danger" data-act="del" data-id="${b.id}">Elimina</button>
        `
      )
    : `
        <button class="miniBtn" data-act="details" data-id="${b.id}">Dettagli</button>
        <button class="miniBtn primary" data-act="goto" data-id="${b.id}">Apri nello storico</button>
      `;

  return `
    <div class="betCard">
      <div class="betTop">
        <div class="betTopLeft">${topLine}</div>
        <div>${badge}</div>
      </div>
      <div class="betMid">${midLine}</div>
      <div class="betActions">${actions}</div>
    </div>
  `;
}
function renderHistory(){
  const arr = filterHistoryList();
  historyList.innerHTML="";
  historyEmpty.textContent="";
  if(arr.length===0){
    historyEmpty.textContent="Nessuna bet da mostrare.";
    return;
  }
  for(const b of arr){
    const wrap = document.createElement("div");
    wrap.innerHTML = renderBetCardHTML(b, "history");
    historyList.appendChild(wrap.firstElementChild);
  }
}

historyList.addEventListener("click",(e)=>{
  const btn = e.target.closest("button[data-act]");
  if(!btn) return;
  const id = btn.getAttribute("data-id");
  const act = btn.getAttribute("data-act");
  const b = state.history.find(x=>x.id===id);
  if(!b) return;

  if(act==="del"){
    if(confirm("Eliminare questa bet?")){
      state.history = state.history.filter(x=>x.id!==id);
      saveState();
      if(selectedBetId===id){
        selectedBetId=null;
        document.getElementById("btnToggleRaw").disabled=true;
        document.getElementById("detailsBox").textContent="Seleziona ‚ÄúDettagli‚Äù su una bet.";
      }
      renderAll();
    }
    return;
  }

  if(act==="details"){
    selectedBetId=id;
    showRaw=false;
    document.getElementById("btnToggleRaw").disabled=false;
    document.getElementById("btnToggleRaw").textContent="Mostra JSON raw";
    renderDetails(b);
    return;
  }

  if(act==="edit"){
    editingBetId = id;
    renderHistory();
    return;
  }

  if(act==="cancel"){
    editingBetId = null;
    renderHistory();
    return;
  }

  if(act==="save"){
    const dateEl = document.querySelector(`[data-edit="date"][data-id="${CSS.escape(id)}"]`);
    const methodEl = document.querySelector(`[data-edit="method"][data-id="${CSS.escape(id)}"]`);
    const matchEl = document.querySelector(`[data-edit="match"][data-id="${CSS.escape(id)}"]`);
    const stakeEl = document.querySelector(`[data-edit="stake_played"][data-id="${CSS.escape(id)}"]`);
    const oddsEl  = document.querySelector(`[data-edit="odds_played"][data-id="${CSS.escape(id)}"]`);
    const resEl   = document.querySelector(`[data-edit="result"][data-id="${CSS.escape(id)}"]`);

    if(dateEl && dateEl.value) b.date = dateEl.value;
    if(methodEl && methodEl.value.trim()) b.meta.Method = methodEl.value.trim();
    if(matchEl && matchEl.value.trim()) b.meta.Match = matchEl.value.trim();

    // keep key aligned with Method
    b.key = (b.meta.Method||"").trim();
    upsertMethodFromBet(b);

    const sp = safeNum(stakeEl?.value);
    const op = safeNum(oddsEl?.value);
    if(sp!==null) b.execution.stake_played = roundStake1decMin1(sp);
    if(op!==null) b.execution.odds_played = op;

    if(resEl && resEl.value) b.result = resEl.value;

    if(b.result==="win" || b.result==="loss"){
      b.profit_real = calcProfit(b.result, b.execution.stake_played, b.execution.odds_played);
    }else{
      b.profit_real = null;
    }

    saveState();
    editingBetId = null;
    renderAll();
    return;
  }
});

/* =========================
   Details view ‚Äî SHOW ALL NOTIFICATION FIELDS
========================= */
function kvRowsFromObj(obj, prefix=""){
  if(obj===null || obj===undefined) return [[prefix || "‚Äî", "‚Äî"]];
  if(typeof obj !== "object") return [[prefix || "val", String(obj)]];
  const rows=[];
  const keys=Object.keys(obj);
  if(keys.length===0) return [[prefix || "‚Äî","‚Äî"]];
  for(const k of keys){
    const v = obj[k];
    if(v && typeof v === "object" && !Array.isArray(v)){
      const subKeys=Object.keys(v);
      if(subKeys.length===0){
        rows.push([prefix?`${prefix}.${k}`:k, "‚Äî"]);
      }else{
        for(const sk of subKeys){
          rows.push([prefix?`${prefix}.${k}.${sk}`:`${k}.${sk}`, v[sk]===null||v[sk]===undefined?"‚Äî":String(v[sk])]);
        }
      }
    }else{
      rows.push([prefix?`${prefix}.${k}`:k, (v===null||v===undefined)?"‚Äî":String(v)]);
    }
  }
  return rows;
}
function sec(title, rows){
  return `
    <div class="section">
      <div class="sectionTitle">${escapeHtml(title)}</div>
      <div class="kvList">
        ${rows.map(([k,v])=>`
          <div class="kvItem"><div class="k">${escapeHtml(k)}</div><div class="v">${escapeHtml(v)}</div></div>
        `).join("")}
      </div>
    </div>`;
}
function renderDetails(b){
  const box=document.getElementById("detailsBox");
  if(!b){
    box.textContent="Seleziona ‚ÄúDettagli‚Äù su una bet.";
    return;
  }
  if(showRaw){
    document.getElementById("btnToggleRaw").textContent="Mostra vista leggibile";
    box.innerHTML = `<pre class="mono" style="white-space:pre-wrap;margin:0">${escapeHtml(JSON.stringify(b,null,2))}</pre>`;
    return;
  }
  document.getElementById("btnToggleRaw").textContent="Mostra JSON raw";

  const infoRows = [
    ["id", b.id],
    ["date", b.date],
    ["result", b.result],
    ["profit_real", (b.profit_real===null||b.profit_real===undefined)?"‚Äî":fmtMoney(b.profit_real)],
  ];

  const all = [];
  all.push(sec("INFO", infoRows));
  all.push(sec("META", kvRowsFromObj(b.meta)));
  all.push(sec("STATE", kvRowsFromObj(b.state)));
  all.push(sec("STATS", kvRowsFromObj(b.stats)));
  all.push(sec("L10", kvRowsFromObj(b.l10)));
  all.push(sec("PROB.HT", kvRowsFromObj(b.prob?.HT)));
  all.push(sec("PROB.FT", kvRowsFromObj(b.prob?.FT)));
  all.push(sec("PRESS", kvRowsFromObj(b.press)));
  all.push(sec("LATE", kvRowsFromObj(b.late)));
  all.push(sec("ODDS_TO_BET", kvRowsFromObj(b.odds_to_bet)));
  all.push(sec("LP", kvRowsFromObj(b.lp)));
  all.push(sec("CALC", kvRowsFromObj(b.calc)));
  all.push(sec("EXECUTION", kvRowsFromObj(b.execution)));
  all.push(sec("RAW (notifica)", [["raw", b.raw ? b.raw : "‚Äî"]]));

  box.innerHTML = `<div class="detailsList">${all.join("")}</div>`;
}

/* =========================
   Backup / Restore + actions
========================= */
document.getElementById("btnClearHistory").addEventListener("click", ()=>{
  if(confirm("Svuotare lo storico?")){
    state.history=[];
    saveState();
    selectedBetId=null;
    editingBetId=null;
    document.getElementById("btnToggleRaw").disabled=true;
    document.getElementById("detailsBox").textContent="Seleziona ‚ÄúDettagli‚Äù su una bet.";
    renderAll();
  }
});
document.getElementById("btnRecalc").addEventListener("click", ()=>{
  recalcAll();
  document.getElementById("backupMsg").innerHTML = `<div class="okLine">Ricalcolo completato.</div>`;
});
document.getElementById("btnBackup").addEventListener("click", ()=>{
  const blob = new Blob([JSON.stringify(state,null,2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `bettools_backup_${todayISO()}.json`;
  document.body.appendChild(a);
  a.click(); a.remove();
  URL.revokeObjectURL(url);
  document.getElementById("backupMsg").innerHTML = `<div class="okLine">Backup creato.</div>`;
});
document.getElementById("restoreFile").addEventListener("change", async (e)=>{
  const file = e.target.files && e.target.files[0];
  if(!file) return;
  try{
    const text = await file.text();
    const incoming = JSON.parse(text);
    const replace = confirm("OK = Sostituisci tutto.\nAnnulla = Unisci (merge).");
    if(replace){
      state = incoming;
    }else{
      const cur = loadState();
      const merged = structuredClone(cur);
      merged.settings = incoming.settings || merged.settings;
      merged.dailySnapshot = incoming.dailySnapshot || merged.dailySnapshot;
      const incHist = Array.isArray(incoming.history) ? incoming.history : [];
      const ids = new Set((merged.history||[]).map(b=>b.id));
      for(const b of incHist){
        if(b && b.id && !ids.has(b.id)){
          merged.history.push(b);
          ids.add(b.id);
        }
      }
      state = merged;
    }
    saveState();
    renderAll();
    document.getElementById("backupMsg").innerHTML = `<div class="okLine">Restore completato.</div>`;
  }catch(err){
    document.getElementById("backupMsg").innerHTML = `<div class="errLine">Errore restore: file non valido.</div>`;
  }finally{
    document.getElementById("restoreFile").value="";
  }
});


// NB model UI
(function initNbUI(){
  const ta = document.getElementById("nbJson");
  const st = document.getElementById("nbStatus");
  const refresh = ()=>{
    const nb = loadNbModel();
    if(nb){
      ta.value = JSON.stringify(nb);
      st.textContent = `NB: caricato (${nb.version||"?"})`;
      st.classList.remove("bad"); st.classList.add("good");
    }else{
      ta.value = "";
      st.textContent = "NB: non caricato";
      st.classList.remove("good"); st.classList.add("bad");
    }
  };
  document.getElementById("btnNbSave").addEventListener("click", ()=>{
    try{
      saveNbModel(ta.value.trim());
      refresh();
      toast("Modello NB salvato.");
    }catch(err){
      console.error(err);
      toast("Errore nel JSON NB.");
    }
  });
  document.getElementById("btnNbClear").addEventListener("click", ()=>{
    clearNbModel();
    refresh();
    toast("Modello NB rimosso.");
  });
  refresh();
})();


/* =========================
   Dashboard
========================= */
let dashRange = "all";
let profitRange = "1m";

document.getElementById("dashRangeSelect").addEventListener("change",(e)=>{
  dashRange = e.target.value;
  renderDashboard();
});
document.getElementById("profitRangeSelect").addEventListener("change",(e)=>{
  profitRange = e.target.value;
  renderDashboard();
});
document.getElementById("btnSaveBR").addEventListener("click", ()=>{
  const v = Number(document.getElementById("bankrollInputDash").value||0);
  state.settings.bankroll = v;
  saveState();
  syncBankrollInputs();
  document.getElementById("dashMsg").innerHTML = `<div class="okLine">Bankroll salvato: ${fmtMoney(v)}</div>`;
});
document.getElementById("btnNewDay").addEventListener("click", ()=>{
  if(confirm("Reset snapshot giornaliero?")){
    state.dailySnapshot.date=null;
    state.dailySnapshot.bankroll=null;
    saveState();
    renderAll();
  }
});
document.getElementById("btnGoStorico").addEventListener("click", ()=> setPage("storico"));

function closedBetsFiltered(range){
  return state.history.filter(b=> (b.result==="win" || b.result==="loss") && inDateRange(b.date, range));
}
function computeTotalsRange(range){
  const closed = closedBetsFiltered(range);
  const profit = sum(closed.map(b=>b.profit_real));
  const stakeTot = sum(closed.map(b=>Number(b.execution.stake_played)||0));
  const roi = stakeTot>0 ? (profit/stakeTot) : null;
  const wins = closed.filter(b=>b.result==="win").length;
  const losses = closed.filter(b=>b.result==="loss").length;
  const winrate = closed.length>0 ? wins/closed.length : null;
  return {closedCount:closed.length, wins, losses, profit, stakeTot, roi, winrate, closed};
}
function computeDrawdownFromClosed(closed){
  const sorted = closed.slice().sort((a,b)=> a.date<b.date ? -1 : (a.date>b.date ? 1 : 0));
  let eq=0, peak=0, maxDD=0;
  for(const b of sorted){
    eq += Number(b.profit_real)||0;
    if(eq>peak) peak=eq;
    const dd=peak-eq;
    if(dd>maxDD) maxDD=dd;
  }
  return {maxDD, eqEnd:eq};
}
function computeStreaksFromClosed(closed){
  const sorted = closed.slice().sort((a,b)=> a.date<b.date ? -1 : (a.date>b.date ? 1 : 0));
  let curW=0,curL=0,maxW=0,maxL=0;
  for(const b of sorted){
    if(b.result==="win"){curW++;curL=0;} else {curL++;curW=0;}
    if(curW>maxW) maxW=curW;
    if(curL>maxL) maxL=curL;
  }
  return {maxW,maxL};
}

/* donut */
function drawDonut(wins, losses){
  const c = document.getElementById("donut");
  const ctx = c.getContext("2d");
  const W=c.width, H=c.height;
  ctx.clearRect(0,0,W,H);

  const total = wins+losses;
  const winPct = total>0 ? wins/total : 0;
  const lossPct = total>0 ? losses/total : 0;

  const cx=W/2, cy=H/2, r=Math.min(W,H)*0.28;
  const thickness=r*0.45;

  function arc(pct, start, color){
    const end = start + pct*Math.PI*2;
    ctx.beginPath();
    ctx.strokeStyle=color;
    ctx.lineWidth=thickness;
    ctx.lineCap="butt";
    ctx.arc(cx, cy, r, start, end);
    ctx.stroke();
    return end;
  }

  ctx.beginPath();
  ctx.strokeStyle="rgba(255,255,255,.08)";
  ctx.lineWidth=thickness;
  ctx.arc(cx, cy, r, 0, Math.PI*2);
  ctx.stroke();

  const good="rgba(25,195,125,.95)";
  const bad="rgba(255,77,79,.95)";
  let a=-Math.PI/2;
  a = arc(winPct, a, good);
  arc(lossPct, a, bad);

  ctx.fillStyle="rgba(232,238,252,.92)";
  ctx.font="700 22px "+getComputedStyle(document.body).fontFamily;
  const wr = total>0 ? Math.round(winPct*100) : 0;
  ctx.textAlign="center";
  ctx.fillText(`${wr}%`, cx, cy+8);
  ctx.font="600 12px "+getComputedStyle(document.body).fontFamily;
  ctx.fillStyle="rgba(159,176,208,.95)";
  ctx.fillText("Win Rate", cx, cy+28);

  document.getElementById("wonLabel").innerHTML = `Won: <b>${Math.round(winPct*100)}%</b>`;
  document.getElementById("lostLabel").innerHTML = `Lost: <b>${Math.round(lossPct*100)}%</b>`;
}

/* profit chart */
function filterByRangeMode(closed, mode){
  const now = new Date();
  const cutoff = new Date(now);
  if(mode==="1m") cutoff.setDate(cutoff.getDate()-30);
  if(mode==="3m") cutoff.setDate(cutoff.getDate()-90);
  if(mode==="6m") cutoff.setDate(cutoff.getDate()-180);
  if(mode==="12m") cutoff.setDate(cutoff.getDate()-365);
  if(mode==="all") return closed;
  return closed.filter(b=>{
    const d=new Date(b.date+"T00:00:00");
    return d>=cutoff;
  });
}
function drawProfitChartOn(canvas, closed, mode){
  const ctx = canvas.getContext("2d");
  const W=canvas.width, H=canvas.height;
  ctx.clearRect(0,0,W,H);

  let data = closed.slice().sort((a,b)=> a.date<b.date ? -1 : (a.date>b.date ? 1 : 0));
  data = filterByRangeMode(data, mode);

  let eq=0;
  const pts = data.map(b=> (eq += Number(b.profit_real)||0));
  if(pts.length===0){
    ctx.strokeStyle="rgba(255,255,255,.10)";
    ctx.strokeRect(40,20,W-60,H-50);
    ctx.fillStyle="rgba(159,176,208,.95)";
    ctx.font="600 12px "+getComputedStyle(document.body).fontFamily;
    ctx.fillText("Nessun dato nel periodo", 50, 40);
    return;
  }

  const minY = Math.min(...pts);
  const maxY = Math.max(...pts);
  const pad = (maxY-minY)*0.12 || 1;
  const y0 = minY - pad;
  const y1 = maxY + pad;

  const left=40, top=20, right=W-20, bottom=H-30;
  const plotW = right-left;
  const plotH = bottom-top;

  const xAt = (i)=> left + (pts.length===1 ? plotW/2 : (i/(pts.length-1))*plotW);
  const yAt = (v)=> top + (1-(v-y0)/(y1-y0))*plotH;

  ctx.strokeStyle="rgba(255,255,255,.08)";
  ctx.strokeRect(left, top, plotW, plotH);

  const final = pts[pts.length-1];
  const isPos = final >= 0;
  const fill = isPos ? "rgba(25,195,125,.12)" : "rgba(255,77,79,.12)";
  const line = isPos ? "rgba(25,195,125,.85)" : "rgba(255,77,79,.85)";
  const dot = isPos ? "rgba(25,195,125,.95)" : "rgba(255,77,79,.95)";

  ctx.beginPath();
  ctx.moveTo(left, bottom);
  for(let i=0;i<pts.length;i++) ctx.lineTo(xAt(i), yAt(pts[i]));
  ctx.lineTo(right, bottom);
  ctx.closePath();
  ctx.fillStyle = fill;
  ctx.fill();

  ctx.beginPath();
  for(let i=0;i<pts.length;i++){
    const x=xAt(i), y=yAt(pts[i]);
    if(i===0) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  }
  ctx.strokeStyle=line;
  ctx.lineWidth=2;
  ctx.stroke();

  ctx.fillStyle=dot;
  for(let i=0;i<pts.length;i++){
    const x=xAt(i), y=yAt(pts[i]);
    ctx.beginPath();
    ctx.arc(x,y,3,0,Math.PI*2);
    ctx.fill();
  }

  ctx.fillStyle="rgba(159,176,208,.95)";
  ctx.font="600 11px "+getComputedStyle(document.body).fontFamily;
  ctx.textAlign="right";
  ctx.fillText(`Cumulato: ${final.toFixed(2)}`, right, top-6);
}
function drawProfitChart(closed, mode){
  drawProfitChartOn(document.getElementById("profitChart"), closed, mode);
}

function renderLatest(){
  const latestList = document.getElementById("latestList");
  const latestEmpty = document.getElementById("latestEmpty");
  latestList.innerHTML = "";
  latestEmpty.textContent = "";
  const arr = state.history.slice(0, 10);
  if(arr.length===0){
    latestEmpty.textContent = "Nessuna bet nello storico.";
    return;
  }
  for(const b of arr){
    const wrap = document.createElement("div");
    wrap.innerHTML = renderBetCardHTML(b, "latest");
    latestList.appendChild(wrap.firstElementChild);
  }
}
document.getElementById("latestList").addEventListener("click",(e)=>{
  const btn = e.target.closest("button[data-act]");
  if(!btn) return;
  const id = btn.getAttribute("data-id");
  const act = btn.getAttribute("data-act");
  const b = state.history.find(x=>x.id===id);
  if(!b) return;

  if(act==="details"){
    selectedBetId=id;
    showRaw=false;
    document.getElementById("btnToggleRaw").disabled=false;
    document.getElementById("btnToggleRaw").textContent="Mostra JSON raw";
    renderDetails(b);
    setPage("storico");
    return;
  }
  if(act==="goto"){
    setPage("storico");
    selectedBetId=id;
    showRaw=false;
    document.getElementById("btnToggleRaw").disabled=false;
    document.getElementById("btnToggleRaw").textContent="Mostra JSON raw";
    renderDetails(b);
    return;
  }
});

function renderDashboard(){
  const t = computeTotalsRange(dashRange);
  const dd = computeDrawdownFromClosed(t.closed);
  const st = computeStreaksFromClosed(t.closed);

  const kpis=document.getElementById("dashKpis");
  kpis.innerHTML = `
    <div class="kpi"><span>Bet chiuse</span><b>${t.closedCount}</b></div>
    <div class="kpi"><span>Winrate</span><b>${t.winrate===null ? "‚Äî" : fmtPct(t.winrate)}</b></div>
    <div class="kpi"><span>Profitto</span><b class="${t.profit>=0?'good':'bad'}">${fmtMoney(t.profit)}</b></div>
    <div class="kpi"><span>ROI</span><b class="${(t.roi!==null && t.roi>=0)?'good':'bad'}">${t.roi===null?"‚Äî":fmtPct(t.roi)}</b></div>
    <div class="kpi"><span>Max Drawdown</span><b class="mono">${fmtMoney(dd.maxDD)}</b></div>
    <div class="kpi"><span>Streak (W / L)</span><b class="mono">${st.maxW} / ${st.maxL}</b></div>
  `;

  drawDonut(t.wins, t.losses);
  drawProfitChart(t.closed, profitRange);
  renderLatest();
}

/* =========================
   Riepilogo temporale (ROI + ROC + Stato day)
========================= */
document.getElementById("timeGroupSelect").addEventListener("change",(e)=>{
  timeGroup = e.target.value;
  renderTimeSummary();
});
let timeGroup="day";

function periodKey(dateISO, mode){
  if(mode==="day") return dateISO;
  if(mode==="week") return startOfWeekISO(dateISO);
  if(mode==="month") return monthKey(dateISO);
  return dateISO;
}
function periodLabel(key, mode){
  if(mode==="day") return key;
  if(mode==="week") return `Week ${key}`;
  if(mode==="month") return key;
  return key;
}
function dayStatusFromROC(roc){
  if(roc===null) return {label:"", cls:""};
  if(roc>=0.03) return {label:"Target", cls:"badge win"};
  if(roc<=-0.10) return {label:"Stop", cls:"badge loss"};
  return {label:"", cls:""};
}

function renderTimeSummary(){
  const empty=document.getElementById("timeEmpty");
  const table=document.getElementById("timeTable");
  const body=document.getElementById("timeBody");

  const closed = state.history.filter(b=>b.result==="win"||b.result==="loss");
  if(closed.length===0){
    empty.textContent="Nessuna bet chiusa: riepilogo non disponibile.";
    table.style.display="none";
    body.innerHTML="";
    return;
  }
  empty.textContent="";
  table.style.display="";
  body.innerHTML="";

  const map=new Map();
  for(const b of closed){
    const key=periodKey(b.date, timeGroup);
    if(!map.has(key)) map.set(key,{key,bets:0,wins:0,losses:0,stake:0,profit:0, brDay:null});
    const o=map.get(key);
    o.bets++;
    if(b.result==="win") o.wins++; else o.losses++;
    o.stake += Number(b.execution.stake_played)||0;
    o.profit += Number(b.profit_real)||0;

    if(timeGroup==="day"){
      if(o.brDay===null){
        o.brDay = getStartBankrollForDate(b.date);
      }
    }
  }

  const rows=[...map.values()].sort((a,b)=> a.key<b.key ? 1 : -1);
  for(const r of rows){
    const closedN=r.wins+r.losses;
    const wr=closedN>0 ? r.wins/closedN : null;
    const roi=r.stake>0 ? r.profit/r.stake : null;
    const roc = (timeGroup==="day" && r.brDay && r.brDay>0) ? (r.profit/r.brDay) : null;
    const status = (timeGroup==="day") ? dayStatusFromROC(roc) : {label:"", cls:""};

    const profitCls = r.profit>=0 ? "badge win" : "badge loss";
    const roiCls = (roi!==null && roi>=0) ? "badge win" : "badge loss";
    const rocCls = (roc!==null && roc>=0) ? "badge win" : (roc!==null ? "badge loss" : "badge neutral");

    const tr=document.createElement("tr");
    tr.innerHTML = `
      <td class="mono">${escapeHtml(periodLabel(r.key,timeGroup))}</td>
      <td>${r.bets}</td>
      <td class="mono">${wr===null?"‚Äî":fmtPct(wr)}</td>
      <td><span class="${profitCls}">${escapeHtml(fmtMoney(r.profit))}</span></td>
      <td><span class="${roiCls}">${roi===null?"‚Äî":escapeHtml(fmtPct(roi))}</span></td>
      <td><span class="${rocCls}">${roc===null?"‚Äî":escapeHtml(fmtPct(roc))}</span></td>
      <td>${status.label ? `<span class="${status.cls}">${escapeHtml(status.label)}</span>` : ""}</td>
    `;
    body.appendChild(tr);
  }
}

/* =========================
   Riepilogo filtri (trend + dettaglio filtro)
========================= */
document.getElementById("filterSort").addEventListener("change", renderFilters);

function computeRangeForBets(bets, daysBackStart, daysBackEnd){
  // include (now - daysBackStart) .. (now - daysBackEnd)
  // example last30: start=0 end=30
  const now = new Date();
  const start = new Date(now); start.setDate(start.getDate()-daysBackStart);
  const end = new Date(now); end.setDate(end.getDate()-daysBackEnd);
  const sel = bets.filter(b=>{
    const d=new Date(b.date+"T00:00:00");
    return d<=start && d>=end;
  });
  const profit = sum(sel.map(b=>b.profit_real));
  const stakeTot = sum(sel.map(b=>Number(b.execution.stake_played)||0));
  const roi = stakeTot>0 ? profit/stakeTot : null;
  const wins = sel.filter(b=>b.result==="win").length;
  const losses = sel.filter(b=>b.result==="loss").length;
  const wr = (wins+losses)>0 ? wins/(wins+losses) : null;
  return {sel, profit, stakeTot, roi, wr, n:(wins+losses)};
}
function trendLabel(delta){
  if(delta===null) return {txt:"‚Äî", cls:"trendFlat"};
  if(delta>0.01) return {txt:"‚ñ≤ in miglioramento", cls:"trendUp"};
  if(delta<-0.01) return {txt:"‚ñº in peggioramento", cls:"trendDown"};
  return {txt:"‚ñ† stabile", cls:"trendFlat"};
}
function filterKeyName(b){
  return `${b.meta?.Method || "‚Äî"} ‚Ä¢ ${formatPick(b)}`;
}
function filterClosedBets(name){
  return state.history.filter(b=>{
    if(filterKeyName(b)!==name) return false;
    return (b.result==="win" || b.result==="loss");
  });
}
function renderFilterDetailHTML(name){
  const closed = filterClosedBets(name).slice().sort((a,b)=> a.date<b.date ? -1 : 1);
  const totalProfit = sum(closed.map(b=>b.profit_real));
  const stakeTot = sum(closed.map(b=>Number(b.execution.stake_played)||0));
  const roi = stakeTot>0 ? totalProfit/stakeTot : null;
  const wins = closed.filter(b=>b.result==="win").length;
  const losses = closed.filter(b=>b.result==="loss").length;
  const wr = (wins+losses)>0 ? wins/(wins+losses) : null;

  const tableRows = [
    {label:"1m", days:30},
    {label:"3m", days:90},
    {label:"6m", days:180},
    {label:"12m", days:365},
  ].map(x=>{
    const nowRange = computeRangeForBets(closed, 0, x.days);
    return `
      <tr>
        <td class="mono">${x.label}</td>
        <td>${nowRange.n}</td>
        <td class="mono">${nowRange.wr===null?"‚Äî":fmtPct(nowRange.wr)}</td>
        <td class="mono">${nowRange.roi===null?"‚Äî":fmtPct(nowRange.roi)}</td>
        <td class="mono">${fmtMoney(nowRange.profit)}</td>
      </tr>
    `;
  }).join("");

  const canvasId = "fchart_"+Math.random().toString(16).slice(2);

  return `
    <div class="section" style="margin-top:10px">
      <div class="sectionTitle">Dettaglio filtro</div>

      <div class="kpiGrid" style="margin-bottom:10px">
        <div class="kpi"><span>Bet chiuse</span><b>${wins+losses}</b></div>
        <div class="kpi"><span>Winrate</span><b>${wr===null?"‚Äî":fmtPct(wr)}</b></div>
        <div class="kpi"><span>Profitto</span><b class="${totalProfit>=0?"good":"bad"}">${fmtMoney(totalProfit)}</b></div>
        <div class="kpi"><span>ROI</span><b class="${(roi!==null && roi>=0)?"good":"bad"}">${roi===null?"‚Äî":fmtPct(roi)}</b></div>
      </div>

      ${(()=>{ 
        const lp = state.methodLP?.[name];
        if(!lp) return '';
        const wrLP = isFinite(lp.WR)? lp.WR/100 : null;
        const aoLP = isFinite(lp.AO)? lp.AO : null;
        const nLP  = isFinite(lp.N)? lp.N : null;
        const wrNow = agg.closed? (agg.win/agg.closed) : null;
        const dWR = (wrLP!==null && wrNow!==null) ? (wrNow-wrLP) : null;
        return `
          <div class="card" style="margin-top:10px">
            <div class="cardHeader"><b>Confronto LivePick (ultima notifica salvata)</b></div>
            <div class="kpiGrid">
              <div class="kpi"><span>WR LP</span><b>${wrLP!==null? fmtPct(wrLP):"‚Äî"}</b></div>
              <div class="kpi"><span>WR tuo</span><b>${wrNow!==null? fmtPct(wrNow):"‚Äî"}</b></div>
              <div class="kpi"><span>Œî WR</span><b>${dWR!==null? fmtPct(dWR):"‚Äî"}</b></div>
              <div class="kpi"><span>AO LP</span><b>${aoLP!==null? fmtNum(aoLP,2):"‚Äî"}</b></div>
              <div class="kpi"><span>N LP</span><b>${nLP!==null? fmtInt(nLP):"‚Äî"}</b></div>
            </div>
          </div>
        `;
      })()}



      <div class="card" style="padding:10px; margin-bottom:10px">
        <div class="cardHeader" style="margin-bottom:6px">
          <div>
            <b>Profit Chart (solo filtro)</b><br/>
            <small>Cumulato bet chiuse</small>
          </div>
          <div class="row">
            <select data-fmode="${escapeHtml(name)}" class="filterChartMode" style="width:auto; min-width:140px">
              <option value="1m" selected>1m</option>
              <option value="3m">3m</option>
              <option value="6m">6m</option>
              <option value="12m">12m</option>
              <option value="all">all</option>
            </select>
          </div>
        </div>
        <canvas id="${canvasId}" width="820" height="280"></canvas>
      </div>

      <div style="overflow:auto">
        <table>
          <thead>
            <tr>
              <th>Periodo</th>
              <th>Bet chiuse</th>
              <th>Winrate</th>
              <th>ROI</th>
              <th>Profitto</th>
            </tr>
          </thead>
          <tbody>${tableRows}</tbody>
        </table>
      </div>

      <div class="help" style="margin-top:8px">Nota: la tabella √® calcolata sulle bet chiuse (win/loss) del filtro.</div>
    </div>

    <script>
      (function(){
        const name = ${JSON.stringify(name)};
        const closed = ${JSON.stringify(closed.map(b=>({date:b.date, profit_real:b.profit_real, execution:b.execution, result:b.result})))};
        // rebuild minimal objects for draw
        const canvas = document.getElementById(${JSON.stringify(canvasId)});
        const toBets = ()=>closed.map(x=>({date:x.date, profit_real:x.profit_real, execution:x.execution, result:x.result}));
        const draw = (mode)=>drawProfitChartOn(canvas, toBets(), mode);
        draw("1m");
        const sel = document.querySelector('select.filterChartMode[data-fmode="'+CSS.escape(name)+'"]');
        if(sel){
          sel.addEventListener("change",(e)=> draw(e.target.value));
        }
      })();
    <\/script>
  `;
}

function renderFilters(){
  const grid=document.getElementById("filtersGrid");
  const sort=document.getElementById("filterSort").value;

  const groups=new Map();
  for(const b of state.history){
    const name = filterKeyName(b);
    if(!groups.has(name)){
      groups.set(name, {
        name, bets:0, wins:0, losses:0,
        stake:0, profit:0,
        oddsSum:0, oddsN:0,
        lastLP: null, lastDate: null,
        hasClosed:false
      });
    }
    const g=groups.get(name);
    g.bets++;

    if(!g.lastDate || b.date >= g.lastDate){
      g.lastDate = b.date;
      g.lastLP = b.lp || null;
    }

    const o = (b.execution?.odds_played ?? b.execution?.odds_ref);
    if(o && Number(o)>1){ g.oddsSum += Number(o); g.oddsN++; }

    if(b.result==="win"||b.result==="loss"){
      g.hasClosed=true;
      g.stake += Number(b.execution.stake_played)||0;
      g.profit += Number(b.profit_real)||0;
      if(b.result==="win") g.wins++; else g.losses++;
    }
  }

  let arr=[...groups.values()].map(g=>{
    const closedN=g.wins+g.losses;
    const winrate = closedN>0 ? g.wins/closedN : null;
    const roi = g.stake>0 ? g.profit/g.stake : null;
    const avgOdds = g.oddsN>0 ? g.oddsSum/g.oddsN : null;
    const lp = g.lastLP;
    const lpWR = lp?.WR ?? null;
    const lpROI = lp?.ROI ?? null;
    const lpProfit = (lp?.Profit ?? null);

    // Trend (ROI last30 vs prev30) on CLOSED bets
    const closedBets = filterClosedBets(g.name);
    const last30 = computeRangeForBets(closedBets, 0, 30);
    const prev30 = computeRangeForBets(closedBets, 30, 60);
    const delta = (last30.roi!==null && prev30.roi!==null) ? (last30.roi - prev30.roi) : null;
    const tLab = trendLabel(delta);

    return {...g, closedN, winrate, roi, avgOdds, lpWR, lpROI, lpProfit, trendText:tLab.txt, trendCls:tLab.cls, trendDelta:delta};
  });

  arr.sort((a,b)=>{
    const va = (sort==="roi") ? (a.roi ?? -1e9)
      : (sort==="profit") ? a.profit
      : (sort==="winrate") ? (a.winrate ?? -1e9)
      : (sort==="bets") ? a.bets
      : a.name.localeCompare(b.name);
    const vb = (sort==="roi") ? (b.roi ?? -1e9)
      : (sort==="profit") ? b.profit
      : (sort==="winrate") ? (b.winrate ?? -1e9)
      : (sort==="bets") ? b.bets
      : 0;
    if(sort==="name") return va;
    return vb - va;
  });

  grid.innerHTML="";
  if(arr.length===0){
    grid.innerHTML = `<div class="card"><div class="help">Nessun dato.</div></div>`;
    return;
  }

  const compLine = (label, val, lpVal, delta, isPct=true)=>{
    const v = val===null ? "‚Äî" : (isPct ? fmtPct(val) : fmtMoney(val));
    const lpS = lpVal===null ? "" : ` (LP ${isPct?fmtPct(lpVal):fmtMoney(lpVal)})`;
    const dS = delta===null ? "" : ` ‚Ä¢ Œî ${isPct?fmtPct(delta):fmtMoney(delta)}`;
    return `<div class="help">${escapeHtml(label)}: <b>${escapeHtml(v)}</b>${escapeHtml(lpS)}${escapeHtml(dS)}</div>`;
  };

  for(const g of arr){
    const roiStr = g.roi===null ? "‚Äî" : fmtPct(g.roi);
    const roiCls = (g.roi!==null && g.roi>=0) ? "badge win" : "badge loss";
    const profitCls = g.profit>=0 ? "good" : "bad";

    const wrDelta = (g.winrate!==null && g.lpWR!==null) ? (g.winrate - g.lpWR) : null;
    const roiDelta = (g.roi!==null && g.lpROI!==null) ? (g.roi - g.lpROI) : null;
    const lpProfitNum = (g.lpProfit===null || g.lpProfit===undefined) ? null : Number(g.lpProfit);
    const pDelta = (lpProfitNum!==null) ? (g.profit - lpProfitNum) : null;

    const detailHTML = renderFilterDetailHTML(g.name);

    const card=document.createElement("div");
    card.className="card";
    card.innerHTML = `
      <div class="cardHeader">
        <div>
          <b>${escapeHtml(g.name)}</b><br/>
          <small>${g.bets} bet</small>
        </div>
        <div class="${roiCls}">${g.roi===null?"ROI ‚Äî":"ROI "+roiStr}</div>
      </div>

      <div class="row">
        <span class="badge">Vinte: <b>${g.winrate===null?"‚Äî":fmtPct(g.winrate)}</b></span>
        <span class="badge">Quota media: <b class="mono">${g.avgOdds===null?"‚Äî":g.avgOdds.toFixed(2)}</b></span>
        <span class="badge">Profitto: <b class="${profitCls} mono">${fmtMoney(g.profit)}</b></span>
      </div>

      <div class="row" style="margin-top:8px">
        <span class="badge">Trend: <b class="${escapeHtml(g.trendCls)}">${escapeHtml(g.trendText)}</b></span>
        <span class="badge">Œî ROI (30d): <b class="mono">${g.trendDelta===null?"‚Äî":fmtPct(g.trendDelta)}</b></span>
      </div>

      <div style="margin-top:8px">
        ${compLine("% Vinte", g.winrate, g.lpWR, wrDelta, true)}
        ${compLine("ROI", g.roi, g.lpROI, roiDelta, true)}
        ${compLine("Profit", g.profit, lpProfitNum, pDelta, false)}
      </div>

      <details style="margin-top:10px">
        <summary>Dettagli filtro</summary>
        ${detailHTML}
      </details>
    `;
    grid.appendChild(card);
  }
}

/* =========================
   Daily UI refresh
========================= */
function renderAll(){
  syncBankrollInputs();
  renderDailyBanner();
  updateDailyPill();
  renderHistory();
  renderDashboard();
  renderTimeSummary();
  renderFilters();
}
renderAll();
renderMethodSelect();
const md=document.getElementById('manDate'); if(md) md.value=todayISO();
document.getElementById("btnToggleRaw").disabled = true;

/* =========================
   iOS26 Theme (UI ONLY)
========================= */
(function(){
  const root = document.documentElement;
  const btn = document.getElementById("themeToggle");
  const KEY = "bt_theme_mode"; // 'light' | 'dark' | 'system'

  function systemPrefersDark(){
    return window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
  }
  function apply(mode){
    const effective = (mode==="system") ? (systemPrefersDark() ? "dark" : "light") : mode;
    root.dataset.theme = effective;
    if(btn){
      btn.textContent = effective === "dark" ? "‚òÄÔ∏é" : "‚òæ";
      btn.title = effective === "dark" ? "Tema chiaro" : "Tema scuro";
      btn.setAttribute("aria-label", effective === "dark" ? "Passa a tema chiaro" : "Passa a tema scuro");
    }
    // redraw charts without changing calculations
    requestAnimationFrame(()=>{
      try{ if(typeof drawDonut==="function") drawDonut(); }catch(e){}
      try{ if(typeof drawProfitChart==="function") drawProfitChart(); }catch(e){}
    });
  }

  const stored = localStorage.getItem(KEY) || "system";
  apply(stored);

  if(window.matchMedia){
    const mq = window.matchMedia("(prefers-color-scheme: dark)");
    mq.addEventListener?.("change", ()=>{ if((localStorage.getItem(KEY) || "system")==="system") apply("system"); });
  }

  if(btn){
    btn.addEventListener("click", ()=>{
      const current = root.dataset.theme === "dark" ? "dark" : "light";
      const next = current === "dark" ? "light" : "dark";
      localStorage.setItem(KEY, next);
      apply(next);
    });
  }
})();

</script>
</body>
</html>
